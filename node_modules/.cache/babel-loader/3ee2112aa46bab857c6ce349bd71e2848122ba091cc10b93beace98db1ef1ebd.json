{"ast":null,"code":"import deepEquals from './deepEquals';\nimport { getDefaultFormState, getDisplayLabel, getClosestMatchingOption, getFirstMatchingOption, getMatchingOption, isFilesArray, isMultiSelect, isSelect, mergeValidationData, retrieveSchema, sanitizeDataForNewSchema, toIdSchema, toPathSchema } from './schema';\n/** The `SchemaUtils` class provides a wrapper around the publicly exported APIs in the `utils/schema` directory such\n * that one does not have to explicitly pass the `validator`, `rootSchema`, or `experimental_defaultFormStateBehavior` to each method.\n * Since these generally do not change across a `Form`, this allows for providing a simplified set of APIs to the\n * `@rjsf/core` components and the various themes as well. This class implements the `SchemaUtilsType` interface.\n */\nclass SchemaUtils {\n  /** Constructs the `SchemaUtils` instance with the given `validator` and `rootSchema` stored as instance variables\n   *\n   * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n   * @param rootSchema - The root schema that will be forwarded to all the APIs\n   * @param experimental_defaultFormStateBehavior - Configuration flags to allow users to override default form state behavior\n   */\n  constructor(validator, rootSchema, experimental_defaultFormStateBehavior) {\n    this.rootSchema = rootSchema;\n    this.validator = validator;\n    this.experimental_defaultFormStateBehavior = experimental_defaultFormStateBehavior;\n  }\n  /** Returns the `ValidatorType` in the `SchemaUtilsType`\n   *\n   * @returns - The `ValidatorType`\n   */\n  getValidator() {\n    return this.validator;\n  }\n  /** Determines whether either the `validator` and `rootSchema` differ from the ones associated with this instance of\n   * the `SchemaUtilsType`. If either `validator` or `rootSchema` are falsy, then return false to prevent the creation\n   * of a new `SchemaUtilsType` with incomplete properties.\n   *\n   * @param validator - An implementation of the `ValidatorType` interface that will be compared against the current one\n   * @param rootSchema - The root schema that will be compared against the current one\n   * @param [experimental_defaultFormStateBehavior] Optional configuration object, if provided, allows users to override default form state behavior\n   * @returns - True if the `SchemaUtilsType` differs from the given `validator` or `rootSchema`\n   */\n  doesSchemaUtilsDiffer(validator, rootSchema, experimental_defaultFormStateBehavior = {}) {\n    if (!validator || !rootSchema) {\n      return false;\n    }\n    return this.validator !== validator || !deepEquals(this.rootSchema, rootSchema) || !deepEquals(this.experimental_defaultFormStateBehavior, experimental_defaultFormStateBehavior);\n  }\n  /** Returns the superset of `formData` that includes the given set updated to include any missing fields that have\n   * computed to have defaults provided in the `schema`.\n   *\n   * @param schema - The schema for which the default state is desired\n   * @param [formData] - The current formData, if any, onto which to provide any missing defaults\n   * @param [includeUndefinedValues=false] - Optional flag, if true, cause undefined values to be added as defaults.\n   *          If \"excludeObjectChildren\", pass `includeUndefinedValues` as false when computing defaults for any nested\n   *          object properties.\n   * @returns - The resulting `formData` with all the defaults provided\n   */\n  getDefaultFormState(schema, formData, includeUndefinedValues = false) {\n    return getDefaultFormState(this.validator, schema, formData, this.rootSchema, includeUndefinedValues, this.experimental_defaultFormStateBehavior);\n  }\n  /** Determines whether the combination of `schema` and `uiSchema` properties indicates that the label for the `schema`\n   * should be displayed in a UI.\n   *\n   * @param schema - The schema for which the display label flag is desired\n   * @param [uiSchema] - The UI schema from which to derive potentially displayable information\n   * @param [globalOptions={}] - The optional Global UI Schema from which to get any fallback `xxx` options\n   * @returns - True if the label should be displayed or false if it should not\n   */\n  getDisplayLabel(schema, uiSchema, globalOptions) {\n    return getDisplayLabel(this.validator, schema, uiSchema, this.rootSchema, globalOptions);\n  }\n  /** Determines which of the given `options` provided most closely matches the `formData`.\n   * Returns the index of the option that is valid and is the closest match, or 0 if there is no match.\n   *\n   * The closest match is determined using the number of matching properties, and more heavily favors options with\n   * matching readOnly, default, or const values.\n   *\n   * @param formData - The form data associated with the schema\n   * @param options - The list of options that can be selected from\n   * @param [selectedOption] - The index of the currently selected option, defaulted to -1 if not specified\n   * @param [discriminatorField] - The optional name of the field within the options object whose value is used to\n   *          determine which option is selected\n   * @returns - The index of the option that is the closest match to the `formData` or the `selectedOption` if no match\n   */\n  getClosestMatchingOption(formData, options, selectedOption, discriminatorField) {\n    return getClosestMatchingOption(this.validator, this.rootSchema, formData, options, selectedOption, discriminatorField);\n  }\n  /** Given the `formData` and list of `options`, attempts to find the index of the first option that matches the data.\n   * Always returns the first option if there is nothing that matches.\n   *\n   * @param formData - The current formData, if any, used to figure out a match\n   * @param options - The list of options to find a matching options from\n   * @param [discriminatorField] - The optional name of the field within the options object whose value is used to\n   *          determine which option is selected\n   * @returns - The firstindex of the matched option or 0 if none is available\n   */\n  getFirstMatchingOption(formData, options, discriminatorField) {\n    return getFirstMatchingOption(this.validator, formData, options, this.rootSchema, discriminatorField);\n  }\n  /** Given the `formData` and list of `options`, attempts to find the index of the option that best matches the data.\n   * Deprecated, use `getFirstMatchingOption()` instead.\n   *\n   * @param formData - The current formData, if any, onto which to provide any missing defaults\n   * @param options - The list of options to find a matching options from\n   * @param [discriminatorField] - The optional name of the field within the options object whose value is used to\n   *          determine which option is selected\n   * @returns - The index of the matched option or 0 if none is available\n   * @deprecated\n   */\n  getMatchingOption(formData, options, discriminatorField) {\n    return getMatchingOption(this.validator, formData, options, this.rootSchema, discriminatorField);\n  }\n  /** Checks to see if the `schema` and `uiSchema` combination represents an array of files\n   *\n   * @param schema - The schema for which check for array of files flag is desired\n   * @param [uiSchema] - The UI schema from which to check the widget\n   * @returns - True if schema/uiSchema contains an array of files, otherwise false\n   */\n  isFilesArray(schema, uiSchema) {\n    return isFilesArray(this.validator, schema, uiSchema, this.rootSchema);\n  }\n  /** Checks to see if the `schema` combination represents a multi-select\n   *\n   * @param schema - The schema for which check for a multi-select flag is desired\n   * @returns - True if schema contains a multi-select, otherwise false\n   */\n  isMultiSelect(schema) {\n    return isMultiSelect(this.validator, schema, this.rootSchema);\n  }\n  /** Checks to see if the `schema` combination represents a select\n   *\n   * @param schema - The schema for which check for a select flag is desired\n   * @returns - True if schema contains a select, otherwise false\n   */\n  isSelect(schema) {\n    return isSelect(this.validator, schema, this.rootSchema);\n  }\n  /** Merges the errors in `additionalErrorSchema` into the existing `validationData` by combining the hierarchies in\n   * the two `ErrorSchema`s and then appending the error list from the `additionalErrorSchema` obtained by calling\n   * `getValidator().toErrorList()` onto the `errors` in the `validationData`. If no `additionalErrorSchema` is passed,\n   * then `validationData` is returned.\n   *\n   * @param validationData - The current `ValidationData` into which to merge the additional errors\n   * @param [additionalErrorSchema] - The additional set of errors\n   * @returns - The `validationData` with the additional errors from `additionalErrorSchema` merged into it, if provided.\n   * @deprecated - Use the `validationDataMerge()` function exported from `@rjsf/utils` instead. This function will be\n   *        removed in the next major release.\n   */\n  mergeValidationData(validationData, additionalErrorSchema) {\n    return mergeValidationData(this.validator, validationData, additionalErrorSchema);\n  }\n  /** Retrieves an expanded schema that has had all of its conditions, additional properties, references and\n   * dependencies resolved and merged into the `schema` given a `rawFormData` that is used to do the potentially\n   * recursive resolution.\n   *\n   * @param schema - The schema for which retrieving a schema is desired\n   * @param [rawFormData] - The current formData, if any, to assist retrieving a schema\n   * @returns - The schema having its conditions, additional properties, references and dependencies resolved\n   */\n  retrieveSchema(schema, rawFormData) {\n    return retrieveSchema(this.validator, schema, this.rootSchema, rawFormData);\n  }\n  /** Sanitize the `data` associated with the `oldSchema` so it is considered appropriate for the `newSchema`. If the\n   * new schema does not contain any properties, then `undefined` is returned to clear all the form data. Due to the\n   * nature of schemas, this sanitization happens recursively for nested objects of data. Also, any properties in the\n   * old schemas that are non-existent in the new schema are set to `undefined`.\n   *\n   * @param [newSchema] - The new schema for which the data is being sanitized\n   * @param [oldSchema] - The old schema from which the data originated\n   * @param [data={}] - The form data associated with the schema, defaulting to an empty object when undefined\n   * @returns - The new form data, with all the fields uniquely associated with the old schema set\n   *      to `undefined`. Will return `undefined` if the new schema is not an object containing properties.\n   */\n  sanitizeDataForNewSchema(newSchema, oldSchema, data) {\n    return sanitizeDataForNewSchema(this.validator, this.rootSchema, newSchema, oldSchema, data);\n  }\n  /** Generates an `IdSchema` object for the `schema`, recursively\n   *\n   * @param schema - The schema for which the display label flag is desired\n   * @param [id] - The base id for the schema\n   * @param [formData] - The current formData, if any, onto which to provide any missing defaults\n   * @param [idPrefix='root'] - The prefix to use for the id\n   * @param [idSeparator='_'] - The separator to use for the path segments in the id\n   * @returns - The `IdSchema` object for the `schema`\n   */\n  toIdSchema(schema, id, formData, idPrefix = 'root', idSeparator = '_') {\n    return toIdSchema(this.validator, schema, id, this.rootSchema, formData, idPrefix, idSeparator);\n  }\n  /** Generates an `PathSchema` object for the `schema`, recursively\n   *\n   * @param schema - The schema for which the display label flag is desired\n   * @param [name] - The base name for the schema\n   * @param [formData] - The current formData, if any, onto which to provide any missing defaults\n   * @returns - The `PathSchema` object for the `schema`\n   */\n  toPathSchema(schema, name, formData) {\n    return toPathSchema(this.validator, schema, name, this.rootSchema, formData);\n  }\n}\n/** Creates a `SchemaUtilsType` interface that is based around the given `validator` and `rootSchema` parameters. The\n * resulting interface implementation will forward the `validator` and `rootSchema` to all the wrapped APIs.\n *\n * @param validator - an implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param [experimental_defaultFormStateBehavior] Optional configuration object, if provided, allows users to override default form state behavior\n * @returns - An implementation of a `SchemaUtilsType` interface\n */\nexport default function createSchemaUtils(validator, rootSchema, experimental_defaultFormStateBehavior = {}) {\n  return new SchemaUtils(validator, rootSchema, experimental_defaultFormStateBehavior);\n}","map":{"version":3,"names":["deepEquals","getDefaultFormState","getDisplayLabel","getClosestMatchingOption","getFirstMatchingOption","getMatchingOption","isFilesArray","isMultiSelect","isSelect","mergeValidationData","retrieveSchema","sanitizeDataForNewSchema","toIdSchema","toPathSchema","SchemaUtils","constructor","validator","rootSchema","experimental_defaultFormStateBehavior","getValidator","doesSchemaUtilsDiffer","schema","formData","includeUndefinedValues","uiSchema","globalOptions","options","selectedOption","discriminatorField","validationData","additionalErrorSchema","rawFormData","newSchema","oldSchema","data","id","idPrefix","idSeparator","name","createSchemaUtils"],"sources":["D:\\Reactjs\\my-app\\node_modules\\@rjsf\\utils\\src\\createSchemaUtils.ts"],"sourcesContent":["import deepEquals from './deepEquals';\nimport {\n  ErrorSchema,\n  Experimental_DefaultFormStateBehavior,\n  FormContextType,\n  GlobalUISchemaOptions,\n  IdSchema,\n  PathSchema,\n  RJSFSchema,\n  SchemaUtilsType,\n  StrictRJSFSchema,\n  UiSchema,\n  ValidationData,\n  ValidatorType,\n} from './types';\nimport {\n  getDefaultFormState,\n  getDisplayLabel,\n  getClosestMatchingOption,\n  getFirstMatchingOption,\n  getMatchingOption,\n  isFilesArray,\n  isMultiSelect,\n  isSelect,\n  mergeValidationData,\n  retrieveSchema,\n  sanitizeDataForNewSchema,\n  toIdSchema,\n  toPathSchema,\n} from './schema';\n\n/** The `SchemaUtils` class provides a wrapper around the publicly exported APIs in the `utils/schema` directory such\n * that one does not have to explicitly pass the `validator`, `rootSchema`, or `experimental_defaultFormStateBehavior` to each method.\n * Since these generally do not change across a `Form`, this allows for providing a simplified set of APIs to the\n * `@rjsf/core` components and the various themes as well. This class implements the `SchemaUtilsType` interface.\n */\nclass SchemaUtils<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>\n  implements SchemaUtilsType<T, S, F>\n{\n  rootSchema: S;\n  validator: ValidatorType<T, S, F>;\n  experimental_defaultFormStateBehavior: Experimental_DefaultFormStateBehavior;\n\n  /** Constructs the `SchemaUtils` instance with the given `validator` and `rootSchema` stored as instance variables\n   *\n   * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n   * @param rootSchema - The root schema that will be forwarded to all the APIs\n   * @param experimental_defaultFormStateBehavior - Configuration flags to allow users to override default form state behavior\n   */\n  constructor(\n    validator: ValidatorType<T, S, F>,\n    rootSchema: S,\n    experimental_defaultFormStateBehavior: Experimental_DefaultFormStateBehavior\n  ) {\n    this.rootSchema = rootSchema;\n    this.validator = validator;\n    this.experimental_defaultFormStateBehavior = experimental_defaultFormStateBehavior;\n  }\n\n  /** Returns the `ValidatorType` in the `SchemaUtilsType`\n   *\n   * @returns - The `ValidatorType`\n   */\n  getValidator() {\n    return this.validator;\n  }\n\n  /** Determines whether either the `validator` and `rootSchema` differ from the ones associated with this instance of\n   * the `SchemaUtilsType`. If either `validator` or `rootSchema` are falsy, then return false to prevent the creation\n   * of a new `SchemaUtilsType` with incomplete properties.\n   *\n   * @param validator - An implementation of the `ValidatorType` interface that will be compared against the current one\n   * @param rootSchema - The root schema that will be compared against the current one\n   * @param [experimental_defaultFormStateBehavior] Optional configuration object, if provided, allows users to override default form state behavior\n   * @returns - True if the `SchemaUtilsType` differs from the given `validator` or `rootSchema`\n   */\n  doesSchemaUtilsDiffer(\n    validator: ValidatorType<T, S, F>,\n    rootSchema: S,\n    experimental_defaultFormStateBehavior = {}\n  ): boolean {\n    if (!validator || !rootSchema) {\n      return false;\n    }\n    return (\n      this.validator !== validator ||\n      !deepEquals(this.rootSchema, rootSchema) ||\n      !deepEquals(this.experimental_defaultFormStateBehavior, experimental_defaultFormStateBehavior)\n    );\n  }\n\n  /** Returns the superset of `formData` that includes the given set updated to include any missing fields that have\n   * computed to have defaults provided in the `schema`.\n   *\n   * @param schema - The schema for which the default state is desired\n   * @param [formData] - The current formData, if any, onto which to provide any missing defaults\n   * @param [includeUndefinedValues=false] - Optional flag, if true, cause undefined values to be added as defaults.\n   *          If \"excludeObjectChildren\", pass `includeUndefinedValues` as false when computing defaults for any nested\n   *          object properties.\n   * @returns - The resulting `formData` with all the defaults provided\n   */\n  getDefaultFormState(\n    schema: S,\n    formData?: T,\n    includeUndefinedValues: boolean | 'excludeObjectChildren' = false\n  ): T | T[] | undefined {\n    return getDefaultFormState<T, S, F>(\n      this.validator,\n      schema,\n      formData,\n      this.rootSchema,\n      includeUndefinedValues,\n      this.experimental_defaultFormStateBehavior\n    );\n  }\n\n  /** Determines whether the combination of `schema` and `uiSchema` properties indicates that the label for the `schema`\n   * should be displayed in a UI.\n   *\n   * @param schema - The schema for which the display label flag is desired\n   * @param [uiSchema] - The UI schema from which to derive potentially displayable information\n   * @param [globalOptions={}] - The optional Global UI Schema from which to get any fallback `xxx` options\n   * @returns - True if the label should be displayed or false if it should not\n   */\n  getDisplayLabel(schema: S, uiSchema?: UiSchema<T, S, F>, globalOptions?: GlobalUISchemaOptions) {\n    return getDisplayLabel<T, S, F>(this.validator, schema, uiSchema, this.rootSchema, globalOptions);\n  }\n\n  /** Determines which of the given `options` provided most closely matches the `formData`.\n   * Returns the index of the option that is valid and is the closest match, or 0 if there is no match.\n   *\n   * The closest match is determined using the number of matching properties, and more heavily favors options with\n   * matching readOnly, default, or const values.\n   *\n   * @param formData - The form data associated with the schema\n   * @param options - The list of options that can be selected from\n   * @param [selectedOption] - The index of the currently selected option, defaulted to -1 if not specified\n   * @param [discriminatorField] - The optional name of the field within the options object whose value is used to\n   *          determine which option is selected\n   * @returns - The index of the option that is the closest match to the `formData` or the `selectedOption` if no match\n   */\n  getClosestMatchingOption(\n    formData: T | undefined,\n    options: S[],\n    selectedOption?: number,\n    discriminatorField?: string\n  ): number {\n    return getClosestMatchingOption<T, S, F>(\n      this.validator,\n      this.rootSchema,\n      formData,\n      options,\n      selectedOption,\n      discriminatorField\n    );\n  }\n\n  /** Given the `formData` and list of `options`, attempts to find the index of the first option that matches the data.\n   * Always returns the first option if there is nothing that matches.\n   *\n   * @param formData - The current formData, if any, used to figure out a match\n   * @param options - The list of options to find a matching options from\n   * @param [discriminatorField] - The optional name of the field within the options object whose value is used to\n   *          determine which option is selected\n   * @returns - The firstindex of the matched option or 0 if none is available\n   */\n  getFirstMatchingOption(formData: T | undefined, options: S[], discriminatorField?: string): number {\n    return getFirstMatchingOption<T, S, F>(this.validator, formData, options, this.rootSchema, discriminatorField);\n  }\n\n  /** Given the `formData` and list of `options`, attempts to find the index of the option that best matches the data.\n   * Deprecated, use `getFirstMatchingOption()` instead.\n   *\n   * @param formData - The current formData, if any, onto which to provide any missing defaults\n   * @param options - The list of options to find a matching options from\n   * @param [discriminatorField] - The optional name of the field within the options object whose value is used to\n   *          determine which option is selected\n   * @returns - The index of the matched option or 0 if none is available\n   * @deprecated\n   */\n  getMatchingOption(formData: T | undefined, options: S[], discriminatorField?: string) {\n    return getMatchingOption<T, S, F>(this.validator, formData, options, this.rootSchema, discriminatorField);\n  }\n\n  /** Checks to see if the `schema` and `uiSchema` combination represents an array of files\n   *\n   * @param schema - The schema for which check for array of files flag is desired\n   * @param [uiSchema] - The UI schema from which to check the widget\n   * @returns - True if schema/uiSchema contains an array of files, otherwise false\n   */\n  isFilesArray(schema: S, uiSchema?: UiSchema<T, S, F>) {\n    return isFilesArray<T, S, F>(this.validator, schema, uiSchema, this.rootSchema);\n  }\n\n  /** Checks to see if the `schema` combination represents a multi-select\n   *\n   * @param schema - The schema for which check for a multi-select flag is desired\n   * @returns - True if schema contains a multi-select, otherwise false\n   */\n  isMultiSelect(schema: S) {\n    return isMultiSelect<T, S, F>(this.validator, schema, this.rootSchema);\n  }\n\n  /** Checks to see if the `schema` combination represents a select\n   *\n   * @param schema - The schema for which check for a select flag is desired\n   * @returns - True if schema contains a select, otherwise false\n   */\n  isSelect(schema: S) {\n    return isSelect<T, S, F>(this.validator, schema, this.rootSchema);\n  }\n\n  /** Merges the errors in `additionalErrorSchema` into the existing `validationData` by combining the hierarchies in\n   * the two `ErrorSchema`s and then appending the error list from the `additionalErrorSchema` obtained by calling\n   * `getValidator().toErrorList()` onto the `errors` in the `validationData`. If no `additionalErrorSchema` is passed,\n   * then `validationData` is returned.\n   *\n   * @param validationData - The current `ValidationData` into which to merge the additional errors\n   * @param [additionalErrorSchema] - The additional set of errors\n   * @returns - The `validationData` with the additional errors from `additionalErrorSchema` merged into it, if provided.\n   * @deprecated - Use the `validationDataMerge()` function exported from `@rjsf/utils` instead. This function will be\n   *        removed in the next major release.\n   */\n  mergeValidationData(validationData: ValidationData<T>, additionalErrorSchema?: ErrorSchema<T>): ValidationData<T> {\n    return mergeValidationData<T, S, F>(this.validator, validationData, additionalErrorSchema);\n  }\n\n  /** Retrieves an expanded schema that has had all of its conditions, additional properties, references and\n   * dependencies resolved and merged into the `schema` given a `rawFormData` that is used to do the potentially\n   * recursive resolution.\n   *\n   * @param schema - The schema for which retrieving a schema is desired\n   * @param [rawFormData] - The current formData, if any, to assist retrieving a schema\n   * @returns - The schema having its conditions, additional properties, references and dependencies resolved\n   */\n  retrieveSchema(schema: S, rawFormData?: T) {\n    return retrieveSchema<T, S, F>(this.validator, schema, this.rootSchema, rawFormData);\n  }\n\n  /** Sanitize the `data` associated with the `oldSchema` so it is considered appropriate for the `newSchema`. If the\n   * new schema does not contain any properties, then `undefined` is returned to clear all the form data. Due to the\n   * nature of schemas, this sanitization happens recursively for nested objects of data. Also, any properties in the\n   * old schemas that are non-existent in the new schema are set to `undefined`.\n   *\n   * @param [newSchema] - The new schema for which the data is being sanitized\n   * @param [oldSchema] - The old schema from which the data originated\n   * @param [data={}] - The form data associated with the schema, defaulting to an empty object when undefined\n   * @returns - The new form data, with all the fields uniquely associated with the old schema set\n   *      to `undefined`. Will return `undefined` if the new schema is not an object containing properties.\n   */\n  sanitizeDataForNewSchema(newSchema?: S, oldSchema?: S, data?: any): T {\n    return sanitizeDataForNewSchema(this.validator, this.rootSchema, newSchema, oldSchema, data);\n  }\n\n  /** Generates an `IdSchema` object for the `schema`, recursively\n   *\n   * @param schema - The schema for which the display label flag is desired\n   * @param [id] - The base id for the schema\n   * @param [formData] - The current formData, if any, onto which to provide any missing defaults\n   * @param [idPrefix='root'] - The prefix to use for the id\n   * @param [idSeparator='_'] - The separator to use for the path segments in the id\n   * @returns - The `IdSchema` object for the `schema`\n   */\n  toIdSchema(schema: S, id?: string | null, formData?: T, idPrefix = 'root', idSeparator = '_'): IdSchema<T> {\n    return toIdSchema<T, S, F>(this.validator, schema, id, this.rootSchema, formData, idPrefix, idSeparator);\n  }\n\n  /** Generates an `PathSchema` object for the `schema`, recursively\n   *\n   * @param schema - The schema for which the display label flag is desired\n   * @param [name] - The base name for the schema\n   * @param [formData] - The current formData, if any, onto which to provide any missing defaults\n   * @returns - The `PathSchema` object for the `schema`\n   */\n  toPathSchema(schema: S, name?: string, formData?: T): PathSchema<T> {\n    return toPathSchema<T, S, F>(this.validator, schema, name, this.rootSchema, formData);\n  }\n}\n\n/** Creates a `SchemaUtilsType` interface that is based around the given `validator` and `rootSchema` parameters. The\n * resulting interface implementation will forward the `validator` and `rootSchema` to all the wrapped APIs.\n *\n * @param validator - an implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param [experimental_defaultFormStateBehavior] Optional configuration object, if provided, allows users to override default form state behavior\n * @returns - An implementation of a `SchemaUtilsType` interface\n */\nexport default function createSchemaUtils<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(\n  validator: ValidatorType<T, S, F>,\n  rootSchema: S,\n  experimental_defaultFormStateBehavior = {}\n): SchemaUtilsType<T, S, F> {\n  return new SchemaUtils<T, S, F>(validator, rootSchema, experimental_defaultFormStateBehavior);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}