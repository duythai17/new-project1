{"ast":null,"code":"import get from 'lodash/get';\nimport isEqual from 'lodash/isEqual';\nimport set from 'lodash/set';\nimport times from 'lodash/times';\nimport transform from 'lodash/transform';\nimport merge from 'lodash/merge';\nimport flattenDeep from 'lodash/flattenDeep';\nimport uniq from 'lodash/uniq';\nimport mergeAllOf from 'json-schema-merge-allof';\nimport { ADDITIONAL_PROPERTIES_KEY, ADDITIONAL_PROPERTY_FLAG, ALL_OF_KEY, ANY_OF_KEY, DEPENDENCIES_KEY, IF_KEY, ONE_OF_KEY, REF_KEY, PROPERTIES_KEY, ITEMS_KEY } from '../constants';\nimport findSchemaDefinition, { splitKeyElementFromObject } from '../findSchemaDefinition';\nimport getDiscriminatorFieldFromSchema from '../getDiscriminatorFieldFromSchema';\nimport guessType from '../guessType';\nimport isObject from '../isObject';\nimport mergeSchemas from '../mergeSchemas';\nimport getFirstMatchingOption from './getFirstMatchingOption';\n/** Retrieves an expanded schema that has had all of its conditions, additional properties, references and dependencies\n * resolved and merged into the `schema` given a `validator`, `rootSchema` and `rawFormData` that is used to do the\n * potentially recursive resolution.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n * @param schema - The schema for which retrieving a schema is desired\n * @param [rootSchema={}] - The root schema that will be forwarded to all the APIs\n * @param [rawFormData] - The current formData, if any, to assist retrieving a schema\n * @returns - The schema having its conditions, additional properties, references and dependencies resolved\n */\nexport default function retrieveSchema(validator, schema) {\n  let rootSchema = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  let rawFormData = arguments.length > 3 ? arguments[3] : undefined;\n  return retrieveSchemaInternal(validator, schema, rootSchema, rawFormData)[0];\n}\n/** Resolves a conditional block (if/else/then) by removing the condition and merging the appropriate conditional branch\n * with the rest of the schema. If `expandAllBranches` is true, then the `retrieveSchemaInteral()` results for both\n * conditions will be returned.\n *\n * @param validator - An implementation of the `ValidatorType` interface that is used to detect valid schema conditions\n * @param schema - The schema for which resolving a condition is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and\n *          dependencies as a list of schemas\n * @param recurseList - The list of recursive references already processed\n * @param [formData] - The current formData to assist retrieving a schema\n * @returns - A list of schemas with the appropriate conditions resolved, possibly with all branches expanded\n */\nexport function resolveCondition(validator, schema, rootSchema, expandAllBranches, recurseList, formData) {\n  const {\n    if: expression,\n    then,\n    else: otherwise,\n    ...resolvedSchemaLessConditional\n  } = schema;\n  const conditionValue = validator.isValid(expression, formData || {}, rootSchema);\n  let resolvedSchemas = [resolvedSchemaLessConditional];\n  let schemas = [];\n  if (expandAllBranches) {\n    if (then && typeof then !== 'boolean') {\n      schemas = schemas.concat(retrieveSchemaInternal(validator, then, rootSchema, formData, expandAllBranches, recurseList));\n    }\n    if (otherwise && typeof otherwise !== 'boolean') {\n      schemas = schemas.concat(retrieveSchemaInternal(validator, otherwise, rootSchema, formData, expandAllBranches, recurseList));\n    }\n  } else {\n    const conditionalSchema = conditionValue ? then : otherwise;\n    if (conditionalSchema && typeof conditionalSchema !== 'boolean') {\n      schemas = schemas.concat(retrieveSchemaInternal(validator, conditionalSchema, rootSchema, formData, expandAllBranches, recurseList));\n    }\n  }\n  if (schemas.length) {\n    resolvedSchemas = schemas.map(s => mergeSchemas(resolvedSchemaLessConditional, s));\n  }\n  return resolvedSchemas.flatMap(s => retrieveSchemaInternal(validator, s, rootSchema, formData, expandAllBranches, recurseList));\n}\n/** Given a list of lists of allOf, anyOf or oneOf values, create a list of lists of all permutations of the values. The\n * `listOfLists` is expected to be all resolved values of the 1st...nth schemas within an `allOf`, `anyOf` or `oneOf`.\n * From those lists, build a matrix for each `xxxOf` where there is more than one schema for a row in the list of lists.\n *\n * For example:\n * - If there are three xxxOf rows (A, B, C) and they have been resolved such that there is only one A, two B and three\n *   C schemas then:\n *   - The permutation for the first row is `[[A]]`\n *   - The permutations for the second row are `[[A,B1], [A,B2]]`\n *   - The permutations for the third row are `[[A,B1,C1], [A,B1,C2], [A,B1,C3], [A,B2,C1], [A,B2,C2], [A,B2,C3]]`\n *\n * @param listOfLists - The list of lists of elements that represent the allOf, anyOf or oneOf resolved values in order\n * @returns - The list of all permutations of schemas for a set of `xxxOf`s\n */\nexport function getAllPermutationsOfXxxOf(listOfLists) {\n  const allPermutations = listOfLists.reduce((permutations, list) => {\n    // When there are more than one set of schemas for a row, duplicate the set of permutations and add in the values\n    if (list.length > 1) {\n      return list.flatMap(element => times(permutations.length, i => [...permutations[i]].concat(element)));\n    }\n    // Otherwise just push in the single value into the current set of permutations\n    permutations.forEach(permutation => permutation.push(list[0]));\n    return permutations;\n  }, [[]] // Start with an empty list\n  );\n  return allPermutations;\n}\n/** Resolves references and dependencies within a schema and its 'allOf' children. Passes the `expandAllBranches` flag\n * down to the `retrieveSchemaInternal()`, `resolveReference()` and `resolveDependencies()` helper calls. If\n * `expandAllBranches` is true, then all possible dependencies and/or allOf branches are returned.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n * @param schema - The schema for which resolving a schema is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and dependencies\n *          as a list of schemas\n * @param recurseList - The list of recursive references already processed\n * @param [formData] - The current formData, if any, to assist retrieving a schema\n * @returns - The list of schemas having its references, dependencies and allOf schemas resolved\n */\nexport function resolveSchema(validator, schema, rootSchema, expandAllBranches, recurseList, formData) {\n  const updatedSchemas = resolveReference(validator, schema, rootSchema, expandAllBranches, recurseList, formData);\n  if (updatedSchemas.length > 1 || updatedSchemas[0] !== schema) {\n    // return the updatedSchemas array if it has either multiple schemas within it\n    // OR the first schema is not the same as the original schema\n    return updatedSchemas;\n  }\n  if (DEPENDENCIES_KEY in schema) {\n    const resolvedSchemas = resolveDependencies(validator, schema, rootSchema, expandAllBranches, recurseList, formData);\n    return resolvedSchemas.flatMap(s => {\n      return retrieveSchemaInternal(validator, s, rootSchema, formData, expandAllBranches, recurseList);\n    });\n  }\n  if (ALL_OF_KEY in schema && Array.isArray(schema.allOf)) {\n    const allOfSchemaElements = schema.allOf.map(allOfSubschema => retrieveSchemaInternal(validator, allOfSubschema, rootSchema, formData, expandAllBranches, recurseList));\n    const allPermutations = getAllPermutationsOfXxxOf(allOfSchemaElements);\n    return allPermutations.map(permutation => ({\n      ...schema,\n      allOf: permutation\n    }));\n  }\n  // No $ref or dependencies or allOf attribute was found, returning the original schema.\n  return [schema];\n}\n/** Resolves all references within a schema and then returns the `retrieveSchemaInternal()` if the resolved schema is\n * actually different than the original. Passes the `expandAllBranches` flag down to the `retrieveSchemaInternal()`\n * helper call.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n * @param schema - The schema for which resolving a reference is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and dependencies\n *          as a list of schemas\n * @param recurseList - The list of recursive references already processed\n * @param [formData] - The current formData, if any, to assist retrieving a schema\n * @returns - The list schemas retrieved after having all references resolved\n */\nexport function resolveReference(validator, schema, rootSchema, expandAllBranches, recurseList, formData) {\n  const updatedSchema = resolveAllReferences(schema, rootSchema, recurseList);\n  if (updatedSchema !== schema) {\n    // Only call this if the schema was actually changed by the `resolveAllReferences()` function\n    return retrieveSchemaInternal(validator, updatedSchema, rootSchema, formData, expandAllBranches, recurseList);\n  }\n  return [schema];\n}\n/** Resolves all references within the schema itself as well as any of its properties and array items.\n *\n * @param schema - The schema for which resolving all references is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param recurseList - List of $refs already resolved to prevent recursion\n * @returns - given schema will all references resolved or the original schema if no internal `$refs` were resolved\n */\nexport function resolveAllReferences(schema, rootSchema, recurseList) {\n  if (!isObject(schema)) {\n    return schema;\n  }\n  let resolvedSchema = schema;\n  // resolve top level ref\n  if (REF_KEY in resolvedSchema) {\n    const {\n      $ref,\n      ...localSchema\n    } = resolvedSchema;\n    // Check for a recursive reference and stop the loop\n    if (recurseList.includes($ref)) {\n      return resolvedSchema;\n    }\n    recurseList.push($ref);\n    // Retrieve the referenced schema definition.\n    const refSchema = findSchemaDefinition($ref, rootSchema);\n    resolvedSchema = {\n      ...refSchema,\n      ...localSchema\n    };\n  }\n  if (PROPERTIES_KEY in resolvedSchema) {\n    const childrenLists = [];\n    const updatedProps = transform(resolvedSchema[PROPERTIES_KEY], (result, value, key) => {\n      const childList = [...recurseList];\n      result[key] = resolveAllReferences(value, rootSchema, childList);\n      childrenLists.push(childList);\n    }, {});\n    merge(recurseList, uniq(flattenDeep(childrenLists)));\n    resolvedSchema = {\n      ...resolvedSchema,\n      [PROPERTIES_KEY]: updatedProps\n    };\n  }\n  if (ITEMS_KEY in resolvedSchema && !Array.isArray(resolvedSchema.items) && typeof resolvedSchema.items !== 'boolean') {\n    resolvedSchema = {\n      ...resolvedSchema,\n      items: resolveAllReferences(resolvedSchema.items, rootSchema, recurseList)\n    };\n  }\n  return isEqual(schema, resolvedSchema) ? schema : resolvedSchema;\n}\n/** Creates new 'properties' items for each key in the `formData`\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param theSchema - The schema for which the existing additional properties is desired\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s * @param validator\n * @param [aFormData] - The current formData, if any, to assist retrieving a schema\n * @returns - The updated schema with additional properties stubbed\n */\nexport function stubExistingAdditionalProperties(validator, theSchema, rootSchema, aFormData) {\n  // Clone the schema so that we don't ruin the consumer's original\n  const schema = {\n    ...theSchema,\n    properties: {\n      ...theSchema.properties\n    }\n  };\n  // make sure formData is an object\n  const formData = aFormData && isObject(aFormData) ? aFormData : {};\n  Object.keys(formData).forEach(key => {\n    if (key in schema.properties) {\n      // No need to stub, our schema already has the property\n      return;\n    }\n    let additionalProperties = {};\n    if (typeof schema.additionalProperties !== 'boolean') {\n      if (REF_KEY in schema.additionalProperties) {\n        additionalProperties = retrieveSchema(validator, {\n          $ref: get(schema.additionalProperties, [REF_KEY])\n        }, rootSchema, formData);\n      } else if ('type' in schema.additionalProperties) {\n        additionalProperties = {\n          ...schema.additionalProperties\n        };\n      } else if (ANY_OF_KEY in schema.additionalProperties || ONE_OF_KEY in schema.additionalProperties) {\n        additionalProperties = {\n          type: 'object',\n          ...schema.additionalProperties\n        };\n      } else {\n        additionalProperties = {\n          type: guessType(get(formData, [key]))\n        };\n      }\n    } else {\n      additionalProperties = {\n        type: guessType(get(formData, [key]))\n      };\n    }\n    // The type of our new key should match the additionalProperties value;\n    schema.properties[key] = additionalProperties;\n    // Set our additional property flag so we know it was dynamically added\n    set(schema.properties, [key, ADDITIONAL_PROPERTY_FLAG], true);\n  });\n  return schema;\n}\n/** Internal handler that retrieves an expanded schema that has had all of its conditions, additional properties,\n * references and dependencies resolved and merged into the `schema` given a `validator`, `rootSchema` and `rawFormData`\n * that is used to do the potentially recursive resolution. If `expandAllBranches` is true, then all possible branches\n * of the schema and its references, conditions and dependencies are returned.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n * @param schema - The schema for which retrieving a schema is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param [rawFormData] - The current formData, if any, to assist retrieving a schema\n * @param [expandAllBranches=false] - Flag, if true, will return all possible branches of conditions, any/oneOf and\n *          dependencies as a list of schemas\n * @param [recurseList=[]] - The optional, list of recursive references already processed\n * @returns - The schema(s) resulting from having its conditions, additional properties, references and dependencies\n *          resolved. Multiple schemas may be returned if `expandAllBranches` is true.\n */\nexport function retrieveSchemaInternal(validator, schema, rootSchema, rawFormData) {\n  let expandAllBranches = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n  let recurseList = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : [];\n  if (!isObject(schema)) {\n    return [{}];\n  }\n  const resolvedSchemas = resolveSchema(validator, schema, rootSchema, expandAllBranches, recurseList, rawFormData);\n  return resolvedSchemas.flatMap(s => {\n    let resolvedSchema = s;\n    if (IF_KEY in resolvedSchema) {\n      return resolveCondition(validator, resolvedSchema, rootSchema, expandAllBranches, recurseList, rawFormData);\n    }\n    if (ALL_OF_KEY in resolvedSchema) {\n      // resolve allOf schemas\n      if (expandAllBranches) {\n        const {\n          allOf,\n          ...restOfSchema\n        } = resolvedSchema;\n        return [...allOf, restOfSchema];\n      }\n      try {\n        resolvedSchema = mergeAllOf(resolvedSchema, {\n          deep: false\n        });\n      } catch (e) {\n        console.warn('could not merge subschemas in allOf:\\n', e);\n        const {\n          allOf,\n          ...resolvedSchemaWithoutAllOf\n        } = resolvedSchema;\n        return resolvedSchemaWithoutAllOf;\n      }\n    }\n    const hasAdditionalProperties = ADDITIONAL_PROPERTIES_KEY in resolvedSchema && resolvedSchema.additionalProperties !== false;\n    if (hasAdditionalProperties) {\n      return stubExistingAdditionalProperties(validator, resolvedSchema, rootSchema, rawFormData);\n    }\n    return resolvedSchema;\n  });\n}\n/** Resolves an `anyOf` or `oneOf` within a schema (if present) to the list of schemas returned from\n * `retrieveSchemaInternal()` for the best matching option. If `expandAllBranches` is true, then a list of schemas for ALL\n * options are retrieved and returned.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n * @param schema - The schema for which retrieving a schema is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and dependencies\n *          as a list of schemas\n * @param [rawFormData] - The current formData, if any, to assist retrieving a schema, defaults to an empty object\n * @returns - Either an array containing the best matching option or all options if `expandAllBranches` is true\n */\nexport function resolveAnyOrOneOfSchemas(validator, schema, rootSchema, expandAllBranches, rawFormData) {\n  let anyOrOneOf;\n  const {\n    oneOf,\n    anyOf,\n    ...remaining\n  } = schema;\n  if (Array.isArray(oneOf)) {\n    anyOrOneOf = oneOf;\n  } else if (Array.isArray(anyOf)) {\n    anyOrOneOf = anyOf;\n  }\n  if (anyOrOneOf) {\n    // Ensure that during expand all branches we pass an object rather than undefined so that all options are interrogated\n    const formData = rawFormData === undefined && expandAllBranches ? {} : rawFormData;\n    const discriminator = getDiscriminatorFieldFromSchema(schema);\n    anyOrOneOf = anyOrOneOf.map(s => {\n      // Due to anyOf/oneOf possibly using the same $ref we always pass a fresh recurse list array so that each option\n      // can resolve recursive references independently\n      return resolveAllReferences(s, rootSchema, []);\n    });\n    // Call this to trigger the set of isValid() calls that the schema parser will need\n    const option = getFirstMatchingOption(validator, formData, anyOrOneOf, rootSchema, discriminator);\n    if (expandAllBranches) {\n      return anyOrOneOf.map(item => mergeSchemas(remaining, item));\n    }\n    schema = mergeSchemas(remaining, anyOrOneOf[option]);\n  }\n  return [schema];\n}\n/** Resolves dependencies within a schema and its 'anyOf/oneOf' children. Passes the `expandAllBranches` flag down to\n * the `resolveAnyOrOneOfSchema()` and `processDependencies()` helper calls.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n * @param schema - The schema for which resolving a dependency is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and dependencies\n *          as a list of schemas\n * @param recurseList - The list of recursive references already processed\n * @param [formData] - The current formData, if any, to assist retrieving a schema\n * @returns - The list of schemas with their dependencies resolved\n */\nexport function resolveDependencies(validator, schema, rootSchema, expandAllBranches, recurseList, formData) {\n  // Drop the dependencies from the source schema.\n  const {\n    dependencies,\n    ...remainingSchema\n  } = schema;\n  const resolvedSchemas = resolveAnyOrOneOfSchemas(validator, remainingSchema, rootSchema, expandAllBranches, formData);\n  return resolvedSchemas.flatMap(resolvedSchema => processDependencies(validator, dependencies, resolvedSchema, rootSchema, expandAllBranches, recurseList, formData));\n}\n/** Processes all the `dependencies` recursively into the list of `resolvedSchema`s as needed. Passes the\n * `expandAllBranches` flag down to the `withDependentSchema()` and the recursive `processDependencies()` helper calls.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n * @param dependencies - The set of dependencies that needs to be processed\n * @param resolvedSchema - The schema for which processing dependencies is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and dependencies\n *          as a list of schemas\n * @param recurseList - The list of recursive references already processed\n * @param [formData] - The current formData, if any, to assist retrieving a schema\n * @returns - The schema with the `dependencies` resolved into it\n */\nexport function processDependencies(validator, dependencies, resolvedSchema, rootSchema, expandAllBranches, recurseList, formData) {\n  let schemas = [resolvedSchema];\n  // Process dependencies updating the local schema properties as appropriate.\n  for (const dependencyKey in dependencies) {\n    // Skip this dependency if its trigger property is not present.\n    if (!expandAllBranches && get(formData, [dependencyKey]) === undefined) {\n      continue;\n    }\n    // Skip this dependency if it is not included in the schema (such as when dependencyKey is itself a hidden dependency.)\n    if (resolvedSchema.properties && !(dependencyKey in resolvedSchema.properties)) {\n      continue;\n    }\n    const [remainingDependencies, dependencyValue] = splitKeyElementFromObject(dependencyKey, dependencies);\n    if (Array.isArray(dependencyValue)) {\n      schemas[0] = withDependentProperties(resolvedSchema, dependencyValue);\n    } else if (isObject(dependencyValue)) {\n      schemas = withDependentSchema(validator, resolvedSchema, rootSchema, dependencyKey, dependencyValue, expandAllBranches, recurseList, formData);\n    }\n    return schemas.flatMap(schema => processDependencies(validator, remainingDependencies, schema, rootSchema, expandAllBranches, recurseList, formData));\n  }\n  return schemas;\n}\n/** Updates a schema with additionally required properties added\n *\n * @param schema - The schema for which resolving a dependent properties is desired\n * @param [additionallyRequired] - An optional array of additionally required names\n * @returns - The schema with the additional required values merged in\n */\nexport function withDependentProperties(schema, additionallyRequired) {\n  if (!additionallyRequired) {\n    return schema;\n  }\n  const required = Array.isArray(schema.required) ? Array.from(new Set([...schema.required, ...additionallyRequired])) : additionallyRequired;\n  return {\n    ...schema,\n    required: required\n  };\n}\n/** Merges a dependent schema into the `schema` dealing with oneOfs and references. Passes the `expandAllBranches` flag\n * down to the `retrieveSchemaInternal()`, `resolveReference()` and `withExactlyOneSubschema()` helper calls.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n * @param schema - The schema for which resolving a dependent schema is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param dependencyKey - The key name of the dependency\n * @param dependencyValue - The potentially dependent schema\n * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and dependencies\n *          as a list of schemas\n * @param recurseList - The list of recursive references already processed\n * @param [formData]- The current formData to assist retrieving a schema\n * @returns - The list of schemas with the dependent schema resolved into them\n */\nexport function withDependentSchema(validator, schema, rootSchema, dependencyKey, dependencyValue, expandAllBranches, recurseList, formData) {\n  const dependentSchemas = retrieveSchemaInternal(validator, dependencyValue, rootSchema, formData, expandAllBranches, recurseList);\n  return dependentSchemas.flatMap(dependent => {\n    const {\n      oneOf,\n      ...dependentSchema\n    } = dependent;\n    schema = mergeSchemas(schema, dependentSchema);\n    // Since it does not contain oneOf, we return the original schema.\n    if (oneOf === undefined) {\n      return schema;\n    }\n    // Resolve $refs inside oneOf.\n    const resolvedOneOfs = oneOf.map(subschema => {\n      if (typeof subschema === 'boolean' || !(REF_KEY in subschema)) {\n        return [subschema];\n      }\n      return resolveReference(validator, subschema, rootSchema, expandAllBranches, recurseList, formData);\n    });\n    const allPermutations = getAllPermutationsOfXxxOf(resolvedOneOfs);\n    return allPermutations.flatMap(resolvedOneOf => withExactlyOneSubschema(validator, schema, rootSchema, dependencyKey, resolvedOneOf, expandAllBranches, recurseList, formData));\n  });\n}\n/** Returns a list of `schema`s with the best choice from the `oneOf` options merged into it. If `expandAllBranches` is\n * true, then a list of schemas for ALL options are retrieved and returned. Passes the `expandAllBranches` flag down to\n * the `retrieveSchemaInternal()` helper call.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used to validate oneOf options\n * @param schema - The schema for which resolving a oneOf subschema is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param dependencyKey - The key name of the oneOf dependency\n * @param oneOf - The list of schemas representing the oneOf options\n * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and dependencies\n *          as a list of schemas\n * @param recurseList - The list of recursive references already processed\n * @param [formData] - The current formData to assist retrieving a schema\n * @returns - Either an array containing the best matching option or all options if `expandAllBranches` is true\n */\nexport function withExactlyOneSubschema(validator, schema, rootSchema, dependencyKey, oneOf, expandAllBranches, recurseList, formData) {\n  const validSubschemas = oneOf.filter(subschema => {\n    if (typeof subschema === 'boolean' || !subschema || !subschema.properties) {\n      return false;\n    }\n    const {\n      [dependencyKey]: conditionPropertySchema\n    } = subschema.properties;\n    if (conditionPropertySchema) {\n      const conditionSchema = {\n        type: 'object',\n        properties: {\n          [dependencyKey]: conditionPropertySchema\n        }\n      };\n      return validator.isValid(conditionSchema, formData, rootSchema) || expandAllBranches;\n    }\n    return false;\n  });\n  if (!expandAllBranches && validSubschemas.length !== 1) {\n    console.warn(\"ignoring oneOf in dependencies because there isn't exactly one subschema that is valid\");\n    return [schema];\n  }\n  return validSubschemas.flatMap(s => {\n    const subschema = s;\n    const [dependentSubschema] = splitKeyElementFromObject(dependencyKey, subschema.properties);\n    const dependentSchema = {\n      ...subschema,\n      properties: dependentSubschema\n    };\n    const schemas = retrieveSchemaInternal(validator, dependentSchema, rootSchema, formData, expandAllBranches, recurseList);\n    return schemas.map(s => mergeSchemas(schema, s));\n  });\n}","map":{"version":3,"names":["get","isEqual","set","times","transform","merge","flattenDeep","uniq","mergeAllOf","ADDITIONAL_PROPERTIES_KEY","ADDITIONAL_PROPERTY_FLAG","ALL_OF_KEY","ANY_OF_KEY","DEPENDENCIES_KEY","IF_KEY","ONE_OF_KEY","REF_KEY","PROPERTIES_KEY","ITEMS_KEY","findSchemaDefinition","splitKeyElementFromObject","getDiscriminatorFieldFromSchema","guessType","isObject","mergeSchemas","getFirstMatchingOption","retrieveSchema","validator","schema","rootSchema","arguments","length","undefined","rawFormData","retrieveSchemaInternal","resolveCondition","expandAllBranches","recurseList","formData","if","expression","then","else","otherwise","resolvedSchemaLessConditional","conditionValue","isValid","resolvedSchemas","schemas","concat","conditionalSchema","map","s","flatMap","getAllPermutationsOfXxxOf","listOfLists","allPermutations","reduce","permutations","list","element","i","forEach","permutation","push","resolveSchema","updatedSchemas","resolveReference","resolveDependencies","Array","isArray","allOf","allOfSchemaElements","allOfSubschema","updatedSchema","resolveAllReferences","resolvedSchema","$ref","localSchema","includes","refSchema","childrenLists","updatedProps","result","value","key","childList","items","stubExistingAdditionalProperties","theSchema","aFormData","properties","Object","keys","additionalProperties","type","restOfSchema","deep","e","console","warn","resolvedSchemaWithoutAllOf","hasAdditionalProperties","resolveAnyOrOneOfSchemas","anyOrOneOf","oneOf","anyOf","remaining","discriminator","option","item","dependencies","remainingSchema","processDependencies","dependencyKey","remainingDependencies","dependencyValue","withDependentProperties","withDependentSchema","additionallyRequired","required","from","Set","dependentSchemas","dependent","dependentSchema","resolvedOneOfs","subschema","resolvedOneOf","withExactlyOneSubschema","validSubschemas","filter","conditionPropertySchema","conditionSchema","dependentSubschema"],"sources":["D:\\Reactjs\\my-app\\node_modules\\@rjsf\\utils\\src\\schema\\retrieveSchema.ts"],"sourcesContent":["import get from 'lodash/get';\nimport isEqual from 'lodash/isEqual';\nimport set from 'lodash/set';\nimport times from 'lodash/times';\nimport transform from 'lodash/transform';\nimport merge from 'lodash/merge';\nimport flattenDeep from 'lodash/flattenDeep';\nimport uniq from 'lodash/uniq';\nimport mergeAllOf, { Options } from 'json-schema-merge-allof';\n\nimport {\n  ADDITIONAL_PROPERTIES_KEY,\n  ADDITIONAL_PROPERTY_FLAG,\n  ALL_OF_KEY,\n  ANY_OF_KEY,\n  DEPENDENCIES_KEY,\n  IF_KEY,\n  ONE_OF_KEY,\n  REF_KEY,\n  PROPERTIES_KEY,\n  ITEMS_KEY,\n} from '../constants';\nimport findSchemaDefinition, { splitKeyElementFromObject } from '../findSchemaDefinition';\nimport getDiscriminatorFieldFromSchema from '../getDiscriminatorFieldFromSchema';\nimport guessType from '../guessType';\nimport isObject from '../isObject';\nimport mergeSchemas from '../mergeSchemas';\nimport { FormContextType, GenericObjectType, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\nimport getFirstMatchingOption from './getFirstMatchingOption';\n\n/** Retrieves an expanded schema that has had all of its conditions, additional properties, references and dependencies\n * resolved and merged into the `schema` given a `validator`, `rootSchema` and `rawFormData` that is used to do the\n * potentially recursive resolution.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n * @param schema - The schema for which retrieving a schema is desired\n * @param [rootSchema={}] - The root schema that will be forwarded to all the APIs\n * @param [rawFormData] - The current formData, if any, to assist retrieving a schema\n * @returns - The schema having its conditions, additional properties, references and dependencies resolved\n */\nexport default function retrieveSchema<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(validator: ValidatorType<T, S, F>, schema: S, rootSchema: S = {} as S, rawFormData?: T): S {\n  return retrieveSchemaInternal<T, S, F>(validator, schema, rootSchema, rawFormData)[0];\n}\n\n/** Resolves a conditional block (if/else/then) by removing the condition and merging the appropriate conditional branch\n * with the rest of the schema. If `expandAllBranches` is true, then the `retrieveSchemaInteral()` results for both\n * conditions will be returned.\n *\n * @param validator - An implementation of the `ValidatorType` interface that is used to detect valid schema conditions\n * @param schema - The schema for which resolving a condition is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and\n *          dependencies as a list of schemas\n * @param recurseList - The list of recursive references already processed\n * @param [formData] - The current formData to assist retrieving a schema\n * @returns - A list of schemas with the appropriate conditions resolved, possibly with all branches expanded\n */\nexport function resolveCondition<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  rootSchema: S,\n  expandAllBranches: boolean,\n  recurseList: string[],\n  formData?: T\n): S[] {\n  const { if: expression, then, else: otherwise, ...resolvedSchemaLessConditional } = schema;\n\n  const conditionValue = validator.isValid(expression as S, formData || ({} as T), rootSchema);\n  let resolvedSchemas = [resolvedSchemaLessConditional as S];\n  let schemas: S[] = [];\n  if (expandAllBranches) {\n    if (then && typeof then !== 'boolean') {\n      schemas = schemas.concat(\n        retrieveSchemaInternal<T, S, F>(validator, then as S, rootSchema, formData, expandAllBranches, recurseList)\n      );\n    }\n    if (otherwise && typeof otherwise !== 'boolean') {\n      schemas = schemas.concat(\n        retrieveSchemaInternal<T, S, F>(validator, otherwise as S, rootSchema, formData, expandAllBranches, recurseList)\n      );\n    }\n  } else {\n    const conditionalSchema = conditionValue ? then : otherwise;\n    if (conditionalSchema && typeof conditionalSchema !== 'boolean') {\n      schemas = schemas.concat(\n        retrieveSchemaInternal<T, S, F>(\n          validator,\n          conditionalSchema as S,\n          rootSchema,\n          formData,\n          expandAllBranches,\n          recurseList\n        )\n      );\n    }\n  }\n  if (schemas.length) {\n    resolvedSchemas = schemas.map((s) => mergeSchemas(resolvedSchemaLessConditional, s) as S);\n  }\n  return resolvedSchemas.flatMap((s) =>\n    retrieveSchemaInternal<T, S, F>(validator, s, rootSchema, formData, expandAllBranches, recurseList)\n  );\n}\n\n/** Given a list of lists of allOf, anyOf or oneOf values, create a list of lists of all permutations of the values. The\n * `listOfLists` is expected to be all resolved values of the 1st...nth schemas within an `allOf`, `anyOf` or `oneOf`.\n * From those lists, build a matrix for each `xxxOf` where there is more than one schema for a row in the list of lists.\n *\n * For example:\n * - If there are three xxxOf rows (A, B, C) and they have been resolved such that there is only one A, two B and three\n *   C schemas then:\n *   - The permutation for the first row is `[[A]]`\n *   - The permutations for the second row are `[[A,B1], [A,B2]]`\n *   - The permutations for the third row are `[[A,B1,C1], [A,B1,C2], [A,B1,C3], [A,B2,C1], [A,B2,C2], [A,B2,C3]]`\n *\n * @param listOfLists - The list of lists of elements that represent the allOf, anyOf or oneOf resolved values in order\n * @returns - The list of all permutations of schemas for a set of `xxxOf`s\n */\nexport function getAllPermutationsOfXxxOf<S extends StrictRJSFSchema = RJSFSchema>(listOfLists: S[][]) {\n  const allPermutations: S[][] = listOfLists.reduce<S[][]>(\n    (permutations, list) => {\n      // When there are more than one set of schemas for a row, duplicate the set of permutations and add in the values\n      if (list.length > 1) {\n        return list.flatMap((element) => times(permutations.length, (i) => [...permutations[i]].concat(element)));\n      }\n      // Otherwise just push in the single value into the current set of permutations\n      permutations.forEach((permutation) => permutation.push(list[0]));\n      return permutations;\n    },\n    [[]] as S[][] // Start with an empty list\n  );\n\n  return allPermutations;\n}\n\n/** Resolves references and dependencies within a schema and its 'allOf' children. Passes the `expandAllBranches` flag\n * down to the `retrieveSchemaInternal()`, `resolveReference()` and `resolveDependencies()` helper calls. If\n * `expandAllBranches` is true, then all possible dependencies and/or allOf branches are returned.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n * @param schema - The schema for which resolving a schema is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and dependencies\n *          as a list of schemas\n * @param recurseList - The list of recursive references already processed\n * @param [formData] - The current formData, if any, to assist retrieving a schema\n * @returns - The list of schemas having its references, dependencies and allOf schemas resolved\n */\nexport function resolveSchema<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  rootSchema: S,\n  expandAllBranches: boolean,\n  recurseList: string[],\n  formData?: T\n): S[] {\n  const updatedSchemas = resolveReference<T, S, F>(\n    validator,\n    schema,\n    rootSchema,\n    expandAllBranches,\n    recurseList,\n    formData\n  );\n  if (updatedSchemas.length > 1 || updatedSchemas[0] !== schema) {\n    // return the updatedSchemas array if it has either multiple schemas within it\n    // OR the first schema is not the same as the original schema\n    return updatedSchemas;\n  }\n  if (DEPENDENCIES_KEY in schema) {\n    const resolvedSchemas = resolveDependencies<T, S, F>(\n      validator,\n      schema,\n      rootSchema,\n      expandAllBranches,\n      recurseList,\n      formData\n    );\n    return resolvedSchemas.flatMap((s) => {\n      return retrieveSchemaInternal<T, S, F>(validator, s, rootSchema, formData, expandAllBranches, recurseList);\n    });\n  }\n  if (ALL_OF_KEY in schema && Array.isArray(schema.allOf)) {\n    const allOfSchemaElements: S[][] = schema.allOf.map((allOfSubschema) =>\n      retrieveSchemaInternal<T, S, F>(\n        validator,\n        allOfSubschema as S,\n        rootSchema,\n        formData,\n        expandAllBranches,\n        recurseList\n      )\n    );\n    const allPermutations = getAllPermutationsOfXxxOf<S>(allOfSchemaElements);\n    return allPermutations.map((permutation) => ({ ...schema, allOf: permutation }));\n  }\n  // No $ref or dependencies or allOf attribute was found, returning the original schema.\n  return [schema];\n}\n\n/** Resolves all references within a schema and then returns the `retrieveSchemaInternal()` if the resolved schema is\n * actually different than the original. Passes the `expandAllBranches` flag down to the `retrieveSchemaInternal()`\n * helper call.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n * @param schema - The schema for which resolving a reference is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and dependencies\n *          as a list of schemas\n * @param recurseList - The list of recursive references already processed\n * @param [formData] - The current formData, if any, to assist retrieving a schema\n * @returns - The list schemas retrieved after having all references resolved\n */\nexport function resolveReference<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  rootSchema: S,\n  expandAllBranches: boolean,\n  recurseList: string[],\n  formData?: T\n): S[] {\n  const updatedSchema = resolveAllReferences<S>(schema, rootSchema, recurseList);\n  if (updatedSchema !== schema) {\n    // Only call this if the schema was actually changed by the `resolveAllReferences()` function\n    return retrieveSchemaInternal<T, S, F>(\n      validator,\n      updatedSchema,\n      rootSchema,\n      formData,\n      expandAllBranches,\n      recurseList\n    );\n  }\n  return [schema];\n}\n\n/** Resolves all references within the schema itself as well as any of its properties and array items.\n *\n * @param schema - The schema for which resolving all references is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param recurseList - List of $refs already resolved to prevent recursion\n * @returns - given schema will all references resolved or the original schema if no internal `$refs` were resolved\n */\nexport function resolveAllReferences<S extends StrictRJSFSchema = RJSFSchema>(\n  schema: S,\n  rootSchema: S,\n  recurseList: string[]\n): S {\n  if (!isObject(schema)) {\n    return schema;\n  }\n  let resolvedSchema: S = schema;\n  // resolve top level ref\n  if (REF_KEY in resolvedSchema) {\n    const { $ref, ...localSchema } = resolvedSchema;\n    // Check for a recursive reference and stop the loop\n    if (recurseList.includes($ref!)) {\n      return resolvedSchema;\n    }\n    recurseList.push($ref!);\n    // Retrieve the referenced schema definition.\n    const refSchema = findSchemaDefinition<S>($ref, rootSchema);\n    resolvedSchema = { ...refSchema, ...localSchema };\n  }\n\n  if (PROPERTIES_KEY in resolvedSchema) {\n    const childrenLists: string[][] = [];\n    const updatedProps = transform(\n      resolvedSchema[PROPERTIES_KEY]!,\n      (result, value, key: string) => {\n        const childList: string[] = [...recurseList];\n        result[key] = resolveAllReferences(value as S, rootSchema, childList);\n        childrenLists.push(childList);\n      },\n      {} as RJSFSchema\n    );\n    merge(recurseList, uniq(flattenDeep(childrenLists)));\n    resolvedSchema = { ...resolvedSchema, [PROPERTIES_KEY]: updatedProps };\n  }\n\n  if (\n    ITEMS_KEY in resolvedSchema &&\n    !Array.isArray(resolvedSchema.items) &&\n    typeof resolvedSchema.items !== 'boolean'\n  ) {\n    resolvedSchema = {\n      ...resolvedSchema,\n      items: resolveAllReferences(resolvedSchema.items as S, rootSchema, recurseList),\n    };\n  }\n\n  return isEqual(schema, resolvedSchema) ? schema : resolvedSchema;\n}\n\n/** Creates new 'properties' items for each key in the `formData`\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param theSchema - The schema for which the existing additional properties is desired\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s * @param validator\n * @param [aFormData] - The current formData, if any, to assist retrieving a schema\n * @returns - The updated schema with additional properties stubbed\n */\nexport function stubExistingAdditionalProperties<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(validator: ValidatorType<T, S, F>, theSchema: S, rootSchema?: S, aFormData?: T): S {\n  // Clone the schema so that we don't ruin the consumer's original\n  const schema = {\n    ...theSchema,\n    properties: { ...theSchema.properties },\n  };\n\n  // make sure formData is an object\n  const formData: GenericObjectType = aFormData && isObject(aFormData) ? aFormData : {};\n  Object.keys(formData).forEach((key) => {\n    if (key in schema.properties) {\n      // No need to stub, our schema already has the property\n      return;\n    }\n\n    let additionalProperties: S['additionalProperties'] = {};\n    if (typeof schema.additionalProperties !== 'boolean') {\n      if (REF_KEY in schema.additionalProperties!) {\n        additionalProperties = retrieveSchema<T, S, F>(\n          validator,\n          { $ref: get(schema.additionalProperties, [REF_KEY]) } as S,\n          rootSchema,\n          formData as T\n        );\n      } else if ('type' in schema.additionalProperties!) {\n        additionalProperties = { ...schema.additionalProperties };\n      } else if (ANY_OF_KEY in schema.additionalProperties! || ONE_OF_KEY in schema.additionalProperties!) {\n        additionalProperties = {\n          type: 'object',\n          ...schema.additionalProperties,\n        };\n      } else {\n        additionalProperties = { type: guessType(get(formData, [key])) };\n      }\n    } else {\n      additionalProperties = { type: guessType(get(formData, [key])) };\n    }\n\n    // The type of our new key should match the additionalProperties value;\n    schema.properties[key] = additionalProperties;\n    // Set our additional property flag so we know it was dynamically added\n    set(schema.properties, [key, ADDITIONAL_PROPERTY_FLAG], true);\n  });\n\n  return schema;\n}\n\n/** Internal handler that retrieves an expanded schema that has had all of its conditions, additional properties,\n * references and dependencies resolved and merged into the `schema` given a `validator`, `rootSchema` and `rawFormData`\n * that is used to do the potentially recursive resolution. If `expandAllBranches` is true, then all possible branches\n * of the schema and its references, conditions and dependencies are returned.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n * @param schema - The schema for which retrieving a schema is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param [rawFormData] - The current formData, if any, to assist retrieving a schema\n * @param [expandAllBranches=false] - Flag, if true, will return all possible branches of conditions, any/oneOf and\n *          dependencies as a list of schemas\n * @param [recurseList=[]] - The optional, list of recursive references already processed\n * @returns - The schema(s) resulting from having its conditions, additional properties, references and dependencies\n *          resolved. Multiple schemas may be returned if `expandAllBranches` is true.\n */\nexport function retrieveSchemaInternal<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  rootSchema: S,\n  rawFormData?: T,\n  expandAllBranches = false,\n  recurseList: string[] = []\n): S[] {\n  if (!isObject(schema)) {\n    return [{} as S];\n  }\n  const resolvedSchemas = resolveSchema<T, S, F>(\n    validator,\n    schema,\n    rootSchema,\n    expandAllBranches,\n    recurseList,\n    rawFormData\n  );\n  return resolvedSchemas.flatMap((s: S) => {\n    let resolvedSchema = s;\n    if (IF_KEY in resolvedSchema) {\n      return resolveCondition<T, S, F>(\n        validator,\n        resolvedSchema,\n        rootSchema,\n        expandAllBranches,\n        recurseList,\n        rawFormData as T\n      );\n    }\n    if (ALL_OF_KEY in resolvedSchema) {\n      // resolve allOf schemas\n      if (expandAllBranches) {\n        const { allOf, ...restOfSchema } = resolvedSchema;\n        return [...(allOf as S[]), restOfSchema as S];\n      }\n      try {\n        resolvedSchema = mergeAllOf(resolvedSchema, {\n          deep: false,\n        } as Options) as S;\n      } catch (e) {\n        console.warn('could not merge subschemas in allOf:\\n', e);\n        const { allOf, ...resolvedSchemaWithoutAllOf } = resolvedSchema;\n        return resolvedSchemaWithoutAllOf as S;\n      }\n    }\n    const hasAdditionalProperties =\n      ADDITIONAL_PROPERTIES_KEY in resolvedSchema && resolvedSchema.additionalProperties !== false;\n    if (hasAdditionalProperties) {\n      return stubExistingAdditionalProperties<T, S, F>(validator, resolvedSchema, rootSchema, rawFormData as T);\n    }\n\n    return resolvedSchema;\n  });\n}\n\n/** Resolves an `anyOf` or `oneOf` within a schema (if present) to the list of schemas returned from\n * `retrieveSchemaInternal()` for the best matching option. If `expandAllBranches` is true, then a list of schemas for ALL\n * options are retrieved and returned.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n * @param schema - The schema for which retrieving a schema is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and dependencies\n *          as a list of schemas\n * @param [rawFormData] - The current formData, if any, to assist retrieving a schema, defaults to an empty object\n * @returns - Either an array containing the best matching option or all options if `expandAllBranches` is true\n */\nexport function resolveAnyOrOneOfSchemas<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(validator: ValidatorType<T, S, F>, schema: S, rootSchema: S, expandAllBranches: boolean, rawFormData?: T) {\n  let anyOrOneOf: S[] | undefined;\n  const { oneOf, anyOf, ...remaining } = schema;\n  if (Array.isArray(oneOf)) {\n    anyOrOneOf = oneOf as S[];\n  } else if (Array.isArray(anyOf)) {\n    anyOrOneOf = anyOf as S[];\n  }\n  if (anyOrOneOf) {\n    // Ensure that during expand all branches we pass an object rather than undefined so that all options are interrogated\n    const formData = rawFormData === undefined && expandAllBranches ? ({} as T) : rawFormData;\n    const discriminator = getDiscriminatorFieldFromSchema<S>(schema);\n    anyOrOneOf = anyOrOneOf.map((s) => {\n      // Due to anyOf/oneOf possibly using the same $ref we always pass a fresh recurse list array so that each option\n      // can resolve recursive references independently\n      return resolveAllReferences(s, rootSchema, []);\n    });\n    // Call this to trigger the set of isValid() calls that the schema parser will need\n    const option = getFirstMatchingOption<T, S, F>(validator, formData, anyOrOneOf, rootSchema, discriminator);\n    if (expandAllBranches) {\n      return anyOrOneOf.map((item) => mergeSchemas(remaining, item) as S);\n    }\n    schema = mergeSchemas(remaining, anyOrOneOf[option]) as S;\n  }\n  return [schema];\n}\n\n/** Resolves dependencies within a schema and its 'anyOf/oneOf' children. Passes the `expandAllBranches` flag down to\n * the `resolveAnyOrOneOfSchema()` and `processDependencies()` helper calls.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n * @param schema - The schema for which resolving a dependency is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and dependencies\n *          as a list of schemas\n * @param recurseList - The list of recursive references already processed\n * @param [formData] - The current formData, if any, to assist retrieving a schema\n * @returns - The list of schemas with their dependencies resolved\n */\nexport function resolveDependencies<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  rootSchema: S,\n  expandAllBranches: boolean,\n  recurseList: string[],\n  formData?: T\n): S[] {\n  // Drop the dependencies from the source schema.\n  const { dependencies, ...remainingSchema } = schema;\n  const resolvedSchemas = resolveAnyOrOneOfSchemas<T, S, F>(\n    validator,\n    remainingSchema as S,\n    rootSchema,\n    expandAllBranches,\n    formData\n  );\n  return resolvedSchemas.flatMap((resolvedSchema) =>\n    processDependencies<T, S, F>(\n      validator,\n      dependencies,\n      resolvedSchema,\n      rootSchema,\n      expandAllBranches,\n      recurseList,\n      formData\n    )\n  );\n}\n\n/** Processes all the `dependencies` recursively into the list of `resolvedSchema`s as needed. Passes the\n * `expandAllBranches` flag down to the `withDependentSchema()` and the recursive `processDependencies()` helper calls.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n * @param dependencies - The set of dependencies that needs to be processed\n * @param resolvedSchema - The schema for which processing dependencies is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and dependencies\n *          as a list of schemas\n * @param recurseList - The list of recursive references already processed\n * @param [formData] - The current formData, if any, to assist retrieving a schema\n * @returns - The schema with the `dependencies` resolved into it\n */\nexport function processDependencies<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  dependencies: S['dependencies'],\n  resolvedSchema: S,\n  rootSchema: S,\n  expandAllBranches: boolean,\n  recurseList: string[],\n  formData?: T\n): S[] {\n  let schemas = [resolvedSchema];\n  // Process dependencies updating the local schema properties as appropriate.\n  for (const dependencyKey in dependencies) {\n    // Skip this dependency if its trigger property is not present.\n    if (!expandAllBranches && get(formData, [dependencyKey]) === undefined) {\n      continue;\n    }\n    // Skip this dependency if it is not included in the schema (such as when dependencyKey is itself a hidden dependency.)\n    if (resolvedSchema.properties && !(dependencyKey in resolvedSchema.properties)) {\n      continue;\n    }\n    const [remainingDependencies, dependencyValue] = splitKeyElementFromObject(\n      dependencyKey,\n      dependencies as GenericObjectType\n    );\n    if (Array.isArray(dependencyValue)) {\n      schemas[0] = withDependentProperties<S>(resolvedSchema, dependencyValue);\n    } else if (isObject(dependencyValue)) {\n      schemas = withDependentSchema<T, S, F>(\n        validator,\n        resolvedSchema,\n        rootSchema,\n        dependencyKey,\n        dependencyValue as S,\n        expandAllBranches,\n        recurseList,\n        formData\n      );\n    }\n    return schemas.flatMap((schema) =>\n      processDependencies<T, S, F>(\n        validator,\n        remainingDependencies,\n        schema,\n        rootSchema,\n        expandAllBranches,\n        recurseList,\n        formData\n      )\n    );\n  }\n  return schemas;\n}\n\n/** Updates a schema with additionally required properties added\n *\n * @param schema - The schema for which resolving a dependent properties is desired\n * @param [additionallyRequired] - An optional array of additionally required names\n * @returns - The schema with the additional required values merged in\n */\nexport function withDependentProperties<S extends StrictRJSFSchema = RJSFSchema>(\n  schema: S,\n  additionallyRequired?: string[]\n) {\n  if (!additionallyRequired) {\n    return schema;\n  }\n  const required = Array.isArray(schema.required)\n    ? Array.from(new Set([...schema.required, ...additionallyRequired]))\n    : additionallyRequired;\n  return { ...schema, required: required };\n}\n\n/** Merges a dependent schema into the `schema` dealing with oneOfs and references. Passes the `expandAllBranches` flag\n * down to the `retrieveSchemaInternal()`, `resolveReference()` and `withExactlyOneSubschema()` helper calls.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n * @param schema - The schema for which resolving a dependent schema is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param dependencyKey - The key name of the dependency\n * @param dependencyValue - The potentially dependent schema\n * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and dependencies\n *          as a list of schemas\n * @param recurseList - The list of recursive references already processed\n * @param [formData]- The current formData to assist retrieving a schema\n * @returns - The list of schemas with the dependent schema resolved into them\n */\nexport function withDependentSchema<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  rootSchema: S,\n  dependencyKey: string,\n  dependencyValue: S,\n  expandAllBranches: boolean,\n  recurseList: string[],\n  formData?: T\n): S[] {\n  const dependentSchemas = retrieveSchemaInternal<T, S, F>(\n    validator,\n    dependencyValue,\n    rootSchema,\n    formData,\n    expandAllBranches,\n    recurseList\n  );\n  return dependentSchemas.flatMap((dependent) => {\n    const { oneOf, ...dependentSchema } = dependent;\n    schema = mergeSchemas(schema, dependentSchema) as S;\n    // Since it does not contain oneOf, we return the original schema.\n    if (oneOf === undefined) {\n      return schema;\n    }\n    // Resolve $refs inside oneOf.\n    const resolvedOneOfs = oneOf.map((subschema) => {\n      if (typeof subschema === 'boolean' || !(REF_KEY in subschema)) {\n        return [subschema as S];\n      }\n      return resolveReference<T, S, F>(validator, subschema as S, rootSchema, expandAllBranches, recurseList, formData);\n    });\n    const allPermutations = getAllPermutationsOfXxxOf(resolvedOneOfs);\n    return allPermutations.flatMap((resolvedOneOf) =>\n      withExactlyOneSubschema<T, S, F>(\n        validator,\n        schema,\n        rootSchema,\n        dependencyKey,\n        resolvedOneOf,\n        expandAllBranches,\n        recurseList,\n        formData\n      )\n    );\n  });\n}\n\n/** Returns a list of `schema`s with the best choice from the `oneOf` options merged into it. If `expandAllBranches` is\n * true, then a list of schemas for ALL options are retrieved and returned. Passes the `expandAllBranches` flag down to\n * the `retrieveSchemaInternal()` helper call.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used to validate oneOf options\n * @param schema - The schema for which resolving a oneOf subschema is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param dependencyKey - The key name of the oneOf dependency\n * @param oneOf - The list of schemas representing the oneOf options\n * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and dependencies\n *          as a list of schemas\n * @param recurseList - The list of recursive references already processed\n * @param [formData] - The current formData to assist retrieving a schema\n * @returns - Either an array containing the best matching option or all options if `expandAllBranches` is true\n */\nexport function withExactlyOneSubschema<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  rootSchema: S,\n  dependencyKey: string,\n  oneOf: S['oneOf'],\n  expandAllBranches: boolean,\n  recurseList: string[],\n  formData?: T\n): S[] {\n  const validSubschemas = oneOf!.filter((subschema) => {\n    if (typeof subschema === 'boolean' || !subschema || !subschema.properties) {\n      return false;\n    }\n    const { [dependencyKey]: conditionPropertySchema } = subschema.properties;\n    if (conditionPropertySchema) {\n      const conditionSchema: S = {\n        type: 'object',\n        properties: {\n          [dependencyKey]: conditionPropertySchema,\n        },\n      } as S;\n      return validator.isValid(conditionSchema, formData, rootSchema) || expandAllBranches;\n    }\n    return false;\n  });\n\n  if (!expandAllBranches && validSubschemas!.length !== 1) {\n    console.warn(\"ignoring oneOf in dependencies because there isn't exactly one subschema that is valid\");\n    return [schema];\n  }\n  return validSubschemas.flatMap((s) => {\n    const subschema: S = s as S;\n    const [dependentSubschema] = splitKeyElementFromObject(dependencyKey, subschema.properties as GenericObjectType);\n    const dependentSchema = { ...subschema, properties: dependentSubschema };\n    const schemas = retrieveSchemaInternal<T, S, F>(\n      validator,\n      dependentSchema,\n      rootSchema,\n      formData,\n      expandAllBranches,\n      recurseList\n    );\n    return schemas.map((s) => mergeSchemas(schema, s) as S);\n  });\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}