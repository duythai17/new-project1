{"ast":null,"code":"import get from 'lodash/get';\nimport isEqual from 'lodash/isEqual';\nimport set from 'lodash/set';\nimport times from 'lodash/times';\nimport transform from 'lodash/transform';\nimport merge from 'lodash/merge';\nimport flattenDeep from 'lodash/flattenDeep';\nimport uniq from 'lodash/uniq';\nimport mergeAllOf from 'json-schema-merge-allof';\nimport { ADDITIONAL_PROPERTIES_KEY, ADDITIONAL_PROPERTY_FLAG, ALL_OF_KEY, ANY_OF_KEY, DEPENDENCIES_KEY, IF_KEY, ONE_OF_KEY, REF_KEY, PROPERTIES_KEY, ITEMS_KEY } from '../constants';\nimport findSchemaDefinition, { splitKeyElementFromObject } from '../findSchemaDefinition';\nimport getDiscriminatorFieldFromSchema from '../getDiscriminatorFieldFromSchema';\nimport guessType from '../guessType';\nimport isObject from '../isObject';\nimport mergeSchemas from '../mergeSchemas';\nimport getFirstMatchingOption from './getFirstMatchingOption';\n/** Retrieves an expanded schema that has had all of its conditions, additional properties, references and dependencies\n * resolved and merged into the `schema` given a `validator`, `rootSchema` and `rawFormData` that is used to do the\n * potentially recursive resolution.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n * @param schema - The schema for which retrieving a schema is desired\n * @param [rootSchema={}] - The root schema that will be forwarded to all the APIs\n * @param [rawFormData] - The current formData, if any, to assist retrieving a schema\n * @returns - The schema having its conditions, additional properties, references and dependencies resolved\n */\nexport default function retrieveSchema(validator, schema, rootSchema = {}, rawFormData) {\n  return retrieveSchemaInternal(validator, schema, rootSchema, rawFormData)[0];\n}\n/** Resolves a conditional block (if/else/then) by removing the condition and merging the appropriate conditional branch\n * with the rest of the schema. If `expandAllBranches` is true, then the `retrieveSchemaInteral()` results for both\n * conditions will be returned.\n *\n * @param validator - An implementation of the `ValidatorType` interface that is used to detect valid schema conditions\n * @param schema - The schema for which resolving a condition is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and\n *          dependencies as a list of schemas\n * @param recurseList - The list of recursive references already processed\n * @param [formData] - The current formData to assist retrieving a schema\n * @returns - A list of schemas with the appropriate conditions resolved, possibly with all branches expanded\n */\nexport function resolveCondition(validator, schema, rootSchema, expandAllBranches, recurseList, formData) {\n  const {\n    if: expression,\n    then,\n    else: otherwise,\n    ...resolvedSchemaLessConditional\n  } = schema;\n  const conditionValue = validator.isValid(expression, formData || {}, rootSchema);\n  let resolvedSchemas = [resolvedSchemaLessConditional];\n  let schemas = [];\n  if (expandAllBranches) {\n    if (then && typeof then !== 'boolean') {\n      schemas = schemas.concat(retrieveSchemaInternal(validator, then, rootSchema, formData, expandAllBranches, recurseList));\n    }\n    if (otherwise && typeof otherwise !== 'boolean') {\n      schemas = schemas.concat(retrieveSchemaInternal(validator, otherwise, rootSchema, formData, expandAllBranches, recurseList));\n    }\n  } else {\n    const conditionalSchema = conditionValue ? then : otherwise;\n    if (conditionalSchema && typeof conditionalSchema !== 'boolean') {\n      schemas = schemas.concat(retrieveSchemaInternal(validator, conditionalSchema, rootSchema, formData, expandAllBranches, recurseList));\n    }\n  }\n  if (schemas.length) {\n    resolvedSchemas = schemas.map(s => mergeSchemas(resolvedSchemaLessConditional, s));\n  }\n  return resolvedSchemas.flatMap(s => retrieveSchemaInternal(validator, s, rootSchema, formData, expandAllBranches, recurseList));\n}\n/** Given a list of lists of allOf, anyOf or oneOf values, create a list of lists of all permutations of the values. The\n * `listOfLists` is expected to be all resolved values of the 1st...nth schemas within an `allOf`, `anyOf` or `oneOf`.\n * From those lists, build a matrix for each `xxxOf` where there is more than one schema for a row in the list of lists.\n *\n * For example:\n * - If there are three xxxOf rows (A, B, C) and they have been resolved such that there is only one A, two B and three\n *   C schemas then:\n *   - The permutation for the first row is `[[A]]`\n *   - The permutations for the second row are `[[A,B1], [A,B2]]`\n *   - The permutations for the third row are `[[A,B1,C1], [A,B1,C2], [A,B1,C3], [A,B2,C1], [A,B2,C2], [A,B2,C3]]`\n *\n * @param listOfLists - The list of lists of elements that represent the allOf, anyOf or oneOf resolved values in order\n * @returns - The list of all permutations of schemas for a set of `xxxOf`s\n */\nexport function getAllPermutationsOfXxxOf(listOfLists) {\n  const allPermutations = listOfLists.reduce((permutations, list) => {\n    // When there are more than one set of schemas for a row, duplicate the set of permutations and add in the values\n    if (list.length > 1) {\n      return list.flatMap(element => times(permutations.length, i => [...permutations[i]].concat(element)));\n    }\n    // Otherwise just push in the single value into the current set of permutations\n    permutations.forEach(permutation => permutation.push(list[0]));\n    return permutations;\n  }, [[]] // Start with an empty list\n  );\n  return allPermutations;\n}\n/** Resolves references and dependencies within a schema and its 'allOf' children. Passes the `expandAllBranches` flag\n * down to the `retrieveSchemaInternal()`, `resolveReference()` and `resolveDependencies()` helper calls. If\n * `expandAllBranches` is true, then all possible dependencies and/or allOf branches are returned.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n * @param schema - The schema for which resolving a schema is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and dependencies\n *          as a list of schemas\n * @param recurseList - The list of recursive references already processed\n * @param [formData] - The current formData, if any, to assist retrieving a schema\n * @returns - The list of schemas having its references, dependencies and allOf schemas resolved\n */\nexport function resolveSchema(validator, schema, rootSchema, expandAllBranches, recurseList, formData) {\n  const updatedSchemas = resolveReference(validator, schema, rootSchema, expandAllBranches, recurseList, formData);\n  if (updatedSchemas.length > 1 || updatedSchemas[0] !== schema) {\n    // return the updatedSchemas array if it has either multiple schemas within it\n    // OR the first schema is not the same as the original schema\n    return updatedSchemas;\n  }\n  if (DEPENDENCIES_KEY in schema) {\n    const resolvedSchemas = resolveDependencies(validator, schema, rootSchema, expandAllBranches, recurseList, formData);\n    return resolvedSchemas.flatMap(s => {\n      return retrieveSchemaInternal(validator, s, rootSchema, formData, expandAllBranches, recurseList);\n    });\n  }\n  if (ALL_OF_KEY in schema && Array.isArray(schema.allOf)) {\n    const allOfSchemaElements = schema.allOf.map(allOfSubschema => retrieveSchemaInternal(validator, allOfSubschema, rootSchema, formData, expandAllBranches, recurseList));\n    const allPermutations = getAllPermutationsOfXxxOf(allOfSchemaElements);\n    return allPermutations.map(permutation => ({\n      ...schema,\n      allOf: permutation\n    }));\n  }\n  // No $ref or dependencies or allOf attribute was found, returning the original schema.\n  return [schema];\n}\n/** Resolves all references within a schema and then returns the `retrieveSchemaInternal()` if the resolved schema is\n * actually different than the original. Passes the `expandAllBranches` flag down to the `retrieveSchemaInternal()`\n * helper call.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n * @param schema - The schema for which resolving a reference is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and dependencies\n *          as a list of schemas\n * @param recurseList - The list of recursive references already processed\n * @param [formData] - The current formData, if any, to assist retrieving a schema\n * @returns - The list schemas retrieved after having all references resolved\n */\nexport function resolveReference(validator, schema, rootSchema, expandAllBranches, recurseList, formData) {\n  const updatedSchema = resolveAllReferences(schema, rootSchema, recurseList);\n  if (updatedSchema !== schema) {\n    // Only call this if the schema was actually changed by the `resolveAllReferences()` function\n    return retrieveSchemaInternal(validator, updatedSchema, rootSchema, formData, expandAllBranches, recurseList);\n  }\n  return [schema];\n}\n/** Resolves all references within the schema itself as well as any of its properties and array items.\n *\n * @param schema - The schema for which resolving all references is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param recurseList - List of $refs already resolved to prevent recursion\n * @returns - given schema will all references resolved or the original schema if no internal `$refs` were resolved\n */\nexport function resolveAllReferences(schema, rootSchema, recurseList) {\n  if (!isObject(schema)) {\n    return schema;\n  }\n  let resolvedSchema = schema;\n  // resolve top level ref\n  if (REF_KEY in resolvedSchema) {\n    const {\n      $ref,\n      ...localSchema\n    } = resolvedSchema;\n    // Check for a recursive reference and stop the loop\n    if (recurseList.includes($ref)) {\n      return resolvedSchema;\n    }\n    recurseList.push($ref);\n    // Retrieve the referenced schema definition.\n    const refSchema = findSchemaDefinition($ref, rootSchema);\n    resolvedSchema = {\n      ...refSchema,\n      ...localSchema\n    };\n  }\n  if (PROPERTIES_KEY in resolvedSchema) {\n    const childrenLists = [];\n    const updatedProps = transform(resolvedSchema[PROPERTIES_KEY], (result, value, key) => {\n      const childList = [...recurseList];\n      result[key] = resolveAllReferences(value, rootSchema, childList);\n      childrenLists.push(childList);\n    }, {});\n    merge(recurseList, uniq(flattenDeep(childrenLists)));\n    resolvedSchema = {\n      ...resolvedSchema,\n      [PROPERTIES_KEY]: updatedProps\n    };\n  }\n  if (ITEMS_KEY in resolvedSchema && !Array.isArray(resolvedSchema.items) && typeof resolvedSchema.items !== 'boolean') {\n    resolvedSchema = {\n      ...resolvedSchema,\n      items: resolveAllReferences(resolvedSchema.items, rootSchema, recurseList)\n    };\n  }\n  return isEqual(schema, resolvedSchema) ? schema : resolvedSchema;\n}\n/** Creates new 'properties' items for each key in the `formData`\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param theSchema - The schema for which the existing additional properties is desired\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s * @param validator\n * @param [aFormData] - The current formData, if any, to assist retrieving a schema\n * @returns - The updated schema with additional properties stubbed\n */\nexport function stubExistingAdditionalProperties(validator, theSchema, rootSchema, aFormData) {\n  // Clone the schema so that we don't ruin the consumer's original\n  const schema = {\n    ...theSchema,\n    properties: {\n      ...theSchema.properties\n    }\n  };\n  // make sure formData is an object\n  const formData = aFormData && isObject(aFormData) ? aFormData : {};\n  Object.keys(formData).forEach(key => {\n    if (key in schema.properties) {\n      // No need to stub, our schema already has the property\n      return;\n    }\n    let additionalProperties = {};\n    if (typeof schema.additionalProperties !== 'boolean') {\n      if (REF_KEY in schema.additionalProperties) {\n        additionalProperties = retrieveSchema(validator, {\n          $ref: get(schema.additionalProperties, [REF_KEY])\n        }, rootSchema, formData);\n      } else if ('type' in schema.additionalProperties) {\n        additionalProperties = {\n          ...schema.additionalProperties\n        };\n      } else if (ANY_OF_KEY in schema.additionalProperties || ONE_OF_KEY in schema.additionalProperties) {\n        additionalProperties = {\n          type: 'object',\n          ...schema.additionalProperties\n        };\n      } else {\n        additionalProperties = {\n          type: guessType(get(formData, [key]))\n        };\n      }\n    } else {\n      additionalProperties = {\n        type: guessType(get(formData, [key]))\n      };\n    }\n    // The type of our new key should match the additionalProperties value;\n    schema.properties[key] = additionalProperties;\n    // Set our additional property flag so we know it was dynamically added\n    set(schema.properties, [key, ADDITIONAL_PROPERTY_FLAG], true);\n  });\n  return schema;\n}\n/** Internal handler that retrieves an expanded schema that has had all of its conditions, additional properties,\n * references and dependencies resolved and merged into the `schema` given a `validator`, `rootSchema` and `rawFormData`\n * that is used to do the potentially recursive resolution. If `expandAllBranches` is true, then all possible branches\n * of the schema and its references, conditions and dependencies are returned.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n * @param schema - The schema for which retrieving a schema is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param [rawFormData] - The current formData, if any, to assist retrieving a schema\n * @param [expandAllBranches=false] - Flag, if true, will return all possible branches of conditions, any/oneOf and\n *          dependencies as a list of schemas\n * @param [recurseList=[]] - The optional, list of recursive references already processed\n * @returns - The schema(s) resulting from having its conditions, additional properties, references and dependencies\n *          resolved. Multiple schemas may be returned if `expandAllBranches` is true.\n */\nexport function retrieveSchemaInternal(validator, schema, rootSchema, rawFormData, expandAllBranches = false, recurseList = []) {\n  if (!isObject(schema)) {\n    return [{}];\n  }\n  const resolvedSchemas = resolveSchema(validator, schema, rootSchema, expandAllBranches, recurseList, rawFormData);\n  return resolvedSchemas.flatMap(s => {\n    let resolvedSchema = s;\n    if (IF_KEY in resolvedSchema) {\n      return resolveCondition(validator, resolvedSchema, rootSchema, expandAllBranches, recurseList, rawFormData);\n    }\n    if (ALL_OF_KEY in resolvedSchema) {\n      // resolve allOf schemas\n      if (expandAllBranches) {\n        const {\n          allOf,\n          ...restOfSchema\n        } = resolvedSchema;\n        return [...allOf, restOfSchema];\n      }\n      try {\n        resolvedSchema = mergeAllOf(resolvedSchema, {\n          deep: false\n        });\n      } catch (e) {\n        console.warn('could not merge subschemas in allOf:\\n', e);\n        const {\n          allOf,\n          ...resolvedSchemaWithoutAllOf\n        } = resolvedSchema;\n        return resolvedSchemaWithoutAllOf;\n      }\n    }\n    const hasAdditionalProperties = ADDITIONAL_PROPERTIES_KEY in resolvedSchema && resolvedSchema.additionalProperties !== false;\n    if (hasAdditionalProperties) {\n      return stubExistingAdditionalProperties(validator, resolvedSchema, rootSchema, rawFormData);\n    }\n    return resolvedSchema;\n  });\n}\n/** Resolves an `anyOf` or `oneOf` within a schema (if present) to the list of schemas returned from\n * `retrieveSchemaInternal()` for the best matching option. If `expandAllBranches` is true, then a list of schemas for ALL\n * options are retrieved and returned.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n * @param schema - The schema for which retrieving a schema is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and dependencies\n *          as a list of schemas\n * @param [rawFormData] - The current formData, if any, to assist retrieving a schema, defaults to an empty object\n * @returns - Either an array containing the best matching option or all options if `expandAllBranches` is true\n */\nexport function resolveAnyOrOneOfSchemas(validator, schema, rootSchema, expandAllBranches, rawFormData) {\n  let anyOrOneOf;\n  const {\n    oneOf,\n    anyOf,\n    ...remaining\n  } = schema;\n  if (Array.isArray(oneOf)) {\n    anyOrOneOf = oneOf;\n  } else if (Array.isArray(anyOf)) {\n    anyOrOneOf = anyOf;\n  }\n  if (anyOrOneOf) {\n    // Ensure that during expand all branches we pass an object rather than undefined so that all options are interrogated\n    const formData = rawFormData === undefined && expandAllBranches ? {} : rawFormData;\n    const discriminator = getDiscriminatorFieldFromSchema(schema);\n    anyOrOneOf = anyOrOneOf.map(s => {\n      // Due to anyOf/oneOf possibly using the same $ref we always pass a fresh recurse list array so that each option\n      // can resolve recursive references independently\n      return resolveAllReferences(s, rootSchema, []);\n    });\n    // Call this to trigger the set of isValid() calls that the schema parser will need\n    const option = getFirstMatchingOption(validator, formData, anyOrOneOf, rootSchema, discriminator);\n    if (expandAllBranches) {\n      return anyOrOneOf.map(item => mergeSchemas(remaining, item));\n    }\n    schema = mergeSchemas(remaining, anyOrOneOf[option]);\n  }\n  return [schema];\n}\n/** Resolves dependencies within a schema and its 'anyOf/oneOf' children. Passes the `expandAllBranches` flag down to\n * the `resolveAnyOrOneOfSchema()` and `processDependencies()` helper calls.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n * @param schema - The schema for which resolving a dependency is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and dependencies\n *          as a list of schemas\n * @param recurseList - The list of recursive references already processed\n * @param [formData] - The current formData, if any, to assist retrieving a schema\n * @returns - The list of schemas with their dependencies resolved\n */\nexport function resolveDependencies(validator, schema, rootSchema, expandAllBranches, recurseList, formData) {\n  // Drop the dependencies from the source schema.\n  const {\n    dependencies,\n    ...remainingSchema\n  } = schema;\n  const resolvedSchemas = resolveAnyOrOneOfSchemas(validator, remainingSchema, rootSchema, expandAllBranches, formData);\n  return resolvedSchemas.flatMap(resolvedSchema => processDependencies(validator, dependencies, resolvedSchema, rootSchema, expandAllBranches, recurseList, formData));\n}\n/** Processes all the `dependencies` recursively into the list of `resolvedSchema`s as needed. Passes the\n * `expandAllBranches` flag down to the `withDependentSchema()` and the recursive `processDependencies()` helper calls.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n * @param dependencies - The set of dependencies that needs to be processed\n * @param resolvedSchema - The schema for which processing dependencies is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and dependencies\n *          as a list of schemas\n * @param recurseList - The list of recursive references already processed\n * @param [formData] - The current formData, if any, to assist retrieving a schema\n * @returns - The schema with the `dependencies` resolved into it\n */\nexport function processDependencies(validator, dependencies, resolvedSchema, rootSchema, expandAllBranches, recurseList, formData) {\n  let schemas = [resolvedSchema];\n  // Process dependencies updating the local schema properties as appropriate.\n  for (const dependencyKey in dependencies) {\n    // Skip this dependency if its trigger property is not present.\n    if (!expandAllBranches && get(formData, [dependencyKey]) === undefined) {\n      continue;\n    }\n    // Skip this dependency if it is not included in the schema (such as when dependencyKey is itself a hidden dependency.)\n    if (resolvedSchema.properties && !(dependencyKey in resolvedSchema.properties)) {\n      continue;\n    }\n    const [remainingDependencies, dependencyValue] = splitKeyElementFromObject(dependencyKey, dependencies);\n    if (Array.isArray(dependencyValue)) {\n      schemas[0] = withDependentProperties(resolvedSchema, dependencyValue);\n    } else if (isObject(dependencyValue)) {\n      schemas = withDependentSchema(validator, resolvedSchema, rootSchema, dependencyKey, dependencyValue, expandAllBranches, recurseList, formData);\n    }\n    return schemas.flatMap(schema => processDependencies(validator, remainingDependencies, schema, rootSchema, expandAllBranches, recurseList, formData));\n  }\n  return schemas;\n}\n/** Updates a schema with additionally required properties added\n *\n * @param schema - The schema for which resolving a dependent properties is desired\n * @param [additionallyRequired] - An optional array of additionally required names\n * @returns - The schema with the additional required values merged in\n */\nexport function withDependentProperties(schema, additionallyRequired) {\n  if (!additionallyRequired) {\n    return schema;\n  }\n  const required = Array.isArray(schema.required) ? Array.from(new Set([...schema.required, ...additionallyRequired])) : additionallyRequired;\n  return {\n    ...schema,\n    required: required\n  };\n}\n/** Merges a dependent schema into the `schema` dealing with oneOfs and references. Passes the `expandAllBranches` flag\n * down to the `retrieveSchemaInternal()`, `resolveReference()` and `withExactlyOneSubschema()` helper calls.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n * @param schema - The schema for which resolving a dependent schema is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param dependencyKey - The key name of the dependency\n * @param dependencyValue - The potentially dependent schema\n * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and dependencies\n *          as a list of schemas\n * @param recurseList - The list of recursive references already processed\n * @param [formData]- The current formData to assist retrieving a schema\n * @returns - The list of schemas with the dependent schema resolved into them\n */\nexport function withDependentSchema(validator, schema, rootSchema, dependencyKey, dependencyValue, expandAllBranches, recurseList, formData) {\n  const dependentSchemas = retrieveSchemaInternal(validator, dependencyValue, rootSchema, formData, expandAllBranches, recurseList);\n  return dependentSchemas.flatMap(dependent => {\n    const {\n      oneOf,\n      ...dependentSchema\n    } = dependent;\n    schema = mergeSchemas(schema, dependentSchema);\n    // Since it does not contain oneOf, we return the original schema.\n    if (oneOf === undefined) {\n      return schema;\n    }\n    // Resolve $refs inside oneOf.\n    const resolvedOneOfs = oneOf.map(subschema => {\n      if (typeof subschema === 'boolean' || !(REF_KEY in subschema)) {\n        return [subschema];\n      }\n      return resolveReference(validator, subschema, rootSchema, expandAllBranches, recurseList, formData);\n    });\n    const allPermutations = getAllPermutationsOfXxxOf(resolvedOneOfs);\n    return allPermutations.flatMap(resolvedOneOf => withExactlyOneSubschema(validator, schema, rootSchema, dependencyKey, resolvedOneOf, expandAllBranches, recurseList, formData));\n  });\n}\n/** Returns a list of `schema`s with the best choice from the `oneOf` options merged into it. If `expandAllBranches` is\n * true, then a list of schemas for ALL options are retrieved and returned. Passes the `expandAllBranches` flag down to\n * the `retrieveSchemaInternal()` helper call.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used to validate oneOf options\n * @param schema - The schema for which resolving a oneOf subschema is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param dependencyKey - The key name of the oneOf dependency\n * @param oneOf - The list of schemas representing the oneOf options\n * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and dependencies\n *          as a list of schemas\n * @param recurseList - The list of recursive references already processed\n * @param [formData] - The current formData to assist retrieving a schema\n * @returns - Either an array containing the best matching option or all options if `expandAllBranches` is true\n */\nexport function withExactlyOneSubschema(validator, schema, rootSchema, dependencyKey, oneOf, expandAllBranches, recurseList, formData) {\n  const validSubschemas = oneOf.filter(subschema => {\n    if (typeof subschema === 'boolean' || !subschema || !subschema.properties) {\n      return false;\n    }\n    const {\n      [dependencyKey]: conditionPropertySchema\n    } = subschema.properties;\n    if (conditionPropertySchema) {\n      const conditionSchema = {\n        type: 'object',\n        properties: {\n          [dependencyKey]: conditionPropertySchema\n        }\n      };\n      return validator.isValid(conditionSchema, formData, rootSchema) || expandAllBranches;\n    }\n    return false;\n  });\n  if (!expandAllBranches && validSubschemas.length !== 1) {\n    console.warn(\"ignoring oneOf in dependencies because there isn't exactly one subschema that is valid\");\n    return [schema];\n  }\n  return validSubschemas.flatMap(s => {\n    const subschema = s;\n    const [dependentSubschema] = splitKeyElementFromObject(dependencyKey, subschema.properties);\n    const dependentSchema = {\n      ...subschema,\n      properties: dependentSubschema\n    };\n    const schemas = retrieveSchemaInternal(validator, dependentSchema, rootSchema, formData, expandAllBranches, recurseList);\n    return schemas.map(s => mergeSchemas(schema, s));\n  });\n}","map":{"version":3,"names":["get","isEqual","set","times","transform","merge","flattenDeep","uniq","mergeAllOf","ADDITIONAL_PROPERTIES_KEY","ADDITIONAL_PROPERTY_FLAG","ALL_OF_KEY","ANY_OF_KEY","DEPENDENCIES_KEY","IF_KEY","ONE_OF_KEY","REF_KEY","PROPERTIES_KEY","ITEMS_KEY","findSchemaDefinition","splitKeyElementFromObject","getDiscriminatorFieldFromSchema","guessType","isObject","mergeSchemas","getFirstMatchingOption","retrieveSchema","validator","schema","rootSchema","rawFormData","retrieveSchemaInternal","resolveCondition","expandAllBranches","recurseList","formData","if","expression","then","else","otherwise","resolvedSchemaLessConditional","conditionValue","isValid","resolvedSchemas","schemas","concat","conditionalSchema","length","map","s","flatMap","getAllPermutationsOfXxxOf","listOfLists","allPermutations","reduce","permutations","list","element","i","forEach","permutation","push","resolveSchema","updatedSchemas","resolveReference","resolveDependencies","Array","isArray","allOf","allOfSchemaElements","allOfSubschema","updatedSchema","resolveAllReferences","resolvedSchema","$ref","localSchema","includes","refSchema","childrenLists","updatedProps","result","value","key","childList","items","stubExistingAdditionalProperties","theSchema","aFormData","properties","Object","keys","additionalProperties","type","restOfSchema","deep","e","console","warn","resolvedSchemaWithoutAllOf","hasAdditionalProperties","resolveAnyOrOneOfSchemas","anyOrOneOf","oneOf","anyOf","remaining","undefined","discriminator","option","item","dependencies","remainingSchema","processDependencies","dependencyKey","remainingDependencies","dependencyValue","withDependentProperties","withDependentSchema","additionallyRequired","required","from","Set","dependentSchemas","dependent","dependentSchema","resolvedOneOfs","subschema","resolvedOneOf","withExactlyOneSubschema","validSubschemas","filter","conditionPropertySchema","conditionSchema","dependentSubschema"],"sources":["D:\\Reactjs\\my-app\\node_modules\\@rjsf\\utils\\src\\schema\\retrieveSchema.ts"],"sourcesContent":["import get from 'lodash/get';\nimport isEqual from 'lodash/isEqual';\nimport set from 'lodash/set';\nimport times from 'lodash/times';\nimport transform from 'lodash/transform';\nimport merge from 'lodash/merge';\nimport flattenDeep from 'lodash/flattenDeep';\nimport uniq from 'lodash/uniq';\nimport mergeAllOf, { Options } from 'json-schema-merge-allof';\n\nimport {\n  ADDITIONAL_PROPERTIES_KEY,\n  ADDITIONAL_PROPERTY_FLAG,\n  ALL_OF_KEY,\n  ANY_OF_KEY,\n  DEPENDENCIES_KEY,\n  IF_KEY,\n  ONE_OF_KEY,\n  REF_KEY,\n  PROPERTIES_KEY,\n  ITEMS_KEY,\n} from '../constants';\nimport findSchemaDefinition, { splitKeyElementFromObject } from '../findSchemaDefinition';\nimport getDiscriminatorFieldFromSchema from '../getDiscriminatorFieldFromSchema';\nimport guessType from '../guessType';\nimport isObject from '../isObject';\nimport mergeSchemas from '../mergeSchemas';\nimport { FormContextType, GenericObjectType, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\nimport getFirstMatchingOption from './getFirstMatchingOption';\n\n/** Retrieves an expanded schema that has had all of its conditions, additional properties, references and dependencies\n * resolved and merged into the `schema` given a `validator`, `rootSchema` and `rawFormData` that is used to do the\n * potentially recursive resolution.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n * @param schema - The schema for which retrieving a schema is desired\n * @param [rootSchema={}] - The root schema that will be forwarded to all the APIs\n * @param [rawFormData] - The current formData, if any, to assist retrieving a schema\n * @returns - The schema having its conditions, additional properties, references and dependencies resolved\n */\nexport default function retrieveSchema<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(validator: ValidatorType<T, S, F>, schema: S, rootSchema: S = {} as S, rawFormData?: T): S {\n  return retrieveSchemaInternal<T, S, F>(validator, schema, rootSchema, rawFormData)[0];\n}\n\n/** Resolves a conditional block (if/else/then) by removing the condition and merging the appropriate conditional branch\n * with the rest of the schema. If `expandAllBranches` is true, then the `retrieveSchemaInteral()` results for both\n * conditions will be returned.\n *\n * @param validator - An implementation of the `ValidatorType` interface that is used to detect valid schema conditions\n * @param schema - The schema for which resolving a condition is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and\n *          dependencies as a list of schemas\n * @param recurseList - The list of recursive references already processed\n * @param [formData] - The current formData to assist retrieving a schema\n * @returns - A list of schemas with the appropriate conditions resolved, possibly with all branches expanded\n */\nexport function resolveCondition<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  rootSchema: S,\n  expandAllBranches: boolean,\n  recurseList: string[],\n  formData?: T\n): S[] {\n  const { if: expression, then, else: otherwise, ...resolvedSchemaLessConditional } = schema;\n\n  const conditionValue = validator.isValid(expression as S, formData || ({} as T), rootSchema);\n  let resolvedSchemas = [resolvedSchemaLessConditional as S];\n  let schemas: S[] = [];\n  if (expandAllBranches) {\n    if (then && typeof then !== 'boolean') {\n      schemas = schemas.concat(\n        retrieveSchemaInternal<T, S, F>(validator, then as S, rootSchema, formData, expandAllBranches, recurseList)\n      );\n    }\n    if (otherwise && typeof otherwise !== 'boolean') {\n      schemas = schemas.concat(\n        retrieveSchemaInternal<T, S, F>(validator, otherwise as S, rootSchema, formData, expandAllBranches, recurseList)\n      );\n    }\n  } else {\n    const conditionalSchema = conditionValue ? then : otherwise;\n    if (conditionalSchema && typeof conditionalSchema !== 'boolean') {\n      schemas = schemas.concat(\n        retrieveSchemaInternal<T, S, F>(\n          validator,\n          conditionalSchema as S,\n          rootSchema,\n          formData,\n          expandAllBranches,\n          recurseList\n        )\n      );\n    }\n  }\n  if (schemas.length) {\n    resolvedSchemas = schemas.map((s) => mergeSchemas(resolvedSchemaLessConditional, s) as S);\n  }\n  return resolvedSchemas.flatMap((s) =>\n    retrieveSchemaInternal<T, S, F>(validator, s, rootSchema, formData, expandAllBranches, recurseList)\n  );\n}\n\n/** Given a list of lists of allOf, anyOf or oneOf values, create a list of lists of all permutations of the values. The\n * `listOfLists` is expected to be all resolved values of the 1st...nth schemas within an `allOf`, `anyOf` or `oneOf`.\n * From those lists, build a matrix for each `xxxOf` where there is more than one schema for a row in the list of lists.\n *\n * For example:\n * - If there are three xxxOf rows (A, B, C) and they have been resolved such that there is only one A, two B and three\n *   C schemas then:\n *   - The permutation for the first row is `[[A]]`\n *   - The permutations for the second row are `[[A,B1], [A,B2]]`\n *   - The permutations for the third row are `[[A,B1,C1], [A,B1,C2], [A,B1,C3], [A,B2,C1], [A,B2,C2], [A,B2,C3]]`\n *\n * @param listOfLists - The list of lists of elements that represent the allOf, anyOf or oneOf resolved values in order\n * @returns - The list of all permutations of schemas for a set of `xxxOf`s\n */\nexport function getAllPermutationsOfXxxOf<S extends StrictRJSFSchema = RJSFSchema>(listOfLists: S[][]) {\n  const allPermutations: S[][] = listOfLists.reduce<S[][]>(\n    (permutations, list) => {\n      // When there are more than one set of schemas for a row, duplicate the set of permutations and add in the values\n      if (list.length > 1) {\n        return list.flatMap((element) => times(permutations.length, (i) => [...permutations[i]].concat(element)));\n      }\n      // Otherwise just push in the single value into the current set of permutations\n      permutations.forEach((permutation) => permutation.push(list[0]));\n      return permutations;\n    },\n    [[]] as S[][] // Start with an empty list\n  );\n\n  return allPermutations;\n}\n\n/** Resolves references and dependencies within a schema and its 'allOf' children. Passes the `expandAllBranches` flag\n * down to the `retrieveSchemaInternal()`, `resolveReference()` and `resolveDependencies()` helper calls. If\n * `expandAllBranches` is true, then all possible dependencies and/or allOf branches are returned.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n * @param schema - The schema for which resolving a schema is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and dependencies\n *          as a list of schemas\n * @param recurseList - The list of recursive references already processed\n * @param [formData] - The current formData, if any, to assist retrieving a schema\n * @returns - The list of schemas having its references, dependencies and allOf schemas resolved\n */\nexport function resolveSchema<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  rootSchema: S,\n  expandAllBranches: boolean,\n  recurseList: string[],\n  formData?: T\n): S[] {\n  const updatedSchemas = resolveReference<T, S, F>(\n    validator,\n    schema,\n    rootSchema,\n    expandAllBranches,\n    recurseList,\n    formData\n  );\n  if (updatedSchemas.length > 1 || updatedSchemas[0] !== schema) {\n    // return the updatedSchemas array if it has either multiple schemas within it\n    // OR the first schema is not the same as the original schema\n    return updatedSchemas;\n  }\n  if (DEPENDENCIES_KEY in schema) {\n    const resolvedSchemas = resolveDependencies<T, S, F>(\n      validator,\n      schema,\n      rootSchema,\n      expandAllBranches,\n      recurseList,\n      formData\n    );\n    return resolvedSchemas.flatMap((s) => {\n      return retrieveSchemaInternal<T, S, F>(validator, s, rootSchema, formData, expandAllBranches, recurseList);\n    });\n  }\n  if (ALL_OF_KEY in schema && Array.isArray(schema.allOf)) {\n    const allOfSchemaElements: S[][] = schema.allOf.map((allOfSubschema) =>\n      retrieveSchemaInternal<T, S, F>(\n        validator,\n        allOfSubschema as S,\n        rootSchema,\n        formData,\n        expandAllBranches,\n        recurseList\n      )\n    );\n    const allPermutations = getAllPermutationsOfXxxOf<S>(allOfSchemaElements);\n    return allPermutations.map((permutation) => ({ ...schema, allOf: permutation }));\n  }\n  // No $ref or dependencies or allOf attribute was found, returning the original schema.\n  return [schema];\n}\n\n/** Resolves all references within a schema and then returns the `retrieveSchemaInternal()` if the resolved schema is\n * actually different than the original. Passes the `expandAllBranches` flag down to the `retrieveSchemaInternal()`\n * helper call.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n * @param schema - The schema for which resolving a reference is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and dependencies\n *          as a list of schemas\n * @param recurseList - The list of recursive references already processed\n * @param [formData] - The current formData, if any, to assist retrieving a schema\n * @returns - The list schemas retrieved after having all references resolved\n */\nexport function resolveReference<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  rootSchema: S,\n  expandAllBranches: boolean,\n  recurseList: string[],\n  formData?: T\n): S[] {\n  const updatedSchema = resolveAllReferences<S>(schema, rootSchema, recurseList);\n  if (updatedSchema !== schema) {\n    // Only call this if the schema was actually changed by the `resolveAllReferences()` function\n    return retrieveSchemaInternal<T, S, F>(\n      validator,\n      updatedSchema,\n      rootSchema,\n      formData,\n      expandAllBranches,\n      recurseList\n    );\n  }\n  return [schema];\n}\n\n/** Resolves all references within the schema itself as well as any of its properties and array items.\n *\n * @param schema - The schema for which resolving all references is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param recurseList - List of $refs already resolved to prevent recursion\n * @returns - given schema will all references resolved or the original schema if no internal `$refs` were resolved\n */\nexport function resolveAllReferences<S extends StrictRJSFSchema = RJSFSchema>(\n  schema: S,\n  rootSchema: S,\n  recurseList: string[]\n): S {\n  if (!isObject(schema)) {\n    return schema;\n  }\n  let resolvedSchema: S = schema;\n  // resolve top level ref\n  if (REF_KEY in resolvedSchema) {\n    const { $ref, ...localSchema } = resolvedSchema;\n    // Check for a recursive reference and stop the loop\n    if (recurseList.includes($ref!)) {\n      return resolvedSchema;\n    }\n    recurseList.push($ref!);\n    // Retrieve the referenced schema definition.\n    const refSchema = findSchemaDefinition<S>($ref, rootSchema);\n    resolvedSchema = { ...refSchema, ...localSchema };\n  }\n\n  if (PROPERTIES_KEY in resolvedSchema) {\n    const childrenLists: string[][] = [];\n    const updatedProps = transform(\n      resolvedSchema[PROPERTIES_KEY]!,\n      (result, value, key: string) => {\n        const childList: string[] = [...recurseList];\n        result[key] = resolveAllReferences(value as S, rootSchema, childList);\n        childrenLists.push(childList);\n      },\n      {} as RJSFSchema\n    );\n    merge(recurseList, uniq(flattenDeep(childrenLists)));\n    resolvedSchema = { ...resolvedSchema, [PROPERTIES_KEY]: updatedProps };\n  }\n\n  if (\n    ITEMS_KEY in resolvedSchema &&\n    !Array.isArray(resolvedSchema.items) &&\n    typeof resolvedSchema.items !== 'boolean'\n  ) {\n    resolvedSchema = {\n      ...resolvedSchema,\n      items: resolveAllReferences(resolvedSchema.items as S, rootSchema, recurseList),\n    };\n  }\n\n  return isEqual(schema, resolvedSchema) ? schema : resolvedSchema;\n}\n\n/** Creates new 'properties' items for each key in the `formData`\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param theSchema - The schema for which the existing additional properties is desired\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s * @param validator\n * @param [aFormData] - The current formData, if any, to assist retrieving a schema\n * @returns - The updated schema with additional properties stubbed\n */\nexport function stubExistingAdditionalProperties<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(validator: ValidatorType<T, S, F>, theSchema: S, rootSchema?: S, aFormData?: T): S {\n  // Clone the schema so that we don't ruin the consumer's original\n  const schema = {\n    ...theSchema,\n    properties: { ...theSchema.properties },\n  };\n\n  // make sure formData is an object\n  const formData: GenericObjectType = aFormData && isObject(aFormData) ? aFormData : {};\n  Object.keys(formData).forEach((key) => {\n    if (key in schema.properties) {\n      // No need to stub, our schema already has the property\n      return;\n    }\n\n    let additionalProperties: S['additionalProperties'] = {};\n    if (typeof schema.additionalProperties !== 'boolean') {\n      if (REF_KEY in schema.additionalProperties!) {\n        additionalProperties = retrieveSchema<T, S, F>(\n          validator,\n          { $ref: get(schema.additionalProperties, [REF_KEY]) } as S,\n          rootSchema,\n          formData as T\n        );\n      } else if ('type' in schema.additionalProperties!) {\n        additionalProperties = { ...schema.additionalProperties };\n      } else if (ANY_OF_KEY in schema.additionalProperties! || ONE_OF_KEY in schema.additionalProperties!) {\n        additionalProperties = {\n          type: 'object',\n          ...schema.additionalProperties,\n        };\n      } else {\n        additionalProperties = { type: guessType(get(formData, [key])) };\n      }\n    } else {\n      additionalProperties = { type: guessType(get(formData, [key])) };\n    }\n\n    // The type of our new key should match the additionalProperties value;\n    schema.properties[key] = additionalProperties;\n    // Set our additional property flag so we know it was dynamically added\n    set(schema.properties, [key, ADDITIONAL_PROPERTY_FLAG], true);\n  });\n\n  return schema;\n}\n\n/** Internal handler that retrieves an expanded schema that has had all of its conditions, additional properties,\n * references and dependencies resolved and merged into the `schema` given a `validator`, `rootSchema` and `rawFormData`\n * that is used to do the potentially recursive resolution. If `expandAllBranches` is true, then all possible branches\n * of the schema and its references, conditions and dependencies are returned.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n * @param schema - The schema for which retrieving a schema is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param [rawFormData] - The current formData, if any, to assist retrieving a schema\n * @param [expandAllBranches=false] - Flag, if true, will return all possible branches of conditions, any/oneOf and\n *          dependencies as a list of schemas\n * @param [recurseList=[]] - The optional, list of recursive references already processed\n * @returns - The schema(s) resulting from having its conditions, additional properties, references and dependencies\n *          resolved. Multiple schemas may be returned if `expandAllBranches` is true.\n */\nexport function retrieveSchemaInternal<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  rootSchema: S,\n  rawFormData?: T,\n  expandAllBranches = false,\n  recurseList: string[] = []\n): S[] {\n  if (!isObject(schema)) {\n    return [{} as S];\n  }\n  const resolvedSchemas = resolveSchema<T, S, F>(\n    validator,\n    schema,\n    rootSchema,\n    expandAllBranches,\n    recurseList,\n    rawFormData\n  );\n  return resolvedSchemas.flatMap((s: S) => {\n    let resolvedSchema = s;\n    if (IF_KEY in resolvedSchema) {\n      return resolveCondition<T, S, F>(\n        validator,\n        resolvedSchema,\n        rootSchema,\n        expandAllBranches,\n        recurseList,\n        rawFormData as T\n      );\n    }\n    if (ALL_OF_KEY in resolvedSchema) {\n      // resolve allOf schemas\n      if (expandAllBranches) {\n        const { allOf, ...restOfSchema } = resolvedSchema;\n        return [...(allOf as S[]), restOfSchema as S];\n      }\n      try {\n        resolvedSchema = mergeAllOf(resolvedSchema, {\n          deep: false,\n        } as Options) as S;\n      } catch (e) {\n        console.warn('could not merge subschemas in allOf:\\n', e);\n        const { allOf, ...resolvedSchemaWithoutAllOf } = resolvedSchema;\n        return resolvedSchemaWithoutAllOf as S;\n      }\n    }\n    const hasAdditionalProperties =\n      ADDITIONAL_PROPERTIES_KEY in resolvedSchema && resolvedSchema.additionalProperties !== false;\n    if (hasAdditionalProperties) {\n      return stubExistingAdditionalProperties<T, S, F>(validator, resolvedSchema, rootSchema, rawFormData as T);\n    }\n\n    return resolvedSchema;\n  });\n}\n\n/** Resolves an `anyOf` or `oneOf` within a schema (if present) to the list of schemas returned from\n * `retrieveSchemaInternal()` for the best matching option. If `expandAllBranches` is true, then a list of schemas for ALL\n * options are retrieved and returned.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n * @param schema - The schema for which retrieving a schema is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and dependencies\n *          as a list of schemas\n * @param [rawFormData] - The current formData, if any, to assist retrieving a schema, defaults to an empty object\n * @returns - Either an array containing the best matching option or all options if `expandAllBranches` is true\n */\nexport function resolveAnyOrOneOfSchemas<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(validator: ValidatorType<T, S, F>, schema: S, rootSchema: S, expandAllBranches: boolean, rawFormData?: T) {\n  let anyOrOneOf: S[] | undefined;\n  const { oneOf, anyOf, ...remaining } = schema;\n  if (Array.isArray(oneOf)) {\n    anyOrOneOf = oneOf as S[];\n  } else if (Array.isArray(anyOf)) {\n    anyOrOneOf = anyOf as S[];\n  }\n  if (anyOrOneOf) {\n    // Ensure that during expand all branches we pass an object rather than undefined so that all options are interrogated\n    const formData = rawFormData === undefined && expandAllBranches ? ({} as T) : rawFormData;\n    const discriminator = getDiscriminatorFieldFromSchema<S>(schema);\n    anyOrOneOf = anyOrOneOf.map((s) => {\n      // Due to anyOf/oneOf possibly using the same $ref we always pass a fresh recurse list array so that each option\n      // can resolve recursive references independently\n      return resolveAllReferences(s, rootSchema, []);\n    });\n    // Call this to trigger the set of isValid() calls that the schema parser will need\n    const option = getFirstMatchingOption<T, S, F>(validator, formData, anyOrOneOf, rootSchema, discriminator);\n    if (expandAllBranches) {\n      return anyOrOneOf.map((item) => mergeSchemas(remaining, item) as S);\n    }\n    schema = mergeSchemas(remaining, anyOrOneOf[option]) as S;\n  }\n  return [schema];\n}\n\n/** Resolves dependencies within a schema and its 'anyOf/oneOf' children. Passes the `expandAllBranches` flag down to\n * the `resolveAnyOrOneOfSchema()` and `processDependencies()` helper calls.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n * @param schema - The schema for which resolving a dependency is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and dependencies\n *          as a list of schemas\n * @param recurseList - The list of recursive references already processed\n * @param [formData] - The current formData, if any, to assist retrieving a schema\n * @returns - The list of schemas with their dependencies resolved\n */\nexport function resolveDependencies<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  rootSchema: S,\n  expandAllBranches: boolean,\n  recurseList: string[],\n  formData?: T\n): S[] {\n  // Drop the dependencies from the source schema.\n  const { dependencies, ...remainingSchema } = schema;\n  const resolvedSchemas = resolveAnyOrOneOfSchemas<T, S, F>(\n    validator,\n    remainingSchema as S,\n    rootSchema,\n    expandAllBranches,\n    formData\n  );\n  return resolvedSchemas.flatMap((resolvedSchema) =>\n    processDependencies<T, S, F>(\n      validator,\n      dependencies,\n      resolvedSchema,\n      rootSchema,\n      expandAllBranches,\n      recurseList,\n      formData\n    )\n  );\n}\n\n/** Processes all the `dependencies` recursively into the list of `resolvedSchema`s as needed. Passes the\n * `expandAllBranches` flag down to the `withDependentSchema()` and the recursive `processDependencies()` helper calls.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n * @param dependencies - The set of dependencies that needs to be processed\n * @param resolvedSchema - The schema for which processing dependencies is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and dependencies\n *          as a list of schemas\n * @param recurseList - The list of recursive references already processed\n * @param [formData] - The current formData, if any, to assist retrieving a schema\n * @returns - The schema with the `dependencies` resolved into it\n */\nexport function processDependencies<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  dependencies: S['dependencies'],\n  resolvedSchema: S,\n  rootSchema: S,\n  expandAllBranches: boolean,\n  recurseList: string[],\n  formData?: T\n): S[] {\n  let schemas = [resolvedSchema];\n  // Process dependencies updating the local schema properties as appropriate.\n  for (const dependencyKey in dependencies) {\n    // Skip this dependency if its trigger property is not present.\n    if (!expandAllBranches && get(formData, [dependencyKey]) === undefined) {\n      continue;\n    }\n    // Skip this dependency if it is not included in the schema (such as when dependencyKey is itself a hidden dependency.)\n    if (resolvedSchema.properties && !(dependencyKey in resolvedSchema.properties)) {\n      continue;\n    }\n    const [remainingDependencies, dependencyValue] = splitKeyElementFromObject(\n      dependencyKey,\n      dependencies as GenericObjectType\n    );\n    if (Array.isArray(dependencyValue)) {\n      schemas[0] = withDependentProperties<S>(resolvedSchema, dependencyValue);\n    } else if (isObject(dependencyValue)) {\n      schemas = withDependentSchema<T, S, F>(\n        validator,\n        resolvedSchema,\n        rootSchema,\n        dependencyKey,\n        dependencyValue as S,\n        expandAllBranches,\n        recurseList,\n        formData\n      );\n    }\n    return schemas.flatMap((schema) =>\n      processDependencies<T, S, F>(\n        validator,\n        remainingDependencies,\n        schema,\n        rootSchema,\n        expandAllBranches,\n        recurseList,\n        formData\n      )\n    );\n  }\n  return schemas;\n}\n\n/** Updates a schema with additionally required properties added\n *\n * @param schema - The schema for which resolving a dependent properties is desired\n * @param [additionallyRequired] - An optional array of additionally required names\n * @returns - The schema with the additional required values merged in\n */\nexport function withDependentProperties<S extends StrictRJSFSchema = RJSFSchema>(\n  schema: S,\n  additionallyRequired?: string[]\n) {\n  if (!additionallyRequired) {\n    return schema;\n  }\n  const required = Array.isArray(schema.required)\n    ? Array.from(new Set([...schema.required, ...additionallyRequired]))\n    : additionallyRequired;\n  return { ...schema, required: required };\n}\n\n/** Merges a dependent schema into the `schema` dealing with oneOfs and references. Passes the `expandAllBranches` flag\n * down to the `retrieveSchemaInternal()`, `resolveReference()` and `withExactlyOneSubschema()` helper calls.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n * @param schema - The schema for which resolving a dependent schema is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param dependencyKey - The key name of the dependency\n * @param dependencyValue - The potentially dependent schema\n * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and dependencies\n *          as a list of schemas\n * @param recurseList - The list of recursive references already processed\n * @param [formData]- The current formData to assist retrieving a schema\n * @returns - The list of schemas with the dependent schema resolved into them\n */\nexport function withDependentSchema<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  rootSchema: S,\n  dependencyKey: string,\n  dependencyValue: S,\n  expandAllBranches: boolean,\n  recurseList: string[],\n  formData?: T\n): S[] {\n  const dependentSchemas = retrieveSchemaInternal<T, S, F>(\n    validator,\n    dependencyValue,\n    rootSchema,\n    formData,\n    expandAllBranches,\n    recurseList\n  );\n  return dependentSchemas.flatMap((dependent) => {\n    const { oneOf, ...dependentSchema } = dependent;\n    schema = mergeSchemas(schema, dependentSchema) as S;\n    // Since it does not contain oneOf, we return the original schema.\n    if (oneOf === undefined) {\n      return schema;\n    }\n    // Resolve $refs inside oneOf.\n    const resolvedOneOfs = oneOf.map((subschema) => {\n      if (typeof subschema === 'boolean' || !(REF_KEY in subschema)) {\n        return [subschema as S];\n      }\n      return resolveReference<T, S, F>(validator, subschema as S, rootSchema, expandAllBranches, recurseList, formData);\n    });\n    const allPermutations = getAllPermutationsOfXxxOf(resolvedOneOfs);\n    return allPermutations.flatMap((resolvedOneOf) =>\n      withExactlyOneSubschema<T, S, F>(\n        validator,\n        schema,\n        rootSchema,\n        dependencyKey,\n        resolvedOneOf,\n        expandAllBranches,\n        recurseList,\n        formData\n      )\n    );\n  });\n}\n\n/** Returns a list of `schema`s with the best choice from the `oneOf` options merged into it. If `expandAllBranches` is\n * true, then a list of schemas for ALL options are retrieved and returned. Passes the `expandAllBranches` flag down to\n * the `retrieveSchemaInternal()` helper call.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used to validate oneOf options\n * @param schema - The schema for which resolving a oneOf subschema is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param dependencyKey - The key name of the oneOf dependency\n * @param oneOf - The list of schemas representing the oneOf options\n * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and dependencies\n *          as a list of schemas\n * @param recurseList - The list of recursive references already processed\n * @param [formData] - The current formData to assist retrieving a schema\n * @returns - Either an array containing the best matching option or all options if `expandAllBranches` is true\n */\nexport function withExactlyOneSubschema<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  rootSchema: S,\n  dependencyKey: string,\n  oneOf: S['oneOf'],\n  expandAllBranches: boolean,\n  recurseList: string[],\n  formData?: T\n): S[] {\n  const validSubschemas = oneOf!.filter((subschema) => {\n    if (typeof subschema === 'boolean' || !subschema || !subschema.properties) {\n      return false;\n    }\n    const { [dependencyKey]: conditionPropertySchema } = subschema.properties;\n    if (conditionPropertySchema) {\n      const conditionSchema: S = {\n        type: 'object',\n        properties: {\n          [dependencyKey]: conditionPropertySchema,\n        },\n      } as S;\n      return validator.isValid(conditionSchema, formData, rootSchema) || expandAllBranches;\n    }\n    return false;\n  });\n\n  if (!expandAllBranches && validSubschemas!.length !== 1) {\n    console.warn(\"ignoring oneOf in dependencies because there isn't exactly one subschema that is valid\");\n    return [schema];\n  }\n  return validSubschemas.flatMap((s) => {\n    const subschema: S = s as S;\n    const [dependentSubschema] = splitKeyElementFromObject(dependencyKey, subschema.properties as GenericObjectType);\n    const dependentSchema = { ...subschema, properties: dependentSubschema };\n    const schemas = retrieveSchemaInternal<T, S, F>(\n      validator,\n      dependentSchema,\n      rootSchema,\n      formData,\n      expandAllBranches,\n      recurseList\n    );\n    return schemas.map((s) => mergeSchemas(schema, s) as S);\n  });\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}