{"ast":null,"code":"import get from 'lodash/get';\nimport has from 'lodash/has';\nimport { PROPERTIES_KEY, REF_KEY } from '../constants';\nimport retrieveSchema from './retrieveSchema';\nconst NO_VALUE = Symbol('no Value');\n/** Sanitize the `data` associated with the `oldSchema` so it is considered appropriate for the `newSchema`. If the new\n * schema does not contain any properties, then `undefined` is returned to clear all the form data. Due to the nature\n * of schemas, this sanitization happens recursively for nested objects of data. Also, any properties in the old schema\n * that are non-existent in the new schema are set to `undefined`. The data sanitization process has the following flow:\n *\n * - If the new schema is an object that contains a `properties` object then:\n *   - Create a `removeOldSchemaData` object, setting each key in the `oldSchema.properties` having `data` to undefined\n *   - Create an empty `nestedData` object for use in the key filtering below:\n *   - Iterate over each key in the `newSchema.properties` as follows:\n *     - Get the `formValue` of the key from the `data`\n *     - Get the `oldKeySchema` and `newKeyedSchema` for the key, defaulting to `{}` when it doesn't exist\n *     - Retrieve the schema for any refs within each `oldKeySchema` and/or `newKeySchema`\n *     - Get the types of the old and new keyed schemas and if the old doesn't exist or the old & new are the same then:\n *       - If `removeOldSchemaData` has an entry for the key, delete it since the new schema has the same property\n *       - If type of the key in the new schema is `object`:\n *         - Store the value from the recursive `sanitizeDataForNewSchema` call in `nestedData[key]`\n *       - Otherwise, check for default or const values:\n *         - Get the old and new `default` values from the schema and check:\n *           - If the new `default` value does not match the form value:\n *             - If the old `default` value DOES match the form value, then:\n *               - Replace `removeOldSchemaData[key]` with the new `default`\n *               - Otherwise, if the new schema is `readOnly` then replace `removeOldSchemaData[key]` with undefined\n *         - Get the old and new `const` values from the schema and check:\n *           - If the new `const` value does not match the form value:\n *           - If the old `const` value DOES match the form value, then:\n *             - Replace `removeOldSchemaData[key]` with the new `const`\n *             - Otherwise, replace `removeOldSchemaData[key]` with undefined\n *   - Once all keys have been processed, return an object built as follows:\n *     - `{ ...removeOldSchemaData, ...nestedData, ...pick(data, keysToKeep) }`\n * - If the new and old schema types are array and the `data` is an array then:\n *   - If the type of the old and new schema `items` are a non-array objects:\n *     - Retrieve the schema for any refs within each `oldKeySchema.items` and/or `newKeySchema.items`\n *     - If the `type`s of both items are the same (or the old does not have a type):\n *       - If the type is \"object\", then:\n *         - For each element in the `data` recursively sanitize the data, stopping at `maxItems` if specified\n *       - Otherwise, just return the `data` removing any values after `maxItems` if it is set\n *   - If the type of the old and new schema `items` are booleans of the same value, return `data` as is\n * - Otherwise return `undefined`\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param rootSchema - The root JSON schema of the entire form\n * @param [newSchema] - The new schema for which the data is being sanitized\n * @param [oldSchema] - The old schema from which the data originated\n * @param [data={}] - The form data associated with the schema, defaulting to an empty object when undefined\n * @returns - The new form data, with all the fields uniquely associated with the old schema set\n *      to `undefined`. Will return `undefined` if the new schema is not an object containing properties.\n */\nexport default function sanitizeDataForNewSchema(validator, rootSchema, newSchema, oldSchema) {\n  let data = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n  // By default, we will clear the form data\n  let newFormData;\n  // If the new schema is of type object and that object contains a list of properties\n  if (has(newSchema, PROPERTIES_KEY)) {\n    // Create an object containing root-level keys in the old schema, setting each key to undefined to remove the data\n    const removeOldSchemaData = {};\n    if (has(oldSchema, PROPERTIES_KEY)) {\n      const properties = get(oldSchema, PROPERTIES_KEY, {});\n      Object.keys(properties).forEach(key => {\n        if (has(data, key)) {\n          removeOldSchemaData[key] = undefined;\n        }\n      });\n    }\n    const keys = Object.keys(get(newSchema, PROPERTIES_KEY, {}));\n    // Create a place to store nested data that will be a side-effect of the filter\n    const nestedData = {};\n    keys.forEach(key => {\n      const formValue = get(data, key);\n      let oldKeyedSchema = get(oldSchema, [PROPERTIES_KEY, key], {});\n      let newKeyedSchema = get(newSchema, [PROPERTIES_KEY, key], {});\n      // Resolve the refs if they exist\n      if (has(oldKeyedSchema, REF_KEY)) {\n        oldKeyedSchema = retrieveSchema(validator, oldKeyedSchema, rootSchema, formValue);\n      }\n      if (has(newKeyedSchema, REF_KEY)) {\n        newKeyedSchema = retrieveSchema(validator, newKeyedSchema, rootSchema, formValue);\n      }\n      // Now get types and see if they are the same\n      const oldSchemaTypeForKey = get(oldKeyedSchema, 'type');\n      const newSchemaTypeForKey = get(newKeyedSchema, 'type');\n      // Check if the old option has the same key with the same type\n      if (!oldSchemaTypeForKey || oldSchemaTypeForKey === newSchemaTypeForKey) {\n        if (has(removeOldSchemaData, key)) {\n          // SIDE-EFFECT: remove the undefined value for a key that has the same type between the old and new schemas\n          delete removeOldSchemaData[key];\n        }\n        // If it is an object, we'll recurse and store the resulting sanitized data for the key\n        if (newSchemaTypeForKey === 'object' || newSchemaTypeForKey === 'array' && Array.isArray(formValue)) {\n          // SIDE-EFFECT: process the new schema type of object recursively to save iterations\n          const itemData = sanitizeDataForNewSchema(validator, rootSchema, newKeyedSchema, oldKeyedSchema, formValue);\n          if (itemData !== undefined || newSchemaTypeForKey === 'array') {\n            // only put undefined values for the array type and not the object type\n            nestedData[key] = itemData;\n          }\n        } else {\n          // Ok, the non-object types match, let's make sure that a default or a const of a different value is replaced\n          // with the new default or const. This allows the case where two schemas differ that only by the default/const\n          // value to be properly selected\n          const newOptionDefault = get(newKeyedSchema, 'default', NO_VALUE);\n          const oldOptionDefault = get(oldKeyedSchema, 'default', NO_VALUE);\n          if (newOptionDefault !== NO_VALUE && newOptionDefault !== formValue) {\n            if (oldOptionDefault === formValue) {\n              // If the old default matches the formValue, we'll update the new value to match the new default\n              removeOldSchemaData[key] = newOptionDefault;\n            } else if (get(newKeyedSchema, 'readOnly') === true) {\n              // If the new schema has the default set to read-only, treat it like a const and remove the value\n              removeOldSchemaData[key] = undefined;\n            }\n          }\n          const newOptionConst = get(newKeyedSchema, 'const', NO_VALUE);\n          const oldOptionConst = get(oldKeyedSchema, 'const', NO_VALUE);\n          if (newOptionConst !== NO_VALUE && newOptionConst !== formValue) {\n            // Since this is a const, if the old value matches, replace the value with the new const otherwise clear it\n            removeOldSchemaData[key] = oldOptionConst === formValue ? newOptionConst : undefined;\n          }\n        }\n      }\n    });\n    newFormData = {\n      ...(typeof data == 'string' || Array.isArray(data) ? undefined : data),\n      ...removeOldSchemaData,\n      ...nestedData\n    };\n    // First apply removing the old schema data, then apply the nested data, then apply the old data keys to keep\n  } else if (get(oldSchema, 'type') === 'array' && get(newSchema, 'type') === 'array' && Array.isArray(data)) {\n    let oldSchemaItems = get(oldSchema, 'items');\n    let newSchemaItems = get(newSchema, 'items');\n    // If any of the array types `items` are arrays (remember arrays are objects) then we'll just drop the data\n    // Eventually, we may want to deal with when either of the `items` are arrays since those tuple validations\n    if (typeof oldSchemaItems === 'object' && typeof newSchemaItems === 'object' && !Array.isArray(oldSchemaItems) && !Array.isArray(newSchemaItems)) {\n      if (has(oldSchemaItems, REF_KEY)) {\n        oldSchemaItems = retrieveSchema(validator, oldSchemaItems, rootSchema, data);\n      }\n      if (has(newSchemaItems, REF_KEY)) {\n        newSchemaItems = retrieveSchema(validator, newSchemaItems, rootSchema, data);\n      }\n      // Now get types and see if they are the same\n      const oldSchemaType = get(oldSchemaItems, 'type');\n      const newSchemaType = get(newSchemaItems, 'type');\n      // Check if the old option has the same key with the same type\n      if (!oldSchemaType || oldSchemaType === newSchemaType) {\n        const maxItems = get(newSchema, 'maxItems', -1);\n        if (newSchemaType === 'object') {\n          newFormData = data.reduce((newValue, aValue) => {\n            const itemValue = sanitizeDataForNewSchema(validator, rootSchema, newSchemaItems, oldSchemaItems, aValue);\n            if (itemValue !== undefined && (maxItems < 0 || newValue.length < maxItems)) {\n              newValue.push(itemValue);\n            }\n            return newValue;\n          }, []);\n        } else {\n          newFormData = maxItems > 0 && data.length > maxItems ? data.slice(0, maxItems) : data;\n        }\n      }\n    } else if (typeof oldSchemaItems === 'boolean' && typeof newSchemaItems === 'boolean' && oldSchemaItems === newSchemaItems) {\n      // If they are both booleans and have the same value just return the data as is otherwise fall-thru to undefined\n      newFormData = data;\n    }\n    // Also probably want to deal with `prefixItems` as tuples with the latest 2020 draft\n  }\n  return newFormData;\n}","map":{"version":3,"names":["get","has","PROPERTIES_KEY","REF_KEY","retrieveSchema","NO_VALUE","Symbol","sanitizeDataForNewSchema","validator","rootSchema","newSchema","oldSchema","data","arguments","length","undefined","newFormData","removeOldSchemaData","properties","Object","keys","forEach","key","nestedData","formValue","oldKeyedSchema","newKeyedSchema","oldSchemaTypeForKey","newSchemaTypeForKey","Array","isArray","itemData","newOptionDefault","oldOptionDefault","newOptionConst","oldOptionConst","oldSchemaItems","newSchemaItems","oldSchemaType","newSchemaType","maxItems","reduce","newValue","aValue","itemValue","push","slice"],"sources":["D:\\Reactjs\\my-app\\node_modules\\@rjsf\\utils\\src\\schema\\sanitizeDataForNewSchema.ts"],"sourcesContent":["import get from 'lodash/get';\nimport has from 'lodash/has';\n\nimport { FormContextType, GenericObjectType, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\nimport { PROPERTIES_KEY, REF_KEY } from '../constants';\nimport retrieveSchema from './retrieveSchema';\n\nconst NO_VALUE = Symbol('no Value');\n\n/** Sanitize the `data` associated with the `oldSchema` so it is considered appropriate for the `newSchema`. If the new\n * schema does not contain any properties, then `undefined` is returned to clear all the form data. Due to the nature\n * of schemas, this sanitization happens recursively for nested objects of data. Also, any properties in the old schema\n * that are non-existent in the new schema are set to `undefined`. The data sanitization process has the following flow:\n *\n * - If the new schema is an object that contains a `properties` object then:\n *   - Create a `removeOldSchemaData` object, setting each key in the `oldSchema.properties` having `data` to undefined\n *   - Create an empty `nestedData` object for use in the key filtering below:\n *   - Iterate over each key in the `newSchema.properties` as follows:\n *     - Get the `formValue` of the key from the `data`\n *     - Get the `oldKeySchema` and `newKeyedSchema` for the key, defaulting to `{}` when it doesn't exist\n *     - Retrieve the schema for any refs within each `oldKeySchema` and/or `newKeySchema`\n *     - Get the types of the old and new keyed schemas and if the old doesn't exist or the old & new are the same then:\n *       - If `removeOldSchemaData` has an entry for the key, delete it since the new schema has the same property\n *       - If type of the key in the new schema is `object`:\n *         - Store the value from the recursive `sanitizeDataForNewSchema` call in `nestedData[key]`\n *       - Otherwise, check for default or const values:\n *         - Get the old and new `default` values from the schema and check:\n *           - If the new `default` value does not match the form value:\n *             - If the old `default` value DOES match the form value, then:\n *               - Replace `removeOldSchemaData[key]` with the new `default`\n *               - Otherwise, if the new schema is `readOnly` then replace `removeOldSchemaData[key]` with undefined\n *         - Get the old and new `const` values from the schema and check:\n *           - If the new `const` value does not match the form value:\n *           - If the old `const` value DOES match the form value, then:\n *             - Replace `removeOldSchemaData[key]` with the new `const`\n *             - Otherwise, replace `removeOldSchemaData[key]` with undefined\n *   - Once all keys have been processed, return an object built as follows:\n *     - `{ ...removeOldSchemaData, ...nestedData, ...pick(data, keysToKeep) }`\n * - If the new and old schema types are array and the `data` is an array then:\n *   - If the type of the old and new schema `items` are a non-array objects:\n *     - Retrieve the schema for any refs within each `oldKeySchema.items` and/or `newKeySchema.items`\n *     - If the `type`s of both items are the same (or the old does not have a type):\n *       - If the type is \"object\", then:\n *         - For each element in the `data` recursively sanitize the data, stopping at `maxItems` if specified\n *       - Otherwise, just return the `data` removing any values after `maxItems` if it is set\n *   - If the type of the old and new schema `items` are booleans of the same value, return `data` as is\n * - Otherwise return `undefined`\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param rootSchema - The root JSON schema of the entire form\n * @param [newSchema] - The new schema for which the data is being sanitized\n * @param [oldSchema] - The old schema from which the data originated\n * @param [data={}] - The form data associated with the schema, defaulting to an empty object when undefined\n * @returns - The new form data, with all the fields uniquely associated with the old schema set\n *      to `undefined`. Will return `undefined` if the new schema is not an object containing properties.\n */\nexport default function sanitizeDataForNewSchema<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(validator: ValidatorType<T, S, F>, rootSchema: S, newSchema?: S, oldSchema?: S, data: any = {}): T {\n  // By default, we will clear the form data\n  let newFormData;\n  // If the new schema is of type object and that object contains a list of properties\n  if (has(newSchema, PROPERTIES_KEY)) {\n    // Create an object containing root-level keys in the old schema, setting each key to undefined to remove the data\n    const removeOldSchemaData: GenericObjectType = {};\n    if (has(oldSchema, PROPERTIES_KEY)) {\n      const properties = get(oldSchema, PROPERTIES_KEY, {});\n      Object.keys(properties).forEach((key) => {\n        if (has(data, key)) {\n          removeOldSchemaData[key] = undefined;\n        }\n      });\n    }\n    const keys: string[] = Object.keys(get(newSchema, PROPERTIES_KEY, {}));\n    // Create a place to store nested data that will be a side-effect of the filter\n    const nestedData: GenericObjectType = {};\n    keys.forEach((key) => {\n      const formValue = get(data, key);\n      let oldKeyedSchema: S = get(oldSchema, [PROPERTIES_KEY, key], {});\n      let newKeyedSchema: S = get(newSchema, [PROPERTIES_KEY, key], {});\n      // Resolve the refs if they exist\n      if (has(oldKeyedSchema, REF_KEY)) {\n        oldKeyedSchema = retrieveSchema<T, S, F>(validator, oldKeyedSchema, rootSchema, formValue);\n      }\n      if (has(newKeyedSchema, REF_KEY)) {\n        newKeyedSchema = retrieveSchema<T, S, F>(validator, newKeyedSchema, rootSchema, formValue);\n      }\n      // Now get types and see if they are the same\n      const oldSchemaTypeForKey = get(oldKeyedSchema, 'type');\n      const newSchemaTypeForKey = get(newKeyedSchema, 'type');\n      // Check if the old option has the same key with the same type\n      if (!oldSchemaTypeForKey || oldSchemaTypeForKey === newSchemaTypeForKey) {\n        if (has(removeOldSchemaData, key)) {\n          // SIDE-EFFECT: remove the undefined value for a key that has the same type between the old and new schemas\n          delete removeOldSchemaData[key];\n        }\n        // If it is an object, we'll recurse and store the resulting sanitized data for the key\n        if (newSchemaTypeForKey === 'object' || (newSchemaTypeForKey === 'array' && Array.isArray(formValue))) {\n          // SIDE-EFFECT: process the new schema type of object recursively to save iterations\n          const itemData = sanitizeDataForNewSchema<T, S, F>(\n            validator,\n            rootSchema,\n            newKeyedSchema,\n            oldKeyedSchema,\n            formValue\n          );\n          if (itemData !== undefined || newSchemaTypeForKey === 'array') {\n            // only put undefined values for the array type and not the object type\n            nestedData[key] = itemData;\n          }\n        } else {\n          // Ok, the non-object types match, let's make sure that a default or a const of a different value is replaced\n          // with the new default or const. This allows the case where two schemas differ that only by the default/const\n          // value to be properly selected\n          const newOptionDefault = get(newKeyedSchema, 'default', NO_VALUE);\n          const oldOptionDefault = get(oldKeyedSchema, 'default', NO_VALUE);\n          if (newOptionDefault !== NO_VALUE && newOptionDefault !== formValue) {\n            if (oldOptionDefault === formValue) {\n              // If the old default matches the formValue, we'll update the new value to match the new default\n              removeOldSchemaData[key] = newOptionDefault;\n            } else if (get(newKeyedSchema, 'readOnly') === true) {\n              // If the new schema has the default set to read-only, treat it like a const and remove the value\n              removeOldSchemaData[key] = undefined;\n            }\n          }\n\n          const newOptionConst = get(newKeyedSchema, 'const', NO_VALUE);\n          const oldOptionConst = get(oldKeyedSchema, 'const', NO_VALUE);\n          if (newOptionConst !== NO_VALUE && newOptionConst !== formValue) {\n            // Since this is a const, if the old value matches, replace the value with the new const otherwise clear it\n            removeOldSchemaData[key] = oldOptionConst === formValue ? newOptionConst : undefined;\n          }\n        }\n      }\n    });\n\n    newFormData = {\n      ...(typeof data == 'string' || Array.isArray(data) ? undefined : data),\n      ...removeOldSchemaData,\n      ...nestedData,\n    };\n    // First apply removing the old schema data, then apply the nested data, then apply the old data keys to keep\n  } else if (get(oldSchema, 'type') === 'array' && get(newSchema, 'type') === 'array' && Array.isArray(data)) {\n    let oldSchemaItems = get(oldSchema, 'items');\n    let newSchemaItems = get(newSchema, 'items');\n    // If any of the array types `items` are arrays (remember arrays are objects) then we'll just drop the data\n    // Eventually, we may want to deal with when either of the `items` are arrays since those tuple validations\n    if (\n      typeof oldSchemaItems === 'object' &&\n      typeof newSchemaItems === 'object' &&\n      !Array.isArray(oldSchemaItems) &&\n      !Array.isArray(newSchemaItems)\n    ) {\n      if (has(oldSchemaItems, REF_KEY)) {\n        oldSchemaItems = retrieveSchema<T, S, F>(validator, oldSchemaItems as S, rootSchema, data as T);\n      }\n      if (has(newSchemaItems, REF_KEY)) {\n        newSchemaItems = retrieveSchema<T, S, F>(validator, newSchemaItems as S, rootSchema, data as T);\n      }\n      // Now get types and see if they are the same\n      const oldSchemaType = get(oldSchemaItems, 'type');\n      const newSchemaType = get(newSchemaItems, 'type');\n      // Check if the old option has the same key with the same type\n      if (!oldSchemaType || oldSchemaType === newSchemaType) {\n        const maxItems = get(newSchema, 'maxItems', -1);\n        if (newSchemaType === 'object') {\n          newFormData = data.reduce((newValue, aValue) => {\n            const itemValue = sanitizeDataForNewSchema<T, S, F>(\n              validator,\n              rootSchema,\n              newSchemaItems as S,\n              oldSchemaItems as S,\n              aValue\n            );\n            if (itemValue !== undefined && (maxItems < 0 || newValue.length < maxItems)) {\n              newValue.push(itemValue);\n            }\n            return newValue;\n          }, []);\n        } else {\n          newFormData = maxItems > 0 && data.length > maxItems ? data.slice(0, maxItems) : data;\n        }\n      }\n    } else if (\n      typeof oldSchemaItems === 'boolean' &&\n      typeof newSchemaItems === 'boolean' &&\n      oldSchemaItems === newSchemaItems\n    ) {\n      // If they are both booleans and have the same value just return the data as is otherwise fall-thru to undefined\n      newFormData = data;\n    }\n    // Also probably want to deal with `prefixItems` as tuples with the latest 2020 draft\n  }\n  return newFormData as T;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}