{"ast":null,"code":"import { jsx as _jsx } from \"react/jsx-runtime\";\nimport { Component } from 'react';\nimport { getTemplate, getWidget, getUiOptions, isFixedItems, allowAdditionalItems, isCustomWidget, optionsList, TranslatableString, ITEMS_KEY } from '@rjsf/utils';\nimport cloneDeep from 'lodash/cloneDeep';\nimport get from 'lodash/get';\nimport isObject from 'lodash/isObject';\nimport set from 'lodash/set';\nimport { nanoid } from 'nanoid';\n/** Used to generate a unique ID for an element in a row */\nfunction generateRowId() {\n  return nanoid();\n}\n/** Converts the `formData` into `KeyedFormDataType` data, using the `generateRowId()` function to create the key\n *\n * @param formData - The data for the form\n * @returns - The `formData` converted into a `KeyedFormDataType` element\n */\nfunction generateKeyedFormData(formData) {\n  return !Array.isArray(formData) ? [] : formData.map(item => {\n    return {\n      key: generateRowId(),\n      item\n    };\n  });\n}\n/** Converts `KeyedFormDataType` data into the inner `formData`\n *\n * @param keyedFormData - The `KeyedFormDataType` to be converted\n * @returns - The inner `formData` item(s) in the `keyedFormData`\n */\nfunction keyedToPlainFormData(keyedFormData) {\n  if (Array.isArray(keyedFormData)) {\n    return keyedFormData.map(keyedItem => keyedItem.item);\n  }\n  return [];\n}\n/** The `ArrayField` component is used to render a field in the schema that is of type `array`. It supports both normal\n * and fixed array, allowing user to add and remove elements from the array data.\n */\nclass ArrayField extends Component {\n  /** Constructs an `ArrayField` from the `props`, generating the initial keyed data from the `formData`\n   *\n   * @param props - The `FieldProps` for this template\n   */\n  constructor(props) {\n    super(props);\n    /** Returns the default form information for an item based on the schema for that item. Deals with the possibility\n     * that the schema is fixed and allows additional items.\n     */\n    this._getNewFormDataRow = () => {\n      const {\n        schema,\n        registry\n      } = this.props;\n      const {\n        schemaUtils\n      } = registry;\n      let itemSchema = schema.items;\n      if (isFixedItems(schema) && allowAdditionalItems(schema)) {\n        itemSchema = schema.additionalItems;\n      }\n      // Cast this as a T to work around schema utils being for T[] caused by the FieldProps<T[], S, F> call on the class\n      return schemaUtils.getDefaultFormState(itemSchema);\n    };\n    /** Callback handler for when the user clicks on the add button. Creates a new row of keyed form data at the end of\n     * the list, adding it into the state, and then returning `onChange()` with the plain form data converted from the\n     * keyed data\n     *\n     * @param event - The event for the click\n     */\n    this.onAddClick = event => {\n      this._handleAddClick(event);\n    };\n    /** Callback handler for when the user clicks on the add button on an existing array element. Creates a new row of\n     * keyed form data inserted at the `index`, adding it into the state, and then returning `onChange()` with the plain\n     * form data converted from the keyed data\n     *\n     * @param index - The index at which the add button is clicked\n     */\n    this.onAddIndexClick = index => {\n      return event => {\n        this._handleAddClick(event, index);\n      };\n    };\n    /** Callback handler for when the user clicks on the copy button on an existing array element. Clones the row of\n     * keyed form data at the `index` into the next position in the state, and then returning `onChange()` with the plain\n     * form data converted from the keyed data\n     *\n     * @param index - The index at which the copy button is clicked\n     */\n    this.onCopyIndexClick = index => {\n      return event => {\n        if (event) {\n          event.preventDefault();\n        }\n        const {\n          onChange,\n          errorSchema\n        } = this.props;\n        const {\n          keyedFormData\n        } = this.state;\n        // refs #195: revalidate to ensure properly reindexing errors\n        let newErrorSchema;\n        if (errorSchema) {\n          newErrorSchema = {};\n          for (const idx in errorSchema) {\n            const i = parseInt(idx);\n            if (i <= index) {\n              set(newErrorSchema, [i], errorSchema[idx]);\n            } else if (i > index) {\n              set(newErrorSchema, [i + 1], errorSchema[idx]);\n            }\n          }\n        }\n        const newKeyedFormDataRow = {\n          key: generateRowId(),\n          item: cloneDeep(keyedFormData[index].item)\n        };\n        const newKeyedFormData = [...keyedFormData];\n        if (index !== undefined) {\n          newKeyedFormData.splice(index + 1, 0, newKeyedFormDataRow);\n        } else {\n          newKeyedFormData.push(newKeyedFormDataRow);\n        }\n        this.setState({\n          keyedFormData: newKeyedFormData,\n          updatedKeyedFormData: true\n        }, () => onChange(keyedToPlainFormData(newKeyedFormData), newErrorSchema));\n      };\n    };\n    /** Callback handler for when the user clicks on the remove button on an existing array element. Removes the row of\n     * keyed form data at the `index` in the state, and then returning `onChange()` with the plain form data converted\n     * from the keyed data\n     *\n     * @param index - The index at which the remove button is clicked\n     */\n    this.onDropIndexClick = index => {\n      return event => {\n        if (event) {\n          event.preventDefault();\n        }\n        const {\n          onChange,\n          errorSchema\n        } = this.props;\n        const {\n          keyedFormData\n        } = this.state;\n        // refs #195: revalidate to ensure properly reindexing errors\n        let newErrorSchema;\n        if (errorSchema) {\n          newErrorSchema = {};\n          for (const idx in errorSchema) {\n            const i = parseInt(idx);\n            if (i < index) {\n              set(newErrorSchema, [i], errorSchema[idx]);\n            } else if (i > index) {\n              set(newErrorSchema, [i - 1], errorSchema[idx]);\n            }\n          }\n        }\n        const newKeyedFormData = keyedFormData.filter((_, i) => i !== index);\n        this.setState({\n          keyedFormData: newKeyedFormData,\n          updatedKeyedFormData: true\n        }, () => onChange(keyedToPlainFormData(newKeyedFormData), newErrorSchema));\n      };\n    };\n    /** Callback handler for when the user clicks on one of the move item buttons on an existing array element. Moves the\n     * row of keyed form data at the `index` to the `newIndex` in the state, and then returning `onChange()` with the\n     * plain form data converted from the keyed data\n     *\n     * @param index - The index of the item to move\n     * @param newIndex - The index to where the item is to be moved\n     */\n    this.onReorderClick = (index, newIndex) => {\n      return event => {\n        if (event) {\n          event.preventDefault();\n          event.currentTarget.blur();\n        }\n        const {\n          onChange,\n          errorSchema\n        } = this.props;\n        let newErrorSchema;\n        if (errorSchema) {\n          newErrorSchema = {};\n          for (const idx in errorSchema) {\n            const i = parseInt(idx);\n            if (i == index) {\n              set(newErrorSchema, [newIndex], errorSchema[index]);\n            } else if (i == newIndex) {\n              set(newErrorSchema, [index], errorSchema[newIndex]);\n            } else {\n              set(newErrorSchema, [idx], errorSchema[i]);\n            }\n          }\n        }\n        const {\n          keyedFormData\n        } = this.state;\n        function reOrderArray() {\n          // Copy item\n          const _newKeyedFormData = keyedFormData.slice();\n          // Moves item from index to newIndex\n          _newKeyedFormData.splice(index, 1);\n          _newKeyedFormData.splice(newIndex, 0, keyedFormData[index]);\n          return _newKeyedFormData;\n        }\n        const newKeyedFormData = reOrderArray();\n        this.setState({\n          keyedFormData: newKeyedFormData\n        }, () => onChange(keyedToPlainFormData(newKeyedFormData), newErrorSchema));\n      };\n    };\n    /** Callback handler used to deal with changing the value of the data in the array at the `index`. Calls the\n     * `onChange` callback with the updated form data\n     *\n     * @param index - The index of the item being changed\n     */\n    this.onChangeForIndex = index => {\n      return (value, newErrorSchema, id) => {\n        const {\n          formData,\n          onChange,\n          errorSchema\n        } = this.props;\n        const arrayData = Array.isArray(formData) ? formData : [];\n        const newFormData = arrayData.map((item, i) => {\n          // We need to treat undefined items as nulls to have validation.\n          // See https://github.com/tdegrunt/jsonschema/issues/206\n          const jsonValue = typeof value === 'undefined' ? null : value;\n          return index === i ? jsonValue : item;\n        });\n        onChange(newFormData, errorSchema && errorSchema && {\n          ...errorSchema,\n          [index]: newErrorSchema\n        }, id);\n      };\n    };\n    /** Callback handler used to change the value for a checkbox */\n    this.onSelectChange = value => {\n      const {\n        onChange,\n        idSchema\n      } = this.props;\n      onChange(value, undefined, idSchema && idSchema.$id);\n    };\n    const {\n      formData = []\n    } = props;\n    const keyedFormData = generateKeyedFormData(formData);\n    this.state = {\n      keyedFormData,\n      updatedKeyedFormData: false\n    };\n  }\n  /** React lifecycle method that is called when the props are about to change allowing the state to be updated. It\n   * regenerates the keyed form data and returns it\n   *\n   * @param nextProps - The next set of props data\n   * @param prevState - The previous set of state data\n   */\n  static getDerivedStateFromProps(nextProps, prevState) {\n    // Don't call getDerivedStateFromProps if keyed formdata was just updated.\n    if (prevState.updatedKeyedFormData) {\n      return {\n        updatedKeyedFormData: false\n      };\n    }\n    const nextFormData = Array.isArray(nextProps.formData) ? nextProps.formData : [];\n    const previousKeyedFormData = prevState.keyedFormData || [];\n    const newKeyedFormData = nextFormData.length === previousKeyedFormData.length ? previousKeyedFormData.map((previousKeyedFormDatum, index) => {\n      return {\n        key: previousKeyedFormDatum.key,\n        item: nextFormData[index]\n      };\n    }) : generateKeyedFormData(nextFormData);\n    return {\n      keyedFormData: newKeyedFormData\n    };\n  }\n  /** Returns the appropriate title for an item by getting first the title from the schema.items, then falling back to\n   * the description from the schema.items, and finally the string \"Item\"\n   */\n  get itemTitle() {\n    const {\n      schema,\n      registry\n    } = this.props;\n    const {\n      translateString\n    } = registry;\n    return get(schema, [ITEMS_KEY, 'title'], get(schema, [ITEMS_KEY, 'description'], translateString(TranslatableString.ArrayItemTitle)));\n  }\n  /** Determines whether the item described in the schema is always required, which is determined by whether any item\n   * may be null.\n   *\n   * @param itemSchema - The schema for the item\n   * @return - True if the item schema type does not contain the \"null\" type\n   */\n  isItemRequired(itemSchema) {\n    if (Array.isArray(itemSchema.type)) {\n      // While we don't yet support composite/nullable jsonschema types, it's\n      // future-proof to check for requirement against these.\n      return !itemSchema.type.includes('null');\n    }\n    // All non-null array item types are inherently required by design\n    return itemSchema.type !== 'null';\n  }\n  /** Determines whether more items can be added to the array. If the uiSchema indicates the array doesn't allow adding\n   * then false is returned. Otherwise, if the schema indicates that there are a maximum number of items and the\n   * `formData` matches that value, then false is returned, otherwise true is returned.\n   *\n   * @param formItems - The list of items in the form\n   * @returns - True if the item is addable otherwise false\n   */\n  canAddItem(formItems) {\n    const {\n      schema,\n      uiSchema,\n      registry\n    } = this.props;\n    let {\n      addable\n    } = getUiOptions(uiSchema, registry.globalUiOptions);\n    if (addable !== false) {\n      // if ui:options.addable was not explicitly set to false, we can add\n      // another item if we have not exceeded maxItems yet\n      if (schema.maxItems !== undefined) {\n        addable = formItems.length < schema.maxItems;\n      } else {\n        addable = true;\n      }\n    }\n    return addable;\n  }\n  /** Callback handler for when the user clicks on the add or add at index buttons. Creates a new row of keyed form data\n   * either at the end of the list (when index is not specified) or inserted at the `index` when it is, adding it into\n   * the state, and then returning `onChange()` with the plain form data converted from the keyed data\n   *\n   * @param event - The event for the click\n   * @param [index] - The optional index at which to add the new data\n   */\n  _handleAddClick(event, index) {\n    if (event) {\n      event.preventDefault();\n    }\n    const {\n      onChange,\n      errorSchema\n    } = this.props;\n    const {\n      keyedFormData\n    } = this.state;\n    // refs #195: revalidate to ensure properly reindexing errors\n    let newErrorSchema;\n    if (errorSchema) {\n      newErrorSchema = {};\n      for (const idx in errorSchema) {\n        const i = parseInt(idx);\n        if (index === undefined || i < index) {\n          set(newErrorSchema, [i], errorSchema[idx]);\n        } else if (i >= index) {\n          set(newErrorSchema, [i + 1], errorSchema[idx]);\n        }\n      }\n    }\n    const newKeyedFormDataRow = {\n      key: generateRowId(),\n      item: this._getNewFormDataRow()\n    };\n    const newKeyedFormData = [...keyedFormData];\n    if (index !== undefined) {\n      newKeyedFormData.splice(index, 0, newKeyedFormDataRow);\n    } else {\n      newKeyedFormData.push(newKeyedFormDataRow);\n    }\n    this.setState({\n      keyedFormData: newKeyedFormData,\n      updatedKeyedFormData: true\n    }, () => onChange(keyedToPlainFormData(newKeyedFormData), newErrorSchema));\n  }\n  /** Renders the `ArrayField` depending on the specific needs of the schema and uischema elements\n   */\n  render() {\n    const {\n      schema,\n      uiSchema,\n      idSchema,\n      registry\n    } = this.props;\n    const {\n      schemaUtils,\n      translateString\n    } = registry;\n    if (!(ITEMS_KEY in schema)) {\n      const uiOptions = getUiOptions(uiSchema);\n      const UnsupportedFieldTemplate = getTemplate('UnsupportedFieldTemplate', registry, uiOptions);\n      return _jsx(UnsupportedFieldTemplate, {\n        schema: schema,\n        idSchema: idSchema,\n        reason: translateString(TranslatableString.MissingItems),\n        registry: registry\n      });\n    }\n    if (schemaUtils.isMultiSelect(schema)) {\n      // If array has enum or uniqueItems set to true, call renderMultiSelect() to render the default multiselect widget or a custom widget, if specified.\n      return this.renderMultiSelect();\n    }\n    if (isCustomWidget(uiSchema)) {\n      return this.renderCustomWidget();\n    }\n    if (isFixedItems(schema)) {\n      return this.renderFixedArray();\n    }\n    if (schemaUtils.isFilesArray(schema, uiSchema)) {\n      return this.renderFiles();\n    }\n    return this.renderNormalArray();\n  }\n  /** Renders a normal array without any limitations of length\n   */\n  renderNormalArray() {\n    const {\n      schema,\n      uiSchema = {},\n      errorSchema,\n      idSchema,\n      name,\n      disabled = false,\n      readonly = false,\n      autofocus = false,\n      required = false,\n      registry,\n      onBlur,\n      onFocus,\n      idPrefix,\n      idSeparator = '_',\n      rawErrors\n    } = this.props;\n    const {\n      keyedFormData\n    } = this.state;\n    const title = schema.title === undefined ? name : schema.title;\n    const {\n      schemaUtils,\n      formContext\n    } = registry;\n    const uiOptions = getUiOptions(uiSchema);\n    const _schemaItems = isObject(schema.items) ? schema.items : {};\n    const itemsSchema = schemaUtils.retrieveSchema(_schemaItems);\n    const formData = keyedToPlainFormData(this.state.keyedFormData);\n    const canAdd = this.canAddItem(formData);\n    const arrayProps = {\n      canAdd,\n      items: keyedFormData.map((keyedItem, index) => {\n        const {\n          key,\n          item\n        } = keyedItem;\n        // While we are actually dealing with a single item of type T, the types require a T[], so cast\n        const itemCast = item;\n        const itemSchema = schemaUtils.retrieveSchema(_schemaItems, itemCast);\n        const itemErrorSchema = errorSchema ? errorSchema[index] : undefined;\n        const itemIdPrefix = idSchema.$id + idSeparator + index;\n        const itemIdSchema = schemaUtils.toIdSchema(itemSchema, itemIdPrefix, itemCast, idPrefix, idSeparator);\n        return this.renderArrayFieldItem({\n          key,\n          index,\n          name: name && `${name}-${index}`,\n          canAdd,\n          canMoveUp: index > 0,\n          canMoveDown: index < formData.length - 1,\n          itemSchema,\n          itemIdSchema,\n          itemErrorSchema,\n          itemData: itemCast,\n          itemUiSchema: uiSchema.items,\n          autofocus: autofocus && index === 0,\n          onBlur,\n          onFocus,\n          rawErrors,\n          totalItems: keyedFormData.length\n        });\n      }),\n      className: `field field-array field-array-of-${itemsSchema.type}`,\n      disabled,\n      idSchema,\n      uiSchema,\n      onAddClick: this.onAddClick,\n      readonly,\n      required,\n      schema,\n      title,\n      formContext,\n      formData,\n      rawErrors,\n      registry\n    };\n    const Template = getTemplate('ArrayFieldTemplate', registry, uiOptions);\n    return _jsx(Template, {\n      ...arrayProps\n    });\n  }\n  /** Renders an array using the custom widget provided by the user in the `uiSchema`\n   */\n  renderCustomWidget() {\n    var _a;\n    const {\n      schema,\n      idSchema,\n      uiSchema,\n      disabled = false,\n      readonly = false,\n      autofocus = false,\n      required = false,\n      hideError,\n      placeholder,\n      onBlur,\n      onFocus,\n      formData: items = [],\n      registry,\n      rawErrors,\n      name\n    } = this.props;\n    const {\n      widgets,\n      formContext,\n      globalUiOptions,\n      schemaUtils\n    } = registry;\n    const {\n      widget,\n      title: uiTitle,\n      ...options\n    } = getUiOptions(uiSchema, globalUiOptions);\n    const Widget = getWidget(schema, widget, widgets);\n    const label = (_a = uiTitle !== null && uiTitle !== void 0 ? uiTitle : schema.title) !== null && _a !== void 0 ? _a : name;\n    const displayLabel = schemaUtils.getDisplayLabel(schema, uiSchema, globalUiOptions);\n    return _jsx(Widget, {\n      id: idSchema.$id,\n      name: name,\n      multiple: true,\n      onChange: this.onSelectChange,\n      onBlur: onBlur,\n      onFocus: onFocus,\n      options: options,\n      schema: schema,\n      uiSchema: uiSchema,\n      registry: registry,\n      value: items,\n      disabled: disabled,\n      readonly: readonly,\n      hideError: hideError,\n      required: required,\n      label: label,\n      hideLabel: !displayLabel,\n      placeholder: placeholder,\n      formContext: formContext,\n      autofocus: autofocus,\n      rawErrors: rawErrors\n    });\n  }\n  /** Renders an array as a set of checkboxes\n   */\n  renderMultiSelect() {\n    var _a;\n    const {\n      schema,\n      idSchema,\n      uiSchema,\n      formData: items = [],\n      disabled = false,\n      readonly = false,\n      autofocus = false,\n      required = false,\n      placeholder,\n      onBlur,\n      onFocus,\n      registry,\n      rawErrors,\n      name\n    } = this.props;\n    const {\n      widgets,\n      schemaUtils,\n      formContext,\n      globalUiOptions\n    } = registry;\n    const itemsSchema = schemaUtils.retrieveSchema(schema.items, items);\n    const enumOptions = optionsList(itemsSchema);\n    const {\n      widget = 'select',\n      title: uiTitle,\n      ...options\n    } = getUiOptions(uiSchema, globalUiOptions);\n    const Widget = getWidget(schema, widget, widgets);\n    const label = (_a = uiTitle !== null && uiTitle !== void 0 ? uiTitle : schema.title) !== null && _a !== void 0 ? _a : name;\n    const displayLabel = schemaUtils.getDisplayLabel(schema, uiSchema, globalUiOptions);\n    return _jsx(Widget, {\n      id: idSchema.$id,\n      name: name,\n      multiple: true,\n      onChange: this.onSelectChange,\n      onBlur: onBlur,\n      onFocus: onFocus,\n      options: {\n        ...options,\n        enumOptions\n      },\n      schema: schema,\n      uiSchema: uiSchema,\n      registry: registry,\n      value: items,\n      disabled: disabled,\n      readonly: readonly,\n      required: required,\n      label: label,\n      hideLabel: !displayLabel,\n      placeholder: placeholder,\n      formContext: formContext,\n      autofocus: autofocus,\n      rawErrors: rawErrors\n    });\n  }\n  /** Renders an array of files using the `FileWidget`\n   */\n  renderFiles() {\n    var _a;\n    const {\n      schema,\n      uiSchema,\n      idSchema,\n      name,\n      disabled = false,\n      readonly = false,\n      autofocus = false,\n      required = false,\n      onBlur,\n      onFocus,\n      registry,\n      formData: items = [],\n      rawErrors\n    } = this.props;\n    const {\n      widgets,\n      formContext,\n      globalUiOptions,\n      schemaUtils\n    } = registry;\n    const {\n      widget = 'files',\n      title: uiTitle,\n      ...options\n    } = getUiOptions(uiSchema, globalUiOptions);\n    const Widget = getWidget(schema, widget, widgets);\n    const label = (_a = uiTitle !== null && uiTitle !== void 0 ? uiTitle : schema.title) !== null && _a !== void 0 ? _a : name;\n    const displayLabel = schemaUtils.getDisplayLabel(schema, uiSchema, globalUiOptions);\n    return _jsx(Widget, {\n      options: options,\n      id: idSchema.$id,\n      name: name,\n      multiple: true,\n      onChange: this.onSelectChange,\n      onBlur: onBlur,\n      onFocus: onFocus,\n      schema: schema,\n      uiSchema: uiSchema,\n      value: items,\n      disabled: disabled,\n      readonly: readonly,\n      required: required,\n      registry: registry,\n      formContext: formContext,\n      autofocus: autofocus,\n      rawErrors: rawErrors,\n      label: label,\n      hideLabel: !displayLabel\n    });\n  }\n  /** Renders an array that has a maximum limit of items\n   */\n  renderFixedArray() {\n    const {\n      schema,\n      uiSchema = {},\n      formData = [],\n      errorSchema,\n      idPrefix,\n      idSeparator = '_',\n      idSchema,\n      name,\n      disabled = false,\n      readonly = false,\n      autofocus = false,\n      required = false,\n      registry,\n      onBlur,\n      onFocus,\n      rawErrors\n    } = this.props;\n    const {\n      keyedFormData\n    } = this.state;\n    let {\n      formData: items = []\n    } = this.props;\n    const title = schema.title || name;\n    const uiOptions = getUiOptions(uiSchema);\n    const {\n      schemaUtils,\n      formContext\n    } = registry;\n    const _schemaItems = isObject(schema.items) ? schema.items : [];\n    const itemSchemas = _schemaItems.map((item, index) => schemaUtils.retrieveSchema(item, formData[index]));\n    const additionalSchema = isObject(schema.additionalItems) ? schemaUtils.retrieveSchema(schema.additionalItems, formData) : null;\n    if (!items || items.length < itemSchemas.length) {\n      // to make sure at least all fixed items are generated\n      items = items || [];\n      items = items.concat(new Array(itemSchemas.length - items.length));\n    }\n    // These are the props passed into the render function\n    const canAdd = this.canAddItem(items) && !!additionalSchema;\n    const arrayProps = {\n      canAdd,\n      className: 'field field-array field-array-fixed-items',\n      disabled,\n      idSchema,\n      formData,\n      items: keyedFormData.map((keyedItem, index) => {\n        const {\n          key,\n          item\n        } = keyedItem;\n        // While we are actually dealing with a single item of type T, the types require a T[], so cast\n        const itemCast = item;\n        const additional = index >= itemSchemas.length;\n        const itemSchema = (additional && isObject(schema.additionalItems) ? schemaUtils.retrieveSchema(schema.additionalItems, itemCast) : itemSchemas[index]) || {};\n        const itemIdPrefix = idSchema.$id + idSeparator + index;\n        const itemIdSchema = schemaUtils.toIdSchema(itemSchema, itemIdPrefix, itemCast, idPrefix, idSeparator);\n        const itemUiSchema = additional ? uiSchema.additionalItems || {} : Array.isArray(uiSchema.items) ? uiSchema.items[index] : uiSchema.items || {};\n        const itemErrorSchema = errorSchema ? errorSchema[index] : undefined;\n        return this.renderArrayFieldItem({\n          key,\n          index,\n          name: name && `${name}-${index}`,\n          canAdd,\n          canRemove: additional,\n          canMoveUp: index >= itemSchemas.length + 1,\n          canMoveDown: additional && index < items.length - 1,\n          itemSchema,\n          itemData: itemCast,\n          itemUiSchema,\n          itemIdSchema,\n          itemErrorSchema,\n          autofocus: autofocus && index === 0,\n          onBlur,\n          onFocus,\n          rawErrors,\n          totalItems: keyedFormData.length\n        });\n      }),\n      onAddClick: this.onAddClick,\n      readonly,\n      required,\n      registry,\n      schema,\n      uiSchema,\n      title,\n      formContext,\n      rawErrors\n    };\n    const Template = getTemplate('ArrayFieldTemplate', registry, uiOptions);\n    return _jsx(Template, {\n      ...arrayProps\n    });\n  }\n  /** Renders the individual array item using a `SchemaField` along with the additional properties required to be send\n   * back to the `ArrayFieldItemTemplate`.\n   *\n   * @param props - The props for the individual array item to be rendered\n   */\n  renderArrayFieldItem(props) {\n    const {\n      key,\n      index,\n      name,\n      canAdd,\n      canRemove = true,\n      canMoveUp,\n      canMoveDown,\n      itemSchema,\n      itemData,\n      itemUiSchema,\n      itemIdSchema,\n      itemErrorSchema,\n      autofocus,\n      onBlur,\n      onFocus,\n      rawErrors,\n      totalItems\n    } = props;\n    const {\n      disabled,\n      hideError,\n      idPrefix,\n      idSeparator,\n      readonly,\n      uiSchema,\n      registry,\n      formContext\n    } = this.props;\n    const {\n      fields: {\n        ArraySchemaField,\n        SchemaField\n      },\n      globalUiOptions\n    } = registry;\n    const ItemSchemaField = ArraySchemaField || SchemaField;\n    const {\n      orderable = true,\n      removable = true,\n      copyable = false\n    } = getUiOptions(uiSchema, globalUiOptions);\n    const has = {\n      moveUp: orderable && canMoveUp,\n      moveDown: orderable && canMoveDown,\n      copy: copyable && canAdd,\n      remove: removable && canRemove,\n      toolbar: false\n    };\n    has.toolbar = Object.keys(has).some(key => has[key]);\n    return {\n      children: _jsx(ItemSchemaField, {\n        name: name,\n        index: index,\n        schema: itemSchema,\n        uiSchema: itemUiSchema,\n        formData: itemData,\n        formContext: formContext,\n        errorSchema: itemErrorSchema,\n        idPrefix: idPrefix,\n        idSeparator: idSeparator,\n        idSchema: itemIdSchema,\n        required: this.isItemRequired(itemSchema),\n        onChange: this.onChangeForIndex(index),\n        onBlur: onBlur,\n        onFocus: onFocus,\n        registry: registry,\n        disabled: disabled,\n        readonly: readonly,\n        hideError: hideError,\n        autofocus: autofocus,\n        rawErrors: rawErrors\n      }),\n      className: 'array-item',\n      disabled,\n      canAdd,\n      hasCopy: has.copy,\n      hasToolbar: has.toolbar,\n      hasMoveUp: has.moveUp,\n      hasMoveDown: has.moveDown,\n      hasRemove: has.remove,\n      index,\n      totalItems,\n      key,\n      onAddIndexClick: this.onAddIndexClick,\n      onCopyIndexClick: this.onCopyIndexClick,\n      onDropIndexClick: this.onDropIndexClick,\n      onReorderClick: this.onReorderClick,\n      readonly,\n      registry,\n      schema: itemSchema,\n      uiSchema: itemUiSchema\n    };\n  }\n}\n/** `ArrayField` is `React.ComponentType<FieldProps<T[], S, F>>` (necessarily) but the `registry` requires things to be a\n * `Field` which is defined as `React.ComponentType<FieldProps<T, S, F>>`, so cast it to make `registry` happy.\n */\nexport default ArrayField;","map":{"version":3,"names":["Component","getTemplate","getWidget","getUiOptions","isFixedItems","allowAdditionalItems","isCustomWidget","optionsList","TranslatableString","ITEMS_KEY","cloneDeep","get","isObject","set","nanoid","generateRowId","generateKeyedFormData","formData","Array","isArray","map","item","key","keyedToPlainFormData","keyedFormData","keyedItem","ArrayField","constructor","props","_getNewFormDataRow","schema","registry","schemaUtils","itemSchema","items","additionalItems","getDefaultFormState","onAddClick","event","_handleAddClick","onAddIndexClick","index","onCopyIndexClick","preventDefault","onChange","errorSchema","state","newErrorSchema","idx","i","parseInt","newKeyedFormDataRow","newKeyedFormData","undefined","splice","push","setState","updatedKeyedFormData","onDropIndexClick","filter","_","onReorderClick","newIndex","currentTarget","blur","reOrderArray","_newKeyedFormData","slice","onChangeForIndex","value","id","arrayData","newFormData","jsonValue","onSelectChange","idSchema","$id","getDerivedStateFromProps","nextProps","prevState","nextFormData","previousKeyedFormData","length","previousKeyedFormDatum","itemTitle","translateString","ArrayItemTitle","isItemRequired","type","includes","canAddItem","formItems","uiSchema","addable","globalUiOptions","maxItems","render","uiOptions","UnsupportedFieldTemplate","_jsx","reason","MissingItems","isMultiSelect","renderMultiSelect","renderCustomWidget","renderFixedArray","isFilesArray","renderFiles","renderNormalArray","name","disabled","readonly","autofocus","required","onBlur","onFocus","idPrefix","idSeparator","rawErrors","title","formContext","_schemaItems","itemsSchema","retrieveSchema","canAdd","arrayProps","itemCast","itemErrorSchema","itemIdPrefix","itemIdSchema","toIdSchema","renderArrayFieldItem","canMoveUp","canMoveDown","itemData","itemUiSchema","totalItems","className","Template","hideError","placeholder","widgets","widget","uiTitle","options","Widget","label","_a","displayLabel","getDisplayLabel","multiple","hideLabel","enumOptions","itemSchemas","additionalSchema","concat","additional","canRemove","fields","ArraySchemaField","SchemaField","ItemSchemaField","orderable","removable","copyable","has","moveUp","moveDown","copy","remove","toolbar","Object","keys","some","children","hasCopy","hasToolbar","hasMoveUp","hasMoveDown","hasRemove"],"sources":["D:\\Reactjs\\my-app\\node_modules\\@rjsf\\core\\src\\components\\fields\\ArrayField.tsx"],"sourcesContent":["import { Component, MouseEvent } from 'react';\nimport {\n  getTemplate,\n  getWidget,\n  getUiOptions,\n  isFixedItems,\n  allowAdditionalItems,\n  isCustomWidget,\n  optionsList,\n  ArrayFieldTemplateProps,\n  ErrorSchema,\n  FieldProps,\n  FormContextType,\n  IdSchema,\n  RJSFSchema,\n  StrictRJSFSchema,\n  TranslatableString,\n  UiSchema,\n  ITEMS_KEY,\n} from '@rjsf/utils';\nimport cloneDeep from 'lodash/cloneDeep';\nimport get from 'lodash/get';\nimport isObject from 'lodash/isObject';\nimport set from 'lodash/set';\nimport { nanoid } from 'nanoid';\n\n/** Type used to represent the keyed form data used in the state */\ntype KeyedFormDataType<T> = { key: string; item: T };\n\n/** Type used for the state of the `ArrayField` component */\ntype ArrayFieldState<T> = {\n  /** The keyed form data elements */\n  keyedFormData: KeyedFormDataType<T>[];\n  /** Flag indicating whether any of the keyed form data has been updated */\n  updatedKeyedFormData: boolean;\n};\n\n/** Used to generate a unique ID for an element in a row */\nfunction generateRowId() {\n  return nanoid();\n}\n\n/** Converts the `formData` into `KeyedFormDataType` data, using the `generateRowId()` function to create the key\n *\n * @param formData - The data for the form\n * @returns - The `formData` converted into a `KeyedFormDataType` element\n */\nfunction generateKeyedFormData<T>(formData: T[]): KeyedFormDataType<T>[] {\n  return !Array.isArray(formData)\n    ? []\n    : formData.map((item) => {\n        return {\n          key: generateRowId(),\n          item,\n        };\n      });\n}\n\n/** Converts `KeyedFormDataType` data into the inner `formData`\n *\n * @param keyedFormData - The `KeyedFormDataType` to be converted\n * @returns - The inner `formData` item(s) in the `keyedFormData`\n */\nfunction keyedToPlainFormData<T>(keyedFormData: KeyedFormDataType<T> | KeyedFormDataType<T>[]): T[] {\n  if (Array.isArray(keyedFormData)) {\n    return keyedFormData.map((keyedItem) => keyedItem.item);\n  }\n  return [];\n}\n\n/** The `ArrayField` component is used to render a field in the schema that is of type `array`. It supports both normal\n * and fixed array, allowing user to add and remove elements from the array data.\n */\nclass ArrayField<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any> extends Component<\n  FieldProps<T[], S, F>,\n  ArrayFieldState<T>\n> {\n  /** Constructs an `ArrayField` from the `props`, generating the initial keyed data from the `formData`\n   *\n   * @param props - The `FieldProps` for this template\n   */\n  constructor(props: FieldProps<T[], S, F>) {\n    super(props);\n    const { formData = [] } = props;\n    const keyedFormData = generateKeyedFormData<T>(formData);\n    this.state = {\n      keyedFormData,\n      updatedKeyedFormData: false,\n    };\n  }\n\n  /** React lifecycle method that is called when the props are about to change allowing the state to be updated. It\n   * regenerates the keyed form data and returns it\n   *\n   * @param nextProps - The next set of props data\n   * @param prevState - The previous set of state data\n   */\n  static getDerivedStateFromProps<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n    nextProps: Readonly<FieldProps<T[], S, F>>,\n    prevState: Readonly<ArrayFieldState<T>>\n  ) {\n    // Don't call getDerivedStateFromProps if keyed formdata was just updated.\n    if (prevState.updatedKeyedFormData) {\n      return {\n        updatedKeyedFormData: false,\n      };\n    }\n    const nextFormData = Array.isArray(nextProps.formData) ? nextProps.formData : [];\n    const previousKeyedFormData = prevState.keyedFormData || [];\n    const newKeyedFormData =\n      nextFormData.length === previousKeyedFormData.length\n        ? previousKeyedFormData.map((previousKeyedFormDatum, index) => {\n            return {\n              key: previousKeyedFormDatum.key,\n              item: nextFormData[index],\n            };\n          })\n        : generateKeyedFormData<T>(nextFormData);\n    return {\n      keyedFormData: newKeyedFormData,\n    };\n  }\n\n  /** Returns the appropriate title for an item by getting first the title from the schema.items, then falling back to\n   * the description from the schema.items, and finally the string \"Item\"\n   */\n  get itemTitle() {\n    const { schema, registry } = this.props;\n    const { translateString } = registry;\n    return get(\n      schema,\n      [ITEMS_KEY, 'title'],\n      get(schema, [ITEMS_KEY, 'description'], translateString(TranslatableString.ArrayItemTitle))\n    );\n  }\n\n  /** Determines whether the item described in the schema is always required, which is determined by whether any item\n   * may be null.\n   *\n   * @param itemSchema - The schema for the item\n   * @return - True if the item schema type does not contain the \"null\" type\n   */\n  isItemRequired(itemSchema: S) {\n    if (Array.isArray(itemSchema.type)) {\n      // While we don't yet support composite/nullable jsonschema types, it's\n      // future-proof to check for requirement against these.\n      return !itemSchema.type.includes('null');\n    }\n    // All non-null array item types are inherently required by design\n    return itemSchema.type !== 'null';\n  }\n\n  /** Determines whether more items can be added to the array. If the uiSchema indicates the array doesn't allow adding\n   * then false is returned. Otherwise, if the schema indicates that there are a maximum number of items and the\n   * `formData` matches that value, then false is returned, otherwise true is returned.\n   *\n   * @param formItems - The list of items in the form\n   * @returns - True if the item is addable otherwise false\n   */\n  canAddItem(formItems: any[]) {\n    const { schema, uiSchema, registry } = this.props;\n    let { addable } = getUiOptions<T[], S, F>(uiSchema, registry.globalUiOptions);\n    if (addable !== false) {\n      // if ui:options.addable was not explicitly set to false, we can add\n      // another item if we have not exceeded maxItems yet\n      if (schema.maxItems !== undefined) {\n        addable = formItems.length < schema.maxItems;\n      } else {\n        addable = true;\n      }\n    }\n    return addable;\n  }\n\n  /** Returns the default form information for an item based on the schema for that item. Deals with the possibility\n   * that the schema is fixed and allows additional items.\n   */\n  _getNewFormDataRow = (): T => {\n    const { schema, registry } = this.props;\n    const { schemaUtils } = registry;\n    let itemSchema = schema.items as S;\n    if (isFixedItems(schema) && allowAdditionalItems(schema)) {\n      itemSchema = schema.additionalItems as S;\n    }\n    // Cast this as a T to work around schema utils being for T[] caused by the FieldProps<T[], S, F> call on the class\n    return schemaUtils.getDefaultFormState(itemSchema) as unknown as T;\n  };\n\n  /** Callback handler for when the user clicks on the add or add at index buttons. Creates a new row of keyed form data\n   * either at the end of the list (when index is not specified) or inserted at the `index` when it is, adding it into\n   * the state, and then returning `onChange()` with the plain form data converted from the keyed data\n   *\n   * @param event - The event for the click\n   * @param [index] - The optional index at which to add the new data\n   */\n  _handleAddClick(event: MouseEvent, index?: number) {\n    if (event) {\n      event.preventDefault();\n    }\n\n    const { onChange, errorSchema } = this.props;\n    const { keyedFormData } = this.state;\n    // refs #195: revalidate to ensure properly reindexing errors\n    let newErrorSchema: ErrorSchema<T>;\n    if (errorSchema) {\n      newErrorSchema = {};\n      for (const idx in errorSchema) {\n        const i = parseInt(idx);\n        if (index === undefined || i < index) {\n          set(newErrorSchema, [i], errorSchema[idx]);\n        } else if (i >= index) {\n          set(newErrorSchema, [i + 1], errorSchema[idx]);\n        }\n      }\n    }\n\n    const newKeyedFormDataRow: KeyedFormDataType<T> = {\n      key: generateRowId(),\n      item: this._getNewFormDataRow(),\n    };\n    const newKeyedFormData = [...keyedFormData];\n    if (index !== undefined) {\n      newKeyedFormData.splice(index, 0, newKeyedFormDataRow);\n    } else {\n      newKeyedFormData.push(newKeyedFormDataRow);\n    }\n    this.setState(\n      {\n        keyedFormData: newKeyedFormData,\n        updatedKeyedFormData: true,\n      },\n      () => onChange(keyedToPlainFormData(newKeyedFormData), newErrorSchema as ErrorSchema<T[]>)\n    );\n  }\n\n  /** Callback handler for when the user clicks on the add button. Creates a new row of keyed form data at the end of\n   * the list, adding it into the state, and then returning `onChange()` with the plain form data converted from the\n   * keyed data\n   *\n   * @param event - The event for the click\n   */\n  onAddClick = (event: MouseEvent) => {\n    this._handleAddClick(event);\n  };\n\n  /** Callback handler for when the user clicks on the add button on an existing array element. Creates a new row of\n   * keyed form data inserted at the `index`, adding it into the state, and then returning `onChange()` with the plain\n   * form data converted from the keyed data\n   *\n   * @param index - The index at which the add button is clicked\n   */\n  onAddIndexClick = (index: number) => {\n    return (event: MouseEvent) => {\n      this._handleAddClick(event, index);\n    };\n  };\n\n  /** Callback handler for when the user clicks on the copy button on an existing array element. Clones the row of\n   * keyed form data at the `index` into the next position in the state, and then returning `onChange()` with the plain\n   * form data converted from the keyed data\n   *\n   * @param index - The index at which the copy button is clicked\n   */\n  onCopyIndexClick = (index: number) => {\n    return (event: MouseEvent) => {\n      if (event) {\n        event.preventDefault();\n      }\n\n      const { onChange, errorSchema } = this.props;\n      const { keyedFormData } = this.state;\n      // refs #195: revalidate to ensure properly reindexing errors\n      let newErrorSchema: ErrorSchema<T>;\n      if (errorSchema) {\n        newErrorSchema = {};\n        for (const idx in errorSchema) {\n          const i = parseInt(idx);\n          if (i <= index) {\n            set(newErrorSchema, [i], errorSchema[idx]);\n          } else if (i > index) {\n            set(newErrorSchema, [i + 1], errorSchema[idx]);\n          }\n        }\n      }\n\n      const newKeyedFormDataRow: KeyedFormDataType<T> = {\n        key: generateRowId(),\n        item: cloneDeep(keyedFormData[index].item),\n      };\n      const newKeyedFormData = [...keyedFormData];\n      if (index !== undefined) {\n        newKeyedFormData.splice(index + 1, 0, newKeyedFormDataRow);\n      } else {\n        newKeyedFormData.push(newKeyedFormDataRow);\n      }\n      this.setState(\n        {\n          keyedFormData: newKeyedFormData,\n          updatedKeyedFormData: true,\n        },\n        () => onChange(keyedToPlainFormData(newKeyedFormData), newErrorSchema as ErrorSchema<T[]>)\n      );\n    };\n  };\n\n  /** Callback handler for when the user clicks on the remove button on an existing array element. Removes the row of\n   * keyed form data at the `index` in the state, and then returning `onChange()` with the plain form data converted\n   * from the keyed data\n   *\n   * @param index - The index at which the remove button is clicked\n   */\n  onDropIndexClick = (index: number) => {\n    return (event: MouseEvent) => {\n      if (event) {\n        event.preventDefault();\n      }\n      const { onChange, errorSchema } = this.props;\n      const { keyedFormData } = this.state;\n      // refs #195: revalidate to ensure properly reindexing errors\n      let newErrorSchema: ErrorSchema<T>;\n      if (errorSchema) {\n        newErrorSchema = {};\n        for (const idx in errorSchema) {\n          const i = parseInt(idx);\n          if (i < index) {\n            set(newErrorSchema, [i], errorSchema[idx]);\n          } else if (i > index) {\n            set(newErrorSchema, [i - 1], errorSchema[idx]);\n          }\n        }\n      }\n      const newKeyedFormData = keyedFormData.filter((_, i) => i !== index);\n      this.setState(\n        {\n          keyedFormData: newKeyedFormData,\n          updatedKeyedFormData: true,\n        },\n        () => onChange(keyedToPlainFormData(newKeyedFormData), newErrorSchema as ErrorSchema<T[]>)\n      );\n    };\n  };\n\n  /** Callback handler for when the user clicks on one of the move item buttons on an existing array element. Moves the\n   * row of keyed form data at the `index` to the `newIndex` in the state, and then returning `onChange()` with the\n   * plain form data converted from the keyed data\n   *\n   * @param index - The index of the item to move\n   * @param newIndex - The index to where the item is to be moved\n   */\n  onReorderClick = (index: number, newIndex: number) => {\n    return (event: MouseEvent<HTMLButtonElement>) => {\n      if (event) {\n        event.preventDefault();\n        event.currentTarget.blur();\n      }\n      const { onChange, errorSchema } = this.props;\n      let newErrorSchema: ErrorSchema<T>;\n      if (errorSchema) {\n        newErrorSchema = {};\n        for (const idx in errorSchema) {\n          const i = parseInt(idx);\n          if (i == index) {\n            set(newErrorSchema, [newIndex], errorSchema[index]);\n          } else if (i == newIndex) {\n            set(newErrorSchema, [index], errorSchema[newIndex]);\n          } else {\n            set(newErrorSchema, [idx], errorSchema[i]);\n          }\n        }\n      }\n\n      const { keyedFormData } = this.state;\n      function reOrderArray() {\n        // Copy item\n        const _newKeyedFormData = keyedFormData.slice();\n\n        // Moves item from index to newIndex\n        _newKeyedFormData.splice(index, 1);\n        _newKeyedFormData.splice(newIndex, 0, keyedFormData[index]);\n\n        return _newKeyedFormData;\n      }\n      const newKeyedFormData = reOrderArray();\n      this.setState(\n        {\n          keyedFormData: newKeyedFormData,\n        },\n        () => onChange(keyedToPlainFormData(newKeyedFormData), newErrorSchema as ErrorSchema<T[]>)\n      );\n    };\n  };\n\n  /** Callback handler used to deal with changing the value of the data in the array at the `index`. Calls the\n   * `onChange` callback with the updated form data\n   *\n   * @param index - The index of the item being changed\n   */\n  onChangeForIndex = (index: number) => {\n    return (value: any, newErrorSchema?: ErrorSchema<T>, id?: string) => {\n      const { formData, onChange, errorSchema } = this.props;\n      const arrayData = Array.isArray(formData) ? formData : [];\n      const newFormData = arrayData.map((item: T, i: number) => {\n        // We need to treat undefined items as nulls to have validation.\n        // See https://github.com/tdegrunt/jsonschema/issues/206\n        const jsonValue = typeof value === 'undefined' ? null : value;\n        return index === i ? jsonValue : item;\n      });\n      onChange(\n        newFormData,\n        errorSchema &&\n          errorSchema && {\n            ...errorSchema,\n            [index]: newErrorSchema,\n          },\n        id\n      );\n    };\n  };\n\n  /** Callback handler used to change the value for a checkbox */\n  onSelectChange = (value: any) => {\n    const { onChange, idSchema } = this.props;\n    onChange(value, undefined, idSchema && idSchema.$id);\n  };\n\n  /** Renders the `ArrayField` depending on the specific needs of the schema and uischema elements\n   */\n  render() {\n    const { schema, uiSchema, idSchema, registry } = this.props;\n    const { schemaUtils, translateString } = registry;\n    if (!(ITEMS_KEY in schema)) {\n      const uiOptions = getUiOptions<T[], S, F>(uiSchema);\n      const UnsupportedFieldTemplate = getTemplate<'UnsupportedFieldTemplate', T[], S, F>(\n        'UnsupportedFieldTemplate',\n        registry,\n        uiOptions\n      );\n\n      return (\n        <UnsupportedFieldTemplate\n          schema={schema}\n          idSchema={idSchema}\n          reason={translateString(TranslatableString.MissingItems)}\n          registry={registry}\n        />\n      );\n    }\n    if (schemaUtils.isMultiSelect(schema)) {\n      // If array has enum or uniqueItems set to true, call renderMultiSelect() to render the default multiselect widget or a custom widget, if specified.\n      return this.renderMultiSelect();\n    }\n    if (isCustomWidget<T[], S, F>(uiSchema)) {\n      return this.renderCustomWidget();\n    }\n    if (isFixedItems(schema)) {\n      return this.renderFixedArray();\n    }\n    if (schemaUtils.isFilesArray(schema, uiSchema)) {\n      return this.renderFiles();\n    }\n    return this.renderNormalArray();\n  }\n\n  /** Renders a normal array without any limitations of length\n   */\n  renderNormalArray() {\n    const {\n      schema,\n      uiSchema = {},\n      errorSchema,\n      idSchema,\n      name,\n      disabled = false,\n      readonly = false,\n      autofocus = false,\n      required = false,\n      registry,\n      onBlur,\n      onFocus,\n      idPrefix,\n      idSeparator = '_',\n      rawErrors,\n    } = this.props;\n    const { keyedFormData } = this.state;\n    const title = schema.title === undefined ? name : schema.title;\n    const { schemaUtils, formContext } = registry;\n    const uiOptions = getUiOptions<T[], S, F>(uiSchema);\n    const _schemaItems: S = isObject(schema.items) ? (schema.items as S) : ({} as S);\n    const itemsSchema: S = schemaUtils.retrieveSchema(_schemaItems);\n    const formData = keyedToPlainFormData(this.state.keyedFormData);\n    const canAdd = this.canAddItem(formData);\n    const arrayProps: ArrayFieldTemplateProps<T[], S, F> = {\n      canAdd,\n      items: keyedFormData.map((keyedItem, index) => {\n        const { key, item } = keyedItem;\n        // While we are actually dealing with a single item of type T, the types require a T[], so cast\n        const itemCast = item as unknown as T[];\n        const itemSchema = schemaUtils.retrieveSchema(_schemaItems, itemCast);\n        const itemErrorSchema = errorSchema ? (errorSchema[index] as ErrorSchema<T[]>) : undefined;\n        const itemIdPrefix = idSchema.$id + idSeparator + index;\n        const itemIdSchema = schemaUtils.toIdSchema(itemSchema, itemIdPrefix, itemCast, idPrefix, idSeparator);\n        return this.renderArrayFieldItem({\n          key,\n          index,\n          name: name && `${name}-${index}`,\n          canAdd,\n          canMoveUp: index > 0,\n          canMoveDown: index < formData.length - 1,\n          itemSchema,\n          itemIdSchema,\n          itemErrorSchema,\n          itemData: itemCast,\n          itemUiSchema: uiSchema.items,\n          autofocus: autofocus && index === 0,\n          onBlur,\n          onFocus,\n          rawErrors,\n          totalItems: keyedFormData.length,\n        });\n      }),\n      className: `field field-array field-array-of-${itemsSchema.type}`,\n      disabled,\n      idSchema,\n      uiSchema,\n      onAddClick: this.onAddClick,\n      readonly,\n      required,\n      schema,\n      title,\n      formContext,\n      formData,\n      rawErrors,\n      registry,\n    };\n\n    const Template = getTemplate<'ArrayFieldTemplate', T[], S, F>('ArrayFieldTemplate', registry, uiOptions);\n    return <Template {...arrayProps} />;\n  }\n\n  /** Renders an array using the custom widget provided by the user in the `uiSchema`\n   */\n  renderCustomWidget() {\n    const {\n      schema,\n      idSchema,\n      uiSchema,\n      disabled = false,\n      readonly = false,\n      autofocus = false,\n      required = false,\n      hideError,\n      placeholder,\n      onBlur,\n      onFocus,\n      formData: items = [],\n      registry,\n      rawErrors,\n      name,\n    } = this.props;\n    const { widgets, formContext, globalUiOptions, schemaUtils } = registry;\n    const { widget, title: uiTitle, ...options } = getUiOptions<T[], S, F>(uiSchema, globalUiOptions);\n    const Widget = getWidget<T[], S, F>(schema, widget, widgets);\n    const label = uiTitle ?? schema.title ?? name;\n    const displayLabel = schemaUtils.getDisplayLabel(schema, uiSchema, globalUiOptions);\n    return (\n      <Widget\n        id={idSchema.$id}\n        name={name}\n        multiple\n        onChange={this.onSelectChange}\n        onBlur={onBlur}\n        onFocus={onFocus}\n        options={options}\n        schema={schema}\n        uiSchema={uiSchema}\n        registry={registry}\n        value={items}\n        disabled={disabled}\n        readonly={readonly}\n        hideError={hideError}\n        required={required}\n        label={label}\n        hideLabel={!displayLabel}\n        placeholder={placeholder}\n        formContext={formContext}\n        autofocus={autofocus}\n        rawErrors={rawErrors}\n      />\n    );\n  }\n\n  /** Renders an array as a set of checkboxes\n   */\n  renderMultiSelect() {\n    const {\n      schema,\n      idSchema,\n      uiSchema,\n      formData: items = [],\n      disabled = false,\n      readonly = false,\n      autofocus = false,\n      required = false,\n      placeholder,\n      onBlur,\n      onFocus,\n      registry,\n      rawErrors,\n      name,\n    } = this.props;\n    const { widgets, schemaUtils, formContext, globalUiOptions } = registry;\n    const itemsSchema = schemaUtils.retrieveSchema(schema.items as S, items);\n    const enumOptions = optionsList(itemsSchema);\n    const { widget = 'select', title: uiTitle, ...options } = getUiOptions<T[], S, F>(uiSchema, globalUiOptions);\n    const Widget = getWidget<T[], S, F>(schema, widget, widgets);\n    const label = uiTitle ?? schema.title ?? name;\n    const displayLabel = schemaUtils.getDisplayLabel(schema, uiSchema, globalUiOptions);\n    return (\n      <Widget\n        id={idSchema.$id}\n        name={name}\n        multiple\n        onChange={this.onSelectChange}\n        onBlur={onBlur}\n        onFocus={onFocus}\n        options={{ ...options, enumOptions }}\n        schema={schema}\n        uiSchema={uiSchema}\n        registry={registry}\n        value={items}\n        disabled={disabled}\n        readonly={readonly}\n        required={required}\n        label={label}\n        hideLabel={!displayLabel}\n        placeholder={placeholder}\n        formContext={formContext}\n        autofocus={autofocus}\n        rawErrors={rawErrors}\n      />\n    );\n  }\n\n  /** Renders an array of files using the `FileWidget`\n   */\n  renderFiles() {\n    const {\n      schema,\n      uiSchema,\n      idSchema,\n      name,\n      disabled = false,\n      readonly = false,\n      autofocus = false,\n      required = false,\n      onBlur,\n      onFocus,\n      registry,\n      formData: items = [],\n      rawErrors,\n    } = this.props;\n    const { widgets, formContext, globalUiOptions, schemaUtils } = registry;\n    const { widget = 'files', title: uiTitle, ...options } = getUiOptions<T[], S, F>(uiSchema, globalUiOptions);\n    const Widget = getWidget<T[], S, F>(schema, widget, widgets);\n    const label = uiTitle ?? schema.title ?? name;\n    const displayLabel = schemaUtils.getDisplayLabel(schema, uiSchema, globalUiOptions);\n    return (\n      <Widget\n        options={options}\n        id={idSchema.$id}\n        name={name}\n        multiple\n        onChange={this.onSelectChange}\n        onBlur={onBlur}\n        onFocus={onFocus}\n        schema={schema}\n        uiSchema={uiSchema}\n        value={items}\n        disabled={disabled}\n        readonly={readonly}\n        required={required}\n        registry={registry}\n        formContext={formContext}\n        autofocus={autofocus}\n        rawErrors={rawErrors}\n        label={label}\n        hideLabel={!displayLabel}\n      />\n    );\n  }\n\n  /** Renders an array that has a maximum limit of items\n   */\n  renderFixedArray() {\n    const {\n      schema,\n      uiSchema = {},\n      formData = [],\n      errorSchema,\n      idPrefix,\n      idSeparator = '_',\n      idSchema,\n      name,\n      disabled = false,\n      readonly = false,\n      autofocus = false,\n      required = false,\n      registry,\n      onBlur,\n      onFocus,\n      rawErrors,\n    } = this.props;\n    const { keyedFormData } = this.state;\n    let { formData: items = [] } = this.props;\n    const title = schema.title || name;\n    const uiOptions = getUiOptions<T[], S, F>(uiSchema);\n    const { schemaUtils, formContext } = registry;\n    const _schemaItems: S[] = isObject(schema.items) ? (schema.items as S[]) : ([] as S[]);\n    const itemSchemas = _schemaItems.map((item: S, index: number) =>\n      schemaUtils.retrieveSchema(item, formData[index] as unknown as T[])\n    );\n    const additionalSchema = isObject(schema.additionalItems)\n      ? schemaUtils.retrieveSchema(schema.additionalItems as S, formData)\n      : null;\n\n    if (!items || items.length < itemSchemas.length) {\n      // to make sure at least all fixed items are generated\n      items = items || [];\n      items = items.concat(new Array(itemSchemas.length - items.length));\n    }\n\n    // These are the props passed into the render function\n    const canAdd = this.canAddItem(items) && !!additionalSchema;\n    const arrayProps: ArrayFieldTemplateProps<T[], S, F> = {\n      canAdd,\n      className: 'field field-array field-array-fixed-items',\n      disabled,\n      idSchema,\n      formData,\n      items: keyedFormData.map((keyedItem, index) => {\n        const { key, item } = keyedItem;\n        // While we are actually dealing with a single item of type T, the types require a T[], so cast\n        const itemCast = item as unknown as T[];\n        const additional = index >= itemSchemas.length;\n        const itemSchema =\n          (additional && isObject(schema.additionalItems)\n            ? schemaUtils.retrieveSchema(schema.additionalItems as S, itemCast)\n            : itemSchemas[index]) || {};\n        const itemIdPrefix = idSchema.$id + idSeparator + index;\n        const itemIdSchema = schemaUtils.toIdSchema(itemSchema, itemIdPrefix, itemCast, idPrefix, idSeparator);\n        const itemUiSchema = additional\n          ? uiSchema.additionalItems || {}\n          : Array.isArray(uiSchema.items)\n          ? uiSchema.items[index]\n          : uiSchema.items || {};\n        const itemErrorSchema = errorSchema ? (errorSchema[index] as ErrorSchema<T[]>) : undefined;\n\n        return this.renderArrayFieldItem({\n          key,\n          index,\n          name: name && `${name}-${index}`,\n          canAdd,\n          canRemove: additional,\n          canMoveUp: index >= itemSchemas.length + 1,\n          canMoveDown: additional && index < items.length - 1,\n          itemSchema,\n          itemData: itemCast,\n          itemUiSchema,\n          itemIdSchema,\n          itemErrorSchema,\n          autofocus: autofocus && index === 0,\n          onBlur,\n          onFocus,\n          rawErrors,\n          totalItems: keyedFormData.length,\n        });\n      }),\n      onAddClick: this.onAddClick,\n      readonly,\n      required,\n      registry,\n      schema,\n      uiSchema,\n      title,\n      formContext,\n      rawErrors,\n    };\n\n    const Template = getTemplate<'ArrayFieldTemplate', T[], S, F>('ArrayFieldTemplate', registry, uiOptions);\n    return <Template {...arrayProps} />;\n  }\n\n  /** Renders the individual array item using a `SchemaField` along with the additional properties required to be send\n   * back to the `ArrayFieldItemTemplate`.\n   *\n   * @param props - The props for the individual array item to be rendered\n   */\n  renderArrayFieldItem(props: {\n    key: string;\n    index: number;\n    name: string;\n    canAdd: boolean;\n    canRemove?: boolean;\n    canMoveUp: boolean;\n    canMoveDown: boolean;\n    itemSchema: S;\n    itemData: T[];\n    itemUiSchema: UiSchema<T[], S, F>;\n    itemIdSchema: IdSchema<T[]>;\n    itemErrorSchema?: ErrorSchema<T[]>;\n    autofocus?: boolean;\n    onBlur: FieldProps<T[], S, F>['onBlur'];\n    onFocus: FieldProps<T[], S, F>['onFocus'];\n    rawErrors?: string[];\n    totalItems: number;\n  }) {\n    const {\n      key,\n      index,\n      name,\n      canAdd,\n      canRemove = true,\n      canMoveUp,\n      canMoveDown,\n      itemSchema,\n      itemData,\n      itemUiSchema,\n      itemIdSchema,\n      itemErrorSchema,\n      autofocus,\n      onBlur,\n      onFocus,\n      rawErrors,\n      totalItems,\n    } = props;\n    const { disabled, hideError, idPrefix, idSeparator, readonly, uiSchema, registry, formContext } = this.props;\n    const {\n      fields: { ArraySchemaField, SchemaField },\n      globalUiOptions,\n    } = registry;\n    const ItemSchemaField = ArraySchemaField || SchemaField;\n    const { orderable = true, removable = true, copyable = false } = getUiOptions<T[], S, F>(uiSchema, globalUiOptions);\n    const has: { [key: string]: boolean } = {\n      moveUp: orderable && canMoveUp,\n      moveDown: orderable && canMoveDown,\n      copy: copyable && canAdd,\n      remove: removable && canRemove,\n      toolbar: false,\n    };\n    has.toolbar = Object.keys(has).some((key: keyof typeof has) => has[key]);\n\n    return {\n      children: (\n        <ItemSchemaField\n          name={name}\n          index={index}\n          schema={itemSchema}\n          uiSchema={itemUiSchema}\n          formData={itemData}\n          formContext={formContext}\n          errorSchema={itemErrorSchema}\n          idPrefix={idPrefix}\n          idSeparator={idSeparator}\n          idSchema={itemIdSchema}\n          required={this.isItemRequired(itemSchema)}\n          onChange={this.onChangeForIndex(index)}\n          onBlur={onBlur}\n          onFocus={onFocus}\n          registry={registry}\n          disabled={disabled}\n          readonly={readonly}\n          hideError={hideError}\n          autofocus={autofocus}\n          rawErrors={rawErrors}\n        />\n      ),\n      className: 'array-item',\n      disabled,\n      canAdd,\n      hasCopy: has.copy,\n      hasToolbar: has.toolbar,\n      hasMoveUp: has.moveUp,\n      hasMoveDown: has.moveDown,\n      hasRemove: has.remove,\n      index,\n      totalItems,\n      key,\n      onAddIndexClick: this.onAddIndexClick,\n      onCopyIndexClick: this.onCopyIndexClick,\n      onDropIndexClick: this.onDropIndexClick,\n      onReorderClick: this.onReorderClick,\n      readonly,\n      registry,\n      schema: itemSchema,\n      uiSchema: itemUiSchema,\n    };\n  }\n}\n\n/** `ArrayField` is `React.ComponentType<FieldProps<T[], S, F>>` (necessarily) but the `registry` requires things to be a\n * `Field` which is defined as `React.ComponentType<FieldProps<T, S, F>>`, so cast it to make `registry` happy.\n */\nexport default ArrayField;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}