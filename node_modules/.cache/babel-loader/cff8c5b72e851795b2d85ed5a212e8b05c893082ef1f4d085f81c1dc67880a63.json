{"ast":null,"code":"import { jsx as _jsx, Fragment as _Fragment, jsxs as _jsxs } from \"react/jsx-runtime\";\nimport { useCallback, Component } from 'react';\nimport { ADDITIONAL_PROPERTY_FLAG, deepEquals, descriptionId, getSchemaType, getTemplate, getUiOptions, ID_KEY, mergeObjects, TranslatableString, UI_OPTIONS_KEY } from '@rjsf/utils';\nimport isObject from 'lodash/isObject';\nimport omit from 'lodash/omit';\nimport Markdown from 'markdown-to-jsx';\n/** The map of component type to FieldName */\nconst COMPONENT_TYPES = {\n  array: 'ArrayField',\n  boolean: 'BooleanField',\n  integer: 'NumberField',\n  number: 'NumberField',\n  object: 'ObjectField',\n  string: 'StringField',\n  null: 'NullField'\n};\n/** Computes and returns which `Field` implementation to return in order to render the field represented by the\n * `schema`. The `uiOptions` are used to alter what potential `Field` implementation is actually returned. If no\n * appropriate `Field` implementation can be found then a wrapper around `UnsupportedFieldTemplate` is used.\n *\n * @param schema - The schema from which to obtain the type\n * @param uiOptions - The UI Options that may affect the component decision\n * @param idSchema - The id that is passed to the `UnsupportedFieldTemplate`\n * @param registry - The registry from which fields and templates are obtained\n * @returns - The `Field` component that is used to render the actual field data\n */\nfunction getFieldComponent(schema, uiOptions, idSchema, registry) {\n  const field = uiOptions.field;\n  const {\n    fields,\n    translateString\n  } = registry;\n  if (typeof field === 'function') {\n    return field;\n  }\n  if (typeof field === 'string' && field in fields) {\n    return fields[field];\n  }\n  const schemaType = getSchemaType(schema);\n  const type = Array.isArray(schemaType) ? schemaType[0] : schemaType || '';\n  const schemaId = schema.$id;\n  let componentName = COMPONENT_TYPES[type];\n  if (schemaId && schemaId in fields) {\n    componentName = schemaId;\n  }\n  // If the type is not defined and the schema uses 'anyOf' or 'oneOf', don't\n  // render a field and let the MultiSchemaField component handle the form display\n  if (!componentName && (schema.anyOf || schema.oneOf)) {\n    return () => null;\n  }\n  return componentName in fields ? fields[componentName] : () => {\n    const UnsupportedFieldTemplate = getTemplate('UnsupportedFieldTemplate', registry, uiOptions);\n    return _jsx(UnsupportedFieldTemplate, {\n      schema: schema,\n      idSchema: idSchema,\n      reason: translateString(TranslatableString.UnknownFieldType, [String(schema.type)]),\n      registry: registry\n    });\n  };\n}\n/** The `SchemaFieldRender` component is the work-horse of react-jsonschema-form, determining what kind of real field to\n * render based on the `schema`, `uiSchema` and all the other props. It also deals with rendering the `anyOf` and\n * `oneOf` fields.\n *\n * @param props - The `FieldProps` for this component\n */\nfunction SchemaFieldRender(props) {\n  const {\n    schema: _schema,\n    idSchema: _idSchema,\n    uiSchema,\n    formData,\n    errorSchema,\n    idPrefix,\n    idSeparator,\n    name,\n    onChange,\n    onKeyChange,\n    onDropPropertyClick,\n    required,\n    registry,\n    wasPropertyKeyModified = false\n  } = props;\n  const {\n    formContext,\n    schemaUtils,\n    globalUiOptions\n  } = registry;\n  const uiOptions = getUiOptions(uiSchema, globalUiOptions);\n  const FieldTemplate = getTemplate('FieldTemplate', registry, uiOptions);\n  const DescriptionFieldTemplate = getTemplate('DescriptionFieldTemplate', registry, uiOptions);\n  const FieldHelpTemplate = getTemplate('FieldHelpTemplate', registry, uiOptions);\n  const FieldErrorTemplate = getTemplate('FieldErrorTemplate', registry, uiOptions);\n  const schema = schemaUtils.retrieveSchema(_schema, formData);\n  const fieldId = _idSchema[ID_KEY];\n  const idSchema = mergeObjects(schemaUtils.toIdSchema(schema, fieldId, formData, idPrefix, idSeparator), _idSchema);\n  /** Intermediary `onChange` handler for field components that will inject the `id` of the current field into the\n   * `onChange` chain if it is not already being provided from a deeper level in the hierarchy\n   */\n  const handleFieldComponentChange = useCallback((formData, newErrorSchema, id) => {\n    const theId = id || fieldId;\n    return onChange(formData, newErrorSchema, theId);\n  }, [fieldId, onChange]);\n  const FieldComponent = getFieldComponent(schema, uiOptions, idSchema, registry);\n  const disabled = Boolean(props.disabled || uiOptions.disabled);\n  const readonly = Boolean(props.readonly || uiOptions.readonly || props.schema.readOnly || schema.readOnly);\n  const uiSchemaHideError = uiOptions.hideError;\n  // Set hideError to the value provided in the uiSchema, otherwise stick with the prop to propagate to children\n  const hideError = uiSchemaHideError === undefined ? props.hideError : Boolean(uiSchemaHideError);\n  const autofocus = Boolean(props.autofocus || uiOptions.autofocus);\n  if (Object.keys(schema).length === 0) {\n    return null;\n  }\n  const displayLabel = schemaUtils.getDisplayLabel(schema, uiSchema, globalUiOptions);\n  const {\n    __errors,\n    ...fieldErrorSchema\n  } = errorSchema || {};\n  // See #439: uiSchema: Don't pass consumed class names or style to child components\n  const fieldUiSchema = omit(uiSchema, ['ui:classNames', 'classNames', 'ui:style']);\n  if (UI_OPTIONS_KEY in fieldUiSchema) {\n    fieldUiSchema[UI_OPTIONS_KEY] = omit(fieldUiSchema[UI_OPTIONS_KEY], ['classNames', 'style']);\n  }\n  const field = _jsx(FieldComponent, {\n    ...props,\n    onChange: handleFieldComponentChange,\n    idSchema: idSchema,\n    schema: schema,\n    uiSchema: fieldUiSchema,\n    disabled: disabled,\n    readonly: readonly,\n    hideError: hideError,\n    autofocus: autofocus,\n    errorSchema: fieldErrorSchema,\n    formContext: formContext,\n    rawErrors: __errors\n  });\n  const id = idSchema[ID_KEY];\n  // If this schema has a title defined, but the user has set a new key/label, retain their input.\n  let label;\n  if (wasPropertyKeyModified) {\n    label = name;\n  } else {\n    label = ADDITIONAL_PROPERTY_FLAG in schema ? name : uiOptions.title || props.schema.title || schema.title || name;\n  }\n  const description = uiOptions.description || props.schema.description || schema.description || '';\n  const richDescription = uiOptions.enableMarkdownInDescription ? _jsx(Markdown, {\n    children: description\n  }) : description;\n  const help = uiOptions.help;\n  const hidden = uiOptions.widget === 'hidden';\n  const classNames = ['form-group', 'field', \"field-\".concat(getSchemaType(schema))];\n  if (!hideError && __errors && __errors.length > 0) {\n    classNames.push('field-error has-error has-danger');\n  }\n  if (uiSchema === null || uiSchema === void 0 ? void 0 : uiSchema.classNames) {\n    if (process.env.NODE_ENV !== 'production') {\n      console.warn(\"'uiSchema.classNames' is deprecated and may be removed in a major release; Use 'ui:classNames' instead.\");\n    }\n    classNames.push(uiSchema.classNames);\n  }\n  if (uiOptions.classNames) {\n    classNames.push(uiOptions.classNames);\n  }\n  const helpComponent = _jsx(FieldHelpTemplate, {\n    help: help,\n    idSchema: idSchema,\n    schema: schema,\n    uiSchema: uiSchema,\n    hasErrors: !hideError && __errors && __errors.length > 0,\n    registry: registry\n  });\n  /*\n   * AnyOf/OneOf errors handled by child schema\n   * unless it can be rendered as select control\n   */\n  const errorsComponent = hideError || (schema.anyOf || schema.oneOf) && !schemaUtils.isSelect(schema) ? undefined : _jsx(FieldErrorTemplate, {\n    errors: __errors,\n    errorSchema: errorSchema,\n    idSchema: idSchema,\n    schema: schema,\n    uiSchema: uiSchema,\n    registry: registry\n  });\n  const fieldProps = {\n    description: _jsx(DescriptionFieldTemplate, {\n      id: descriptionId(id),\n      description: richDescription,\n      schema: schema,\n      uiSchema: uiSchema,\n      registry: registry\n    }),\n    rawDescription: description,\n    help: helpComponent,\n    rawHelp: typeof help === 'string' ? help : undefined,\n    errors: errorsComponent,\n    rawErrors: hideError ? undefined : __errors,\n    id,\n    label,\n    hidden,\n    onChange,\n    onKeyChange,\n    onDropPropertyClick,\n    required,\n    disabled,\n    readonly,\n    hideError,\n    displayLabel,\n    classNames: classNames.join(' ').trim(),\n    style: uiOptions.style,\n    formContext,\n    formData,\n    schema,\n    uiSchema,\n    registry\n  };\n  const _AnyOfField = registry.fields.AnyOfField;\n  const _OneOfField = registry.fields.OneOfField;\n  const isReplacingAnyOrOneOf = (uiSchema === null || uiSchema === void 0 ? void 0 : uiSchema['ui:field']) && (uiSchema === null || uiSchema === void 0 ? void 0 : uiSchema['ui:fieldReplacesAnyOrOneOf']) === true;\n  return _jsx(FieldTemplate, {\n    ...fieldProps,\n    children: _jsxs(_Fragment, {\n      children: [field, schema.anyOf && !isReplacingAnyOrOneOf && !schemaUtils.isSelect(schema) && _jsx(_AnyOfField, {\n        name: name,\n        disabled: disabled,\n        readonly: readonly,\n        hideError: hideError,\n        errorSchema: errorSchema,\n        formData: formData,\n        formContext: formContext,\n        idPrefix: idPrefix,\n        idSchema: idSchema,\n        idSeparator: idSeparator,\n        onBlur: props.onBlur,\n        onChange: props.onChange,\n        onFocus: props.onFocus,\n        options: schema.anyOf.map(_schema => schemaUtils.retrieveSchema(isObject(_schema) ? _schema : {}, formData)),\n        registry: registry,\n        schema: schema,\n        uiSchema: uiSchema\n      }), schema.oneOf && !isReplacingAnyOrOneOf && !schemaUtils.isSelect(schema) && _jsx(_OneOfField, {\n        name: name,\n        disabled: disabled,\n        readonly: readonly,\n        hideError: hideError,\n        errorSchema: errorSchema,\n        formData: formData,\n        formContext: formContext,\n        idPrefix: idPrefix,\n        idSchema: idSchema,\n        idSeparator: idSeparator,\n        onBlur: props.onBlur,\n        onChange: props.onChange,\n        onFocus: props.onFocus,\n        options: schema.oneOf.map(_schema => schemaUtils.retrieveSchema(isObject(_schema) ? _schema : {}, formData)),\n        registry: registry,\n        schema: schema,\n        uiSchema: uiSchema\n      })]\n    })\n  });\n}\n/** The `SchemaField` component determines whether it is necessary to rerender the component based on any props changes\n * and if so, calls the `SchemaFieldRender` component with the props.\n */\nclass SchemaField extends Component {\n  shouldComponentUpdate(nextProps) {\n    return !deepEquals(this.props, nextProps);\n  }\n  render() {\n    return _jsx(SchemaFieldRender, {\n      ...this.props\n    });\n  }\n}\nexport default SchemaField;","map":{"version":3,"names":["useCallback","Component","ADDITIONAL_PROPERTY_FLAG","deepEquals","descriptionId","getSchemaType","getTemplate","getUiOptions","ID_KEY","mergeObjects","TranslatableString","UI_OPTIONS_KEY","isObject","omit","Markdown","COMPONENT_TYPES","array","boolean","integer","number","object","string","null","getFieldComponent","schema","uiOptions","idSchema","registry","field","fields","translateString","schemaType","type","Array","isArray","schemaId","$id","componentName","anyOf","oneOf","UnsupportedFieldTemplate","_jsx","reason","UnknownFieldType","String","SchemaFieldRender","props","_schema","_idSchema","uiSchema","formData","errorSchema","idPrefix","idSeparator","name","onChange","onKeyChange","onDropPropertyClick","required","wasPropertyKeyModified","formContext","schemaUtils","globalUiOptions","FieldTemplate","DescriptionFieldTemplate","FieldHelpTemplate","FieldErrorTemplate","retrieveSchema","fieldId","toIdSchema","handleFieldComponentChange","newErrorSchema","id","theId","FieldComponent","disabled","Boolean","readonly","readOnly","uiSchemaHideError","hideError","undefined","autofocus","Object","keys","length","displayLabel","getDisplayLabel","__errors","fieldErrorSchema","fieldUiSchema","rawErrors","label","title","description","richDescription","enableMarkdownInDescription","children","help","hidden","widget","classNames","concat","push","process","env","NODE_ENV","console","warn","helpComponent","hasErrors","errorsComponent","isSelect","errors","fieldProps","rawDescription","rawHelp","join","trim","style","_AnyOfField","AnyOfField","_OneOfField","OneOfField","isReplacingAnyOrOneOf","_jsxs","_Fragment","onBlur","onFocus","options","map","SchemaField","shouldComponentUpdate","nextProps","render"],"sources":["D:\\Reactjs\\my-app\\node_modules\\@rjsf\\core\\src\\components\\fields\\SchemaField.tsx"],"sourcesContent":["import { useCallback, Component } from 'react';\nimport {\n  ADDITIONAL_PROPERTY_FLAG,\n  deepEquals,\n  descriptionId,\n  ErrorSchema,\n  FieldProps,\n  FieldTemplateProps,\n  FormContextType,\n  getSchemaType,\n  getTemplate,\n  getUiOptions,\n  ID_KEY,\n  IdSchema,\n  mergeObjects,\n  Registry,\n  RJSFSchema,\n  StrictRJSFSchema,\n  TranslatableString,\n  UI_OPTIONS_KEY,\n  UIOptionsType,\n} from '@rjsf/utils';\nimport isObject from 'lodash/isObject';\nimport omit from 'lodash/omit';\nimport Markdown from 'markdown-to-jsx';\n\n/** The map of component type to FieldName */\nconst COMPONENT_TYPES: { [key: string]: string } = {\n  array: 'ArrayField',\n  boolean: 'BooleanField',\n  integer: 'NumberField',\n  number: 'NumberField',\n  object: 'ObjectField',\n  string: 'StringField',\n  null: 'NullField',\n};\n\n/** Computes and returns which `Field` implementation to return in order to render the field represented by the\n * `schema`. The `uiOptions` are used to alter what potential `Field` implementation is actually returned. If no\n * appropriate `Field` implementation can be found then a wrapper around `UnsupportedFieldTemplate` is used.\n *\n * @param schema - The schema from which to obtain the type\n * @param uiOptions - The UI Options that may affect the component decision\n * @param idSchema - The id that is passed to the `UnsupportedFieldTemplate`\n * @param registry - The registry from which fields and templates are obtained\n * @returns - The `Field` component that is used to render the actual field data\n */\nfunction getFieldComponent<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  schema: S,\n  uiOptions: UIOptionsType<T, S, F>,\n  idSchema: IdSchema<T>,\n  registry: Registry<T, S, F>\n) {\n  const field = uiOptions.field;\n  const { fields, translateString } = registry;\n  if (typeof field === 'function') {\n    return field;\n  }\n  if (typeof field === 'string' && field in fields) {\n    return fields[field];\n  }\n\n  const schemaType = getSchemaType(schema);\n  const type: string = Array.isArray(schemaType) ? schemaType[0] : schemaType || '';\n\n  const schemaId = schema.$id;\n\n  let componentName = COMPONENT_TYPES[type];\n  if (schemaId && schemaId in fields) {\n    componentName = schemaId;\n  }\n\n  // If the type is not defined and the schema uses 'anyOf' or 'oneOf', don't\n  // render a field and let the MultiSchemaField component handle the form display\n  if (!componentName && (schema.anyOf || schema.oneOf)) {\n    return () => null;\n  }\n\n  return componentName in fields\n    ? fields[componentName]\n    : () => {\n        const UnsupportedFieldTemplate = getTemplate<'UnsupportedFieldTemplate', T, S, F>(\n          'UnsupportedFieldTemplate',\n          registry,\n          uiOptions\n        );\n\n        return (\n          <UnsupportedFieldTemplate\n            schema={schema}\n            idSchema={idSchema}\n            reason={translateString(TranslatableString.UnknownFieldType, [String(schema.type)])}\n            registry={registry}\n          />\n        );\n      };\n}\n\n/** The `SchemaFieldRender` component is the work-horse of react-jsonschema-form, determining what kind of real field to\n * render based on the `schema`, `uiSchema` and all the other props. It also deals with rendering the `anyOf` and\n * `oneOf` fields.\n *\n * @param props - The `FieldProps` for this component\n */\nfunction SchemaFieldRender<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  props: FieldProps<T, S, F>\n) {\n  const {\n    schema: _schema,\n    idSchema: _idSchema,\n    uiSchema,\n    formData,\n    errorSchema,\n    idPrefix,\n    idSeparator,\n    name,\n    onChange,\n    onKeyChange,\n    onDropPropertyClick,\n    required,\n    registry,\n    wasPropertyKeyModified = false,\n  } = props;\n  const { formContext, schemaUtils, globalUiOptions } = registry;\n  const uiOptions = getUiOptions<T, S, F>(uiSchema, globalUiOptions);\n  const FieldTemplate = getTemplate<'FieldTemplate', T, S, F>('FieldTemplate', registry, uiOptions);\n  const DescriptionFieldTemplate = getTemplate<'DescriptionFieldTemplate', T, S, F>(\n    'DescriptionFieldTemplate',\n    registry,\n    uiOptions\n  );\n  const FieldHelpTemplate = getTemplate<'FieldHelpTemplate', T, S, F>('FieldHelpTemplate', registry, uiOptions);\n  const FieldErrorTemplate = getTemplate<'FieldErrorTemplate', T, S, F>('FieldErrorTemplate', registry, uiOptions);\n  const schema = schemaUtils.retrieveSchema(_schema, formData);\n  const fieldId = _idSchema[ID_KEY];\n  const idSchema = mergeObjects(\n    schemaUtils.toIdSchema(schema, fieldId, formData, idPrefix, idSeparator),\n    _idSchema\n  ) as IdSchema<T>;\n\n  /** Intermediary `onChange` handler for field components that will inject the `id` of the current field into the\n   * `onChange` chain if it is not already being provided from a deeper level in the hierarchy\n   */\n  const handleFieldComponentChange = useCallback(\n    (formData: T | undefined, newErrorSchema?: ErrorSchema<T>, id?: string) => {\n      const theId = id || fieldId;\n      return onChange(formData, newErrorSchema, theId);\n    },\n    [fieldId, onChange]\n  );\n\n  const FieldComponent = getFieldComponent<T, S, F>(schema, uiOptions, idSchema, registry);\n  const disabled = Boolean(props.disabled || uiOptions.disabled);\n  const readonly = Boolean(props.readonly || uiOptions.readonly || props.schema.readOnly || schema.readOnly);\n  const uiSchemaHideError = uiOptions.hideError;\n  // Set hideError to the value provided in the uiSchema, otherwise stick with the prop to propagate to children\n  const hideError = uiSchemaHideError === undefined ? props.hideError : Boolean(uiSchemaHideError);\n  const autofocus = Boolean(props.autofocus || uiOptions.autofocus);\n  if (Object.keys(schema).length === 0) {\n    return null;\n  }\n\n  const displayLabel = schemaUtils.getDisplayLabel(schema, uiSchema, globalUiOptions);\n\n  const { __errors, ...fieldErrorSchema } = errorSchema || {};\n  // See #439: uiSchema: Don't pass consumed class names or style to child components\n  const fieldUiSchema = omit(uiSchema, ['ui:classNames', 'classNames', 'ui:style']);\n  if (UI_OPTIONS_KEY in fieldUiSchema) {\n    fieldUiSchema[UI_OPTIONS_KEY] = omit(fieldUiSchema[UI_OPTIONS_KEY], ['classNames', 'style']);\n  }\n\n  const field = (\n    <FieldComponent\n      {...props}\n      onChange={handleFieldComponentChange}\n      idSchema={idSchema}\n      schema={schema}\n      uiSchema={fieldUiSchema}\n      disabled={disabled}\n      readonly={readonly}\n      hideError={hideError}\n      autofocus={autofocus}\n      errorSchema={fieldErrorSchema}\n      formContext={formContext}\n      rawErrors={__errors}\n    />\n  );\n\n  const id = idSchema[ID_KEY];\n\n  // If this schema has a title defined, but the user has set a new key/label, retain their input.\n  let label;\n  if (wasPropertyKeyModified) {\n    label = name;\n  } else {\n    label = ADDITIONAL_PROPERTY_FLAG in schema ? name : uiOptions.title || props.schema.title || schema.title || name;\n  }\n\n  const description = uiOptions.description || props.schema.description || schema.description || '';\n\n  const richDescription = uiOptions.enableMarkdownInDescription ? <Markdown>{description}</Markdown> : description;\n\n  const help = uiOptions.help;\n  const hidden = uiOptions.widget === 'hidden';\n\n  const classNames = ['form-group', 'field', `field-${getSchemaType(schema)}`];\n  if (!hideError && __errors && __errors.length > 0) {\n    classNames.push('field-error has-error has-danger');\n  }\n  if (uiSchema?.classNames) {\n    if (process.env.NODE_ENV !== 'production') {\n      console.warn(\n        \"'uiSchema.classNames' is deprecated and may be removed in a major release; Use 'ui:classNames' instead.\"\n      );\n    }\n    classNames.push(uiSchema.classNames);\n  }\n  if (uiOptions.classNames) {\n    classNames.push(uiOptions.classNames);\n  }\n\n  const helpComponent = (\n    <FieldHelpTemplate\n      help={help}\n      idSchema={idSchema}\n      schema={schema}\n      uiSchema={uiSchema}\n      hasErrors={!hideError && __errors && __errors.length > 0}\n      registry={registry}\n    />\n  );\n  /*\n   * AnyOf/OneOf errors handled by child schema\n   * unless it can be rendered as select control\n   */\n  const errorsComponent =\n    hideError || ((schema.anyOf || schema.oneOf) && !schemaUtils.isSelect(schema)) ? undefined : (\n      <FieldErrorTemplate\n        errors={__errors}\n        errorSchema={errorSchema}\n        idSchema={idSchema}\n        schema={schema}\n        uiSchema={uiSchema}\n        registry={registry}\n      />\n    );\n  const fieldProps: Omit<FieldTemplateProps<T, S, F>, 'children'> = {\n    description: (\n      <DescriptionFieldTemplate\n        id={descriptionId<T>(id)}\n        description={richDescription}\n        schema={schema}\n        uiSchema={uiSchema}\n        registry={registry}\n      />\n    ),\n    rawDescription: description,\n    help: helpComponent,\n    rawHelp: typeof help === 'string' ? help : undefined,\n    errors: errorsComponent,\n    rawErrors: hideError ? undefined : __errors,\n    id,\n    label,\n    hidden,\n    onChange,\n    onKeyChange,\n    onDropPropertyClick,\n    required,\n    disabled,\n    readonly,\n    hideError,\n    displayLabel,\n    classNames: classNames.join(' ').trim(),\n    style: uiOptions.style,\n    formContext,\n    formData,\n    schema,\n    uiSchema,\n    registry,\n  };\n\n  const _AnyOfField = registry.fields.AnyOfField;\n  const _OneOfField = registry.fields.OneOfField;\n  const isReplacingAnyOrOneOf = uiSchema?.['ui:field'] && uiSchema?.['ui:fieldReplacesAnyOrOneOf'] === true;\n\n  return (\n    <FieldTemplate {...fieldProps}>\n      <>\n        {field}\n        {/*\n        If the schema `anyOf` or 'oneOf' can be rendered as a select control, don't\n        render the selection and let `StringField` component handle\n        rendering\n      */}\n        {schema.anyOf && !isReplacingAnyOrOneOf && !schemaUtils.isSelect(schema) && (\n          <_AnyOfField\n            name={name}\n            disabled={disabled}\n            readonly={readonly}\n            hideError={hideError}\n            errorSchema={errorSchema}\n            formData={formData}\n            formContext={formContext}\n            idPrefix={idPrefix}\n            idSchema={idSchema}\n            idSeparator={idSeparator}\n            onBlur={props.onBlur}\n            onChange={props.onChange}\n            onFocus={props.onFocus}\n            options={schema.anyOf.map((_schema) =>\n              schemaUtils.retrieveSchema(isObject(_schema) ? (_schema as S) : ({} as S), formData)\n            )}\n            registry={registry}\n            schema={schema}\n            uiSchema={uiSchema}\n          />\n        )}\n        {schema.oneOf && !isReplacingAnyOrOneOf && !schemaUtils.isSelect(schema) && (\n          <_OneOfField\n            name={name}\n            disabled={disabled}\n            readonly={readonly}\n            hideError={hideError}\n            errorSchema={errorSchema}\n            formData={formData}\n            formContext={formContext}\n            idPrefix={idPrefix}\n            idSchema={idSchema}\n            idSeparator={idSeparator}\n            onBlur={props.onBlur}\n            onChange={props.onChange}\n            onFocus={props.onFocus}\n            options={schema.oneOf.map((_schema) =>\n              schemaUtils.retrieveSchema(isObject(_schema) ? (_schema as S) : ({} as S), formData)\n            )}\n            registry={registry}\n            schema={schema}\n            uiSchema={uiSchema}\n          />\n        )}\n      </>\n    </FieldTemplate>\n  );\n}\n\n/** The `SchemaField` component determines whether it is necessary to rerender the component based on any props changes\n * and if so, calls the `SchemaFieldRender` component with the props.\n */\nclass SchemaField<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any> extends Component<\n  FieldProps<T, S, F>\n> {\n  shouldComponentUpdate(nextProps: Readonly<FieldProps<T, S, F>>) {\n    return !deepEquals(this.props, nextProps);\n  }\n\n  render() {\n    return <SchemaFieldRender<T, S, F> {...this.props} />;\n  }\n}\n\nexport default SchemaField;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}