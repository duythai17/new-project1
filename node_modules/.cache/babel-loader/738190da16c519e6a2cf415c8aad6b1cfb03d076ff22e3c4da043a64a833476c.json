{"ast":null,"code":"import { jsx as _jsx } from \"react/jsx-runtime\";\nimport { useState, useCallback } from 'react';\nimport { asNumber } from '@rjsf/utils';\n// Matches a string that ends in a . character, optionally followed by a sequence of\n// digits followed by any number of 0 characters up until the end of the line.\n// Ensuring that there is at least one prefixed character is important so that\n// you don't incorrectly match against \"0\".\nconst trailingCharMatcherWithPrefix = /\\.([0-9]*0)*$/;\n// This is used for trimming the trailing 0 and . characters without affecting\n// the rest of the string. Its possible to use one RegEx with groups for this\n// functionality, but it is fairly complex compared to simply defining two\n// different matchers.\nconst trailingCharMatcher = /[0.]0*$/;\n/**\n * The NumberField class has some special handling for dealing with trailing\n * decimal points and/or zeroes. This logic is designed to allow trailing values\n * to be visible in the input element, but not be represented in the\n * corresponding form data.\n *\n * The algorithm is as follows:\n *\n * 1. When the input value changes the value is cached in the component state\n *\n * 2. The value is then normalized, removing trailing decimal points and zeros,\n *    then passed to the \"onChange\" callback\n *\n * 3. When the component is rendered, the formData value is checked against the\n *    value cached in the state. If it matches the cached value, the cached\n *    value is passed to the input instead of the formData value\n */\nfunction NumberField(props) {\n  const {\n    registry,\n    onChange,\n    formData,\n    value: initialValue\n  } = props;\n  const [lastValue, setLastValue] = useState(initialValue);\n  const {\n    StringField\n  } = registry.fields;\n  let value = formData;\n  /** Handle the change from the `StringField` to properly convert to a number\n   *\n   * @param value - The current value for the change occurring\n   */\n  const handleChange = useCallback(value => {\n    // Cache the original value in component state\n    setLastValue(value);\n    // Normalize decimals that don't start with a zero character in advance so\n    // that the rest of the normalization logic is simpler\n    if (`${value}`.charAt(0) === '.') {\n      value = `0${value}`;\n    }\n    // Check that the value is a string (this can happen if the widget used is a\n    // <select>, due to an enum declaration etc) then, if the value ends in a\n    // trailing decimal point or multiple zeroes, strip the trailing values\n    const processed = typeof value === 'string' && value.match(trailingCharMatcherWithPrefix) ? asNumber(value.replace(trailingCharMatcher, '')) : asNumber(value);\n    onChange(processed);\n  }, [onChange]);\n  if (typeof lastValue === 'string' && typeof value === 'number') {\n    // Construct a regular expression that checks for a string that consists\n    // of the formData value suffixed with zero or one '.' characters and zero\n    // or more '0' characters\n    const re = new RegExp(`${value}`.replace('.', '\\\\.') + '\\\\.?0*$');\n    // If the cached \"lastValue\" is a match, use that instead of the formData\n    // value to prevent the input value from changing in the UI\n    if (lastValue.match(re)) {\n      value = lastValue;\n    }\n  }\n  return _jsx(StringField, {\n    ...props,\n    formData: value,\n    onChange: handleChange\n  });\n}\nexport default NumberField;","map":{"version":3,"names":["useState","useCallback","asNumber","trailingCharMatcherWithPrefix","trailingCharMatcher","NumberField","props","registry","onChange","formData","value","initialValue","lastValue","setLastValue","StringField","fields","handleChange","charAt","processed","match","replace","re","RegExp","_jsx"],"sources":["D:\\Reactjs\\my-app\\node_modules\\@rjsf\\core\\src\\components\\fields\\NumberField.tsx"],"sourcesContent":["import { useState, useCallback } from 'react';\nimport { asNumber, FieldProps, FormContextType, RJSFSchema, StrictRJSFSchema } from '@rjsf/utils';\n\n// Matches a string that ends in a . character, optionally followed by a sequence of\n// digits followed by any number of 0 characters up until the end of the line.\n// Ensuring that there is at least one prefixed character is important so that\n// you don't incorrectly match against \"0\".\nconst trailingCharMatcherWithPrefix = /\\.([0-9]*0)*$/;\n\n// This is used for trimming the trailing 0 and . characters without affecting\n// the rest of the string. Its possible to use one RegEx with groups for this\n// functionality, but it is fairly complex compared to simply defining two\n// different matchers.\nconst trailingCharMatcher = /[0.]0*$/;\n\n/**\n * The NumberField class has some special handling for dealing with trailing\n * decimal points and/or zeroes. This logic is designed to allow trailing values\n * to be visible in the input element, but not be represented in the\n * corresponding form data.\n *\n * The algorithm is as follows:\n *\n * 1. When the input value changes the value is cached in the component state\n *\n * 2. The value is then normalized, removing trailing decimal points and zeros,\n *    then passed to the \"onChange\" callback\n *\n * 3. When the component is rendered, the formData value is checked against the\n *    value cached in the state. If it matches the cached value, the cached\n *    value is passed to the input instead of the formData value\n */\nfunction NumberField<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  props: FieldProps<T, S, F>\n) {\n  const { registry, onChange, formData, value: initialValue } = props;\n  const [lastValue, setLastValue] = useState(initialValue);\n  const { StringField } = registry.fields;\n\n  let value = formData;\n\n  /** Handle the change from the `StringField` to properly convert to a number\n   *\n   * @param value - The current value for the change occurring\n   */\n  const handleChange = useCallback(\n    (value: FieldProps<T, S, F>['value']) => {\n      // Cache the original value in component state\n      setLastValue(value);\n\n      // Normalize decimals that don't start with a zero character in advance so\n      // that the rest of the normalization logic is simpler\n      if (`${value}`.charAt(0) === '.') {\n        value = `0${value}`;\n      }\n\n      // Check that the value is a string (this can happen if the widget used is a\n      // <select>, due to an enum declaration etc) then, if the value ends in a\n      // trailing decimal point or multiple zeroes, strip the trailing values\n      const processed =\n        typeof value === 'string' && value.match(trailingCharMatcherWithPrefix)\n          ? asNumber(value.replace(trailingCharMatcher, ''))\n          : asNumber(value);\n\n      onChange(processed as unknown as T);\n    },\n    [onChange]\n  );\n\n  if (typeof lastValue === 'string' && typeof value === 'number') {\n    // Construct a regular expression that checks for a string that consists\n    // of the formData value suffixed with zero or one '.' characters and zero\n    // or more '0' characters\n    const re = new RegExp(`${value}`.replace('.', '\\\\.') + '\\\\.?0*$');\n\n    // If the cached \"lastValue\" is a match, use that instead of the formData\n    // value to prevent the input value from changing in the UI\n    if (lastValue.match(re)) {\n      value = lastValue as unknown as T;\n    }\n  }\n\n  return <StringField {...props} formData={value} onChange={handleChange} />;\n}\n\nexport default NumberField;\n"],"mappings":";AAAA,SAASA,QAAQ,EAAEC,WAAW,QAAQ,OAAO;AAC7C,SAASC,QAAQ,QAAmE,aAAa;AAEjG;AACA;AACA;AACA;AACA,MAAMC,6BAA6B,GAAG,eAAe;AAErD;AACA;AACA;AACA;AACA,MAAMC,mBAAmB,GAAG,SAAS;AAErC;;;;;;;;;;;;;;;;;AAiBA,SAASC,WAAWA,CAClBC,KAA0B;EAE1B,MAAM;IAAEC,QAAQ;IAAEC,QAAQ;IAAEC,QAAQ;IAAEC,KAAK,EAAEC;EAAY,CAAE,GAAGL,KAAK;EACnE,MAAM,CAACM,SAAS,EAAEC,YAAY,CAAC,GAAGb,QAAQ,CAACW,YAAY,CAAC;EACxD,MAAM;IAAEG;EAAW,CAAE,GAAGP,QAAQ,CAACQ,MAAM;EAEvC,IAAIL,KAAK,GAAGD,QAAQ;EAEpB;;;;EAIA,MAAMO,YAAY,GAAGf,WAAW,CAC7BS,KAAmC,IAAI;IACtC;IACAG,YAAY,CAACH,KAAK,CAAC;IAEnB;IACA;IACA,IAAI,GAAGA,KAAK,EAAE,CAACO,MAAM,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;MAChCP,KAAK,GAAG,IAAIA,KAAK,EAAE;;IAGrB;IACA;IACA;IACA,MAAMQ,SAAS,GACb,OAAOR,KAAK,KAAK,QAAQ,IAAIA,KAAK,CAACS,KAAK,CAAChB,6BAA6B,CAAC,GACnED,QAAQ,CAACQ,KAAK,CAACU,OAAO,CAAChB,mBAAmB,EAAE,EAAE,CAAC,CAAC,GAChDF,QAAQ,CAACQ,KAAK,CAAC;IAErBF,QAAQ,CAACU,SAAyB,CAAC;EACrC,CAAC,EACD,CAACV,QAAQ,CAAC,CACX;EAED,IAAI,OAAOI,SAAS,KAAK,QAAQ,IAAI,OAAOF,KAAK,KAAK,QAAQ,EAAE;IAC9D;IACA;IACA;IACA,MAAMW,EAAE,GAAG,IAAIC,MAAM,CAAC,GAAGZ,KAAK,EAAE,CAACU,OAAO,CAAC,GAAG,EAAE,KAAK,CAAC,GAAG,SAAS,CAAC;IAEjE;IACA;IACA,IAAIR,SAAS,CAACO,KAAK,CAACE,EAAE,CAAC,EAAE;MACvBX,KAAK,GAAGE,SAAyB;;;EAIrC,OAAOW,IAAA,CAACT,WAAW;IAAA,GAAKR,KAAK;IAAEG,QAAQ,EAAEC,KAAK;IAAEF,QAAQ,EAAEQ;EAAY,EAAI;AAC5E;AAEA,eAAeX,WAAW"},"metadata":{},"sourceType":"module","externalDependencies":[]}