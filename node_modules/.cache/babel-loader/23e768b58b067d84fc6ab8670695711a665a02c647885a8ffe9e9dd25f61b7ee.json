{"ast":null,"code":"import get from 'lodash/get';\nimport { createErrorHandler, getDefaultFormState, getUiOptions, PROPERTIES_KEY, toErrorSchema, unwrapErrorHandler, validationDataMerge } from '@rjsf/utils';\n/** Transforming the error output from ajv to format used by @rjsf/utils.\n * At some point, components should be updated to support ajv.\n *\n * @param errors - The list of AJV errors to convert to `RJSFValidationErrors`\n * @param [uiSchema] - An optional uiSchema that is passed to `transformErrors` and `customValidate`\n */\nexport function transformRJSFValidationErrors() {\n  let errors = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  let uiSchema = arguments.length > 1 ? arguments[1] : undefined;\n  return errors.map(e => {\n    const {\n      instancePath,\n      keyword,\n      params,\n      schemaPath,\n      parentSchema,\n      ...rest\n    } = e;\n    let {\n      message = ''\n    } = rest;\n    let property = instancePath.replace(/\\//g, '.');\n    let stack = \"\".concat(property, \" \").concat(message).trim();\n    if ('missingProperty' in params) {\n      property = property ? \"\".concat(property, \".\").concat(params.missingProperty) : params.missingProperty;\n      const currentProperty = params.missingProperty;\n      const uiSchemaTitle = getUiOptions(get(uiSchema, \"\".concat(property.replace(/^\\./, '')))).title;\n      if (uiSchemaTitle) {\n        message = message.replace(currentProperty, uiSchemaTitle);\n      } else {\n        const parentSchemaTitle = get(parentSchema, [PROPERTIES_KEY, currentProperty, 'title']);\n        if (parentSchemaTitle) {\n          message = message.replace(currentProperty, parentSchemaTitle);\n        }\n      }\n      stack = message;\n    } else {\n      const uiSchemaTitle = getUiOptions(get(uiSchema, \"\".concat(property.replace(/^\\./, '')))).title;\n      if (uiSchemaTitle) {\n        stack = \"'\".concat(uiSchemaTitle, \"' \").concat(message).trim();\n      } else {\n        const parentSchemaTitle = parentSchema === null || parentSchema === void 0 ? void 0 : parentSchema.title;\n        if (parentSchemaTitle) {\n          stack = \"'\".concat(parentSchemaTitle, \"' \").concat(message).trim();\n        }\n      }\n    }\n    // put data in expected format\n    return {\n      name: keyword,\n      property,\n      message,\n      params,\n      stack,\n      schemaPath\n    };\n  });\n}\n/** This function processes the `formData` with an optional user contributed `customValidate` function, which receives\n * the form data and a `errorHandler` function that will be used to add custom validation errors for each field. Also\n * supports a `transformErrors` function that will take the raw AJV validation errors, prior to custom validation and\n * transform them in what ever way it chooses.\n *\n * @param validator - The `ValidatorType` implementation used for the `getDefaultFormState()` call\n * @param rawErrors - The list of raw `ErrorObject`s to process\n * @param formData - The form data to validate\n * @param schema - The schema against which to validate the form data\n * @param [customValidate] - An optional function that is used to perform custom validation\n * @param [transformErrors] - An optional function that is used to transform errors after AJV validation\n * @param [uiSchema] - An optional uiSchema that is passed to `transformErrors` and `customValidate`\n */\nexport default function processRawValidationErrors(validator, rawErrors, formData, schema, customValidate, transformErrors, uiSchema) {\n  const {\n    validationError: invalidSchemaError\n  } = rawErrors;\n  let errors = transformRJSFValidationErrors(rawErrors.errors, uiSchema);\n  if (invalidSchemaError) {\n    errors = [...errors, {\n      stack: invalidSchemaError.message\n    }];\n  }\n  if (typeof transformErrors === 'function') {\n    errors = transformErrors(errors, uiSchema);\n  }\n  let errorSchema = toErrorSchema(errors);\n  if (invalidSchemaError) {\n    errorSchema = {\n      ...errorSchema,\n      $schema: {\n        __errors: [invalidSchemaError.message]\n      }\n    };\n  }\n  if (typeof customValidate !== 'function') {\n    return {\n      errors,\n      errorSchema\n    };\n  }\n  // Include form data with undefined values, which is required for custom validation.\n  const newFormData = getDefaultFormState(validator, schema, formData, schema, true);\n  const errorHandler = customValidate(newFormData, createErrorHandler(newFormData), uiSchema);\n  const userErrorSchema = unwrapErrorHandler(errorHandler);\n  return validationDataMerge({\n    errors,\n    errorSchema\n  }, userErrorSchema);\n}","map":{"version":3,"names":["get","createErrorHandler","getDefaultFormState","getUiOptions","PROPERTIES_KEY","toErrorSchema","unwrapErrorHandler","validationDataMerge","transformRJSFValidationErrors","errors","arguments","length","undefined","uiSchema","map","e","instancePath","keyword","params","schemaPath","parentSchema","rest","message","property","replace","stack","concat","trim","missingProperty","currentProperty","uiSchemaTitle","title","parentSchemaTitle","name","processRawValidationErrors","validator","rawErrors","formData","schema","customValidate","transformErrors","validationError","invalidSchemaError","errorSchema","$schema","__errors","newFormData","errorHandler","userErrorSchema"],"sources":["D:\\Reactjs\\my-app\\node_modules\\@rjsf\\validator-ajv8\\src\\processRawValidationErrors.ts"],"sourcesContent":["import { ErrorObject } from 'ajv';\nimport get from 'lodash/get';\nimport {\n  createErrorHandler,\n  CustomValidator,\n  ErrorTransformer,\n  FormContextType,\n  getDefaultFormState,\n  getUiOptions,\n  PROPERTIES_KEY,\n  RJSFSchema,\n  RJSFValidationError,\n  StrictRJSFSchema,\n  toErrorSchema,\n  UiSchema,\n  unwrapErrorHandler,\n  validationDataMerge,\n  ValidatorType,\n} from '@rjsf/utils';\n\nexport type RawValidationErrorsType<Result = any> = { errors?: Result[]; validationError?: Error };\n\n/** Transforming the error output from ajv to format used by @rjsf/utils.\n * At some point, components should be updated to support ajv.\n *\n * @param errors - The list of AJV errors to convert to `RJSFValidationErrors`\n * @param [uiSchema] - An optional uiSchema that is passed to `transformErrors` and `customValidate`\n */\nexport function transformRJSFValidationErrors<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(errors: ErrorObject[] = [], uiSchema?: UiSchema<T, S, F>): RJSFValidationError[] {\n  return errors.map((e: ErrorObject) => {\n    const { instancePath, keyword, params, schemaPath, parentSchema, ...rest } = e;\n    let { message = '' } = rest;\n    let property = instancePath.replace(/\\//g, '.');\n    let stack = `${property} ${message}`.trim();\n\n    if ('missingProperty' in params) {\n      property = property ? `${property}.${params.missingProperty}` : params.missingProperty;\n      const currentProperty: string = params.missingProperty;\n      const uiSchemaTitle = getUiOptions(get(uiSchema, `${property.replace(/^\\./, '')}`)).title;\n\n      if (uiSchemaTitle) {\n        message = message.replace(currentProperty, uiSchemaTitle);\n      } else {\n        const parentSchemaTitle = get(parentSchema, [PROPERTIES_KEY, currentProperty, 'title']);\n\n        if (parentSchemaTitle) {\n          message = message.replace(currentProperty, parentSchemaTitle);\n        }\n      }\n\n      stack = message;\n    } else {\n      const uiSchemaTitle = getUiOptions<T, S, F>(get(uiSchema, `${property.replace(/^\\./, '')}`)).title;\n\n      if (uiSchemaTitle) {\n        stack = `'${uiSchemaTitle}' ${message}`.trim();\n      } else {\n        const parentSchemaTitle = parentSchema?.title;\n\n        if (parentSchemaTitle) {\n          stack = `'${parentSchemaTitle}' ${message}`.trim();\n        }\n      }\n    }\n\n    // put data in expected format\n    return {\n      name: keyword,\n      property,\n      message,\n      params, // specific to ajv\n      stack,\n      schemaPath,\n    };\n  });\n}\n\n/** This function processes the `formData` with an optional user contributed `customValidate` function, which receives\n * the form data and a `errorHandler` function that will be used to add custom validation errors for each field. Also\n * supports a `transformErrors` function that will take the raw AJV validation errors, prior to custom validation and\n * transform them in what ever way it chooses.\n *\n * @param validator - The `ValidatorType` implementation used for the `getDefaultFormState()` call\n * @param rawErrors - The list of raw `ErrorObject`s to process\n * @param formData - The form data to validate\n * @param schema - The schema against which to validate the form data\n * @param [customValidate] - An optional function that is used to perform custom validation\n * @param [transformErrors] - An optional function that is used to transform errors after AJV validation\n * @param [uiSchema] - An optional uiSchema that is passed to `transformErrors` and `customValidate`\n */\nexport default function processRawValidationErrors<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(\n  validator: ValidatorType<T, S, F>,\n  rawErrors: RawValidationErrorsType<ErrorObject>,\n  formData: T | undefined,\n  schema: S,\n  customValidate?: CustomValidator<T, S, F>,\n  transformErrors?: ErrorTransformer<T, S, F>,\n  uiSchema?: UiSchema<T, S, F>\n) {\n  const { validationError: invalidSchemaError } = rawErrors;\n  let errors = transformRJSFValidationErrors<T, S, F>(rawErrors.errors, uiSchema);\n\n  if (invalidSchemaError) {\n    errors = [...errors, { stack: invalidSchemaError!.message }];\n  }\n  if (typeof transformErrors === 'function') {\n    errors = transformErrors(errors, uiSchema);\n  }\n\n  let errorSchema = toErrorSchema<T>(errors);\n\n  if (invalidSchemaError) {\n    errorSchema = {\n      ...errorSchema,\n      $schema: {\n        __errors: [invalidSchemaError!.message],\n      },\n    };\n  }\n\n  if (typeof customValidate !== 'function') {\n    return { errors, errorSchema };\n  }\n\n  // Include form data with undefined values, which is required for custom validation.\n  const newFormData = getDefaultFormState<T, S, F>(validator, schema, formData, schema, true) as T;\n\n  const errorHandler = customValidate(newFormData, createErrorHandler<T>(newFormData), uiSchema);\n  const userErrorSchema = unwrapErrorHandler<T>(errorHandler);\n  return validationDataMerge<T>({ errors, errorSchema }, userErrorSchema);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}