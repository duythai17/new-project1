{"ast":null,"code":"import { jsx as _jsx, jsxs as _jsxs } from \"react/jsx-runtime\";\nimport { Component } from 'react';\nimport { getTemplate, getUiOptions, orderProperties, TranslatableString, ADDITIONAL_PROPERTY_FLAG, PROPERTIES_KEY, REF_KEY, ANY_OF_KEY, ONE_OF_KEY } from '@rjsf/utils';\nimport Markdown from 'markdown-to-jsx';\nimport get from 'lodash/get';\nimport has from 'lodash/has';\nimport isObject from 'lodash/isObject';\nimport set from 'lodash/set';\nimport unset from 'lodash/unset';\n/** The `ObjectField` component is used to render a field in the schema that is of type `object`. It tracks whether an\n * additional property key was modified and what it was modified to\n *\n * @param props - The `FieldProps` for this template\n */\nclass ObjectField extends Component {\n  constructor() {\n    var _this;\n    /** Set up the initial state */\n    super(...arguments);\n    _this = this;\n    this.state = {\n      wasPropertyKeyModified: false,\n      additionalProperties: {}\n    };\n    /** Returns the `onPropertyChange` handler for the `name` field. Handles the special case where a user is attempting\n     * to clear the data for a field added as an additional property. Calls the `onChange()` handler with the updated\n     * formData.\n     *\n     * @param name - The name of the property\n     * @param addedByAdditionalProperties - Flag indicating whether this property is an additional property\n     * @returns - The onPropertyChange callback for the `name` property\n     */\n    this.onPropertyChange = function (name) {\n      let addedByAdditionalProperties = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      return (value, newErrorSchema, id) => {\n        const {\n          formData,\n          onChange,\n          errorSchema\n        } = _this.props;\n        if (value === undefined && addedByAdditionalProperties) {\n          // Don't set value = undefined for fields added by\n          // additionalProperties. Doing so removes them from the\n          // formData, which causes them to completely disappear\n          // (including the input field for the property name). Unlike\n          // fields which are \"mandated\" by the schema, these fields can\n          // be set to undefined by clicking a \"delete field\" button, so\n          // set empty values to the empty string.\n          value = '';\n        }\n        const newFormData = {\n          ...formData,\n          [name]: value\n        };\n        onChange(newFormData, errorSchema && errorSchema && {\n          ...errorSchema,\n          [name]: newErrorSchema\n        }, id);\n      };\n    };\n    /** Returns a callback to handle the onDropPropertyClick event for the given `key` which removes the old `key` data\n     * and calls the `onChange` callback with it\n     *\n     * @param key - The key for which the drop callback is desired\n     * @returns - The drop property click callback\n     */\n    this.onDropPropertyClick = key => {\n      return event => {\n        event.preventDefault();\n        const {\n          onChange,\n          formData\n        } = this.props;\n        const copiedFormData = {\n          ...formData\n        };\n        unset(copiedFormData, key);\n        onChange(copiedFormData);\n      };\n    };\n    /** Computes the next available key name from the `preferredKey`, indexing through the already existing keys until one\n     * that is already not assigned is found.\n     *\n     * @param preferredKey - The preferred name of a new key\n     * @param [formData] - The form data in which to check if the desired key already exists\n     * @returns - The name of the next available key from `preferredKey`\n     */\n    this.getAvailableKey = (preferredKey, formData) => {\n      const {\n        uiSchema,\n        registry\n      } = this.props;\n      const {\n        duplicateKeySuffixSeparator = '-'\n      } = getUiOptions(uiSchema, registry.globalUiOptions);\n      let index = 0;\n      let newKey = preferredKey;\n      while (has(formData, newKey)) {\n        newKey = \"\".concat(preferredKey).concat(duplicateKeySuffixSeparator).concat(++index);\n      }\n      return newKey;\n    };\n    /** Returns a callback function that deals with the rename of a key for an additional property for a schema. That\n     * callback will attempt to rename the key and move the existing data to that key, calling `onChange` when it does.\n     *\n     * @param oldValue - The old value of a field\n     * @returns - The key change callback function\n     */\n    this.onKeyChange = oldValue => {\n      return (value, newErrorSchema) => {\n        if (oldValue === value) {\n          return;\n        }\n        const {\n          formData,\n          onChange,\n          errorSchema\n        } = this.props;\n        value = this.getAvailableKey(value, formData);\n        const newFormData = {\n          ...formData\n        };\n        const newKeys = {\n          [oldValue]: value\n        };\n        const keyValues = Object.keys(newFormData).map(key => {\n          const newKey = newKeys[key] || key;\n          return {\n            [newKey]: newFormData[key]\n          };\n        });\n        const renamedObj = Object.assign({}, ...keyValues);\n        this.setState({\n          wasPropertyKeyModified: true\n        });\n        onChange(renamedObj, errorSchema && errorSchema && {\n          ...errorSchema,\n          [value]: newErrorSchema\n        });\n      };\n    };\n    /** Handles the adding of a new additional property on the given `schema`. Calls the `onChange` callback once the new\n     * default data for that field has been added to the formData.\n     *\n     * @param schema - The schema element to which the new property is being added\n     */\n    this.handleAddClick = schema => () => {\n      if (!schema.additionalProperties) {\n        return;\n      }\n      const {\n        formData,\n        onChange,\n        registry\n      } = this.props;\n      const newFormData = {\n        ...formData\n      };\n      let type = undefined;\n      if (isObject(schema.additionalProperties)) {\n        type = schema.additionalProperties.type;\n        let apSchema = schema.additionalProperties;\n        if (REF_KEY in apSchema) {\n          const {\n            schemaUtils\n          } = registry;\n          apSchema = schemaUtils.retrieveSchema({\n            $ref: apSchema[REF_KEY]\n          }, formData);\n          type = apSchema.type;\n        }\n        if (!type && (ANY_OF_KEY in apSchema || ONE_OF_KEY in apSchema)) {\n          type = 'object';\n        }\n      }\n      const newKey = this.getAvailableKey('newKey', newFormData);\n      // Cast this to make the `set` work properly\n      set(newFormData, newKey, this.getDefaultValue(type));\n      onChange(newFormData);\n    };\n  }\n  /** Returns a flag indicating whether the `name` field is required in the object schema\n   *\n   * @param name - The name of the field to check for required-ness\n   * @returns - True if the field `name` is required, false otherwise\n   */\n  isRequired(name) {\n    const {\n      schema\n    } = this.props;\n    return Array.isArray(schema.required) && schema.required.indexOf(name) !== -1;\n  }\n  /** Returns a default value to be used for a new additional schema property of the given `type`\n   *\n   * @param type - The type of the new additional schema property\n   */\n  getDefaultValue(type) {\n    const {\n      registry: {\n        translateString\n      }\n    } = this.props;\n    switch (type) {\n      case 'array':\n        return [];\n      case 'boolean':\n        return false;\n      case 'null':\n        return null;\n      case 'number':\n        return 0;\n      case 'object':\n        return {};\n      case 'string':\n      default:\n        // We don't have a datatype for some reason (perhaps additionalProperties was true)\n        return translateString(TranslatableString.NewStringDefault);\n    }\n  }\n  /** Renders the `ObjectField` from the given props\n   */\n  render() {\n    var _a, _b, _c;\n    const {\n      schema: rawSchema,\n      uiSchema = {},\n      formData,\n      errorSchema,\n      idSchema,\n      name,\n      required = false,\n      disabled = false,\n      readonly = false,\n      hideError,\n      idPrefix,\n      idSeparator,\n      onBlur,\n      onFocus,\n      registry\n    } = this.props;\n    const {\n      fields,\n      formContext,\n      schemaUtils,\n      translateString,\n      globalUiOptions\n    } = registry;\n    const {\n      SchemaField\n    } = fields;\n    const schema = schemaUtils.retrieveSchema(rawSchema, formData);\n    const uiOptions = getUiOptions(uiSchema, globalUiOptions);\n    const {\n      properties: schemaProperties = {}\n    } = schema;\n    const title = (_b = (_a = uiOptions.title) !== null && _a !== void 0 ? _a : schema.title) !== null && _b !== void 0 ? _b : name;\n    const description = (_c = uiOptions.description) !== null && _c !== void 0 ? _c : schema.description;\n    let orderedProperties;\n    try {\n      const properties = Object.keys(schemaProperties);\n      orderedProperties = orderProperties(properties, uiOptions.order);\n    } catch (err) {\n      return _jsxs(\"div\", {\n        children: [_jsx(\"p\", {\n          className: 'config-error',\n          style: {\n            color: 'red'\n          },\n          children: _jsx(Markdown, {\n            children: translateString(TranslatableString.InvalidObjectField, [name || 'root', err.message])\n          })\n        }), _jsx(\"pre\", {\n          children: JSON.stringify(schema)\n        })]\n      });\n    }\n    const Template = getTemplate('ObjectFieldTemplate', registry, uiOptions);\n    const templateProps = {\n      // getDisplayLabel() always returns false for object types, so just check the `uiOptions.label`\n      title: uiOptions.label === false ? '' : title,\n      description: uiOptions.label === false ? undefined : description,\n      properties: orderedProperties.map(name => {\n        const addedByAdditionalProperties = has(schema, [PROPERTIES_KEY, name, ADDITIONAL_PROPERTY_FLAG]);\n        const fieldUiSchema = addedByAdditionalProperties ? uiSchema.additionalProperties : uiSchema[name];\n        const hidden = getUiOptions(fieldUiSchema).widget === 'hidden';\n        const fieldIdSchema = get(idSchema, [name], {});\n        return {\n          content: _jsx(SchemaField, {\n            name: name,\n            required: this.isRequired(name),\n            schema: get(schema, [PROPERTIES_KEY, name], {}),\n            uiSchema: fieldUiSchema,\n            errorSchema: get(errorSchema, name),\n            idSchema: fieldIdSchema,\n            idPrefix: idPrefix,\n            idSeparator: idSeparator,\n            formData: get(formData, name),\n            formContext: formContext,\n            wasPropertyKeyModified: this.state.wasPropertyKeyModified,\n            onKeyChange: this.onKeyChange(name),\n            onChange: this.onPropertyChange(name, addedByAdditionalProperties),\n            onBlur: onBlur,\n            onFocus: onFocus,\n            registry: registry,\n            disabled: disabled,\n            readonly: readonly,\n            hideError: hideError,\n            onDropPropertyClick: this.onDropPropertyClick\n          }, name),\n          name,\n          readonly,\n          disabled,\n          required,\n          hidden\n        };\n      }),\n      readonly,\n      disabled,\n      required,\n      idSchema,\n      uiSchema,\n      errorSchema,\n      schema,\n      formData,\n      formContext,\n      registry\n    };\n    return _jsx(Template, {\n      ...templateProps,\n      onAddClick: this.handleAddClick\n    });\n  }\n}\nexport default ObjectField;","map":{"version":3,"names":["Component","getTemplate","getUiOptions","orderProperties","TranslatableString","ADDITIONAL_PROPERTY_FLAG","PROPERTIES_KEY","REF_KEY","ANY_OF_KEY","ONE_OF_KEY","Markdown","get","has","isObject","set","unset","ObjectField","constructor","_this","state","wasPropertyKeyModified","additionalProperties","onPropertyChange","name","addedByAdditionalProperties","arguments","length","undefined","value","newErrorSchema","id","formData","onChange","errorSchema","props","newFormData","onDropPropertyClick","key","event","preventDefault","copiedFormData","getAvailableKey","preferredKey","uiSchema","registry","duplicateKeySuffixSeparator","globalUiOptions","index","newKey","concat","onKeyChange","oldValue","newKeys","keyValues","Object","keys","map","renamedObj","assign","setState","handleAddClick","schema","type","apSchema","schemaUtils","retrieveSchema","$ref","getDefaultValue","isRequired","Array","isArray","required","indexOf","translateString","NewStringDefault","render","rawSchema","idSchema","disabled","readonly","hideError","idPrefix","idSeparator","onBlur","onFocus","fields","formContext","SchemaField","uiOptions","properties","schemaProperties","title","_b","_a","description","_c","orderedProperties","order","err","_jsxs","children","_jsx","className","style","color","InvalidObjectField","message","JSON","stringify","Template","templateProps","label","fieldUiSchema","hidden","widget","fieldIdSchema","content","onAddClick"],"sources":["D:\\Reactjs\\my-app\\node_modules\\@rjsf\\core\\src\\components\\fields\\ObjectField.tsx"],"sourcesContent":["import { Component } from 'react';\nimport {\n  getTemplate,\n  getUiOptions,\n  orderProperties,\n  ErrorSchema,\n  FieldProps,\n  FormContextType,\n  GenericObjectType,\n  IdSchema,\n  RJSFSchema,\n  StrictRJSFSchema,\n  TranslatableString,\n  ADDITIONAL_PROPERTY_FLAG,\n  PROPERTIES_KEY,\n  REF_KEY,\n  ANY_OF_KEY,\n  ONE_OF_KEY,\n} from '@rjsf/utils';\nimport Markdown from 'markdown-to-jsx';\nimport get from 'lodash/get';\nimport has from 'lodash/has';\nimport isObject from 'lodash/isObject';\nimport set from 'lodash/set';\nimport unset from 'lodash/unset';\n\n/** Type used for the state of the `ObjectField` component */\ntype ObjectFieldState = {\n  /** Flag indicating whether an additional property key was modified */\n  wasPropertyKeyModified: boolean;\n  /** The set of additional properties */\n  additionalProperties: object;\n};\n\n/** The `ObjectField` component is used to render a field in the schema that is of type `object`. It tracks whether an\n * additional property key was modified and what it was modified to\n *\n * @param props - The `FieldProps` for this template\n */\nclass ObjectField<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any> extends Component<\n  FieldProps<T, S, F>,\n  ObjectFieldState\n> {\n  /** Set up the initial state */\n  state = {\n    wasPropertyKeyModified: false,\n    additionalProperties: {},\n  };\n\n  /** Returns a flag indicating whether the `name` field is required in the object schema\n   *\n   * @param name - The name of the field to check for required-ness\n   * @returns - True if the field `name` is required, false otherwise\n   */\n  isRequired(name: string) {\n    const { schema } = this.props;\n    return Array.isArray(schema.required) && schema.required.indexOf(name) !== -1;\n  }\n\n  /** Returns the `onPropertyChange` handler for the `name` field. Handles the special case where a user is attempting\n   * to clear the data for a field added as an additional property. Calls the `onChange()` handler with the updated\n   * formData.\n   *\n   * @param name - The name of the property\n   * @param addedByAdditionalProperties - Flag indicating whether this property is an additional property\n   * @returns - The onPropertyChange callback for the `name` property\n   */\n  onPropertyChange = (name: string, addedByAdditionalProperties = false) => {\n    return (value: T | undefined, newErrorSchema?: ErrorSchema<T>, id?: string) => {\n      const { formData, onChange, errorSchema } = this.props;\n      if (value === undefined && addedByAdditionalProperties) {\n        // Don't set value = undefined for fields added by\n        // additionalProperties. Doing so removes them from the\n        // formData, which causes them to completely disappear\n        // (including the input field for the property name). Unlike\n        // fields which are \"mandated\" by the schema, these fields can\n        // be set to undefined by clicking a \"delete field\" button, so\n        // set empty values to the empty string.\n        value = '' as unknown as T;\n      }\n      const newFormData = { ...formData, [name]: value } as unknown as T;\n      onChange(\n        newFormData,\n        errorSchema &&\n          errorSchema && {\n            ...errorSchema,\n            [name]: newErrorSchema,\n          },\n        id\n      );\n    };\n  };\n\n  /** Returns a callback to handle the onDropPropertyClick event for the given `key` which removes the old `key` data\n   * and calls the `onChange` callback with it\n   *\n   * @param key - The key for which the drop callback is desired\n   * @returns - The drop property click callback\n   */\n  onDropPropertyClick = (key: string) => {\n    return (event: DragEvent) => {\n      event.preventDefault();\n      const { onChange, formData } = this.props;\n      const copiedFormData = { ...formData } as T;\n      unset(copiedFormData, key);\n      onChange(copiedFormData);\n    };\n  };\n\n  /** Computes the next available key name from the `preferredKey`, indexing through the already existing keys until one\n   * that is already not assigned is found.\n   *\n   * @param preferredKey - The preferred name of a new key\n   * @param [formData] - The form data in which to check if the desired key already exists\n   * @returns - The name of the next available key from `preferredKey`\n   */\n  getAvailableKey = (preferredKey: string, formData?: T) => {\n    const { uiSchema, registry } = this.props;\n    const { duplicateKeySuffixSeparator = '-' } = getUiOptions<T, S, F>(uiSchema, registry.globalUiOptions);\n\n    let index = 0;\n    let newKey = preferredKey;\n    while (has(formData, newKey)) {\n      newKey = `${preferredKey}${duplicateKeySuffixSeparator}${++index}`;\n    }\n    return newKey;\n  };\n\n  /** Returns a callback function that deals with the rename of a key for an additional property for a schema. That\n   * callback will attempt to rename the key and move the existing data to that key, calling `onChange` when it does.\n   *\n   * @param oldValue - The old value of a field\n   * @returns - The key change callback function\n   */\n  onKeyChange = (oldValue: any) => {\n    return (value: any, newErrorSchema: ErrorSchema<T>) => {\n      if (oldValue === value) {\n        return;\n      }\n      const { formData, onChange, errorSchema } = this.props;\n\n      value = this.getAvailableKey(value, formData);\n      const newFormData: GenericObjectType = {\n        ...(formData as GenericObjectType),\n      };\n      const newKeys: GenericObjectType = { [oldValue]: value };\n      const keyValues = Object.keys(newFormData).map((key) => {\n        const newKey = newKeys[key] || key;\n        return { [newKey]: newFormData[key] };\n      });\n      const renamedObj = Object.assign({}, ...keyValues);\n\n      this.setState({ wasPropertyKeyModified: true });\n\n      onChange(\n        renamedObj,\n        errorSchema &&\n          errorSchema && {\n            ...errorSchema,\n            [value]: newErrorSchema,\n          }\n      );\n    };\n  };\n\n  /** Returns a default value to be used for a new additional schema property of the given `type`\n   *\n   * @param type - The type of the new additional schema property\n   */\n  getDefaultValue(type?: RJSFSchema['type']) {\n    const {\n      registry: { translateString },\n    } = this.props;\n    switch (type) {\n      case 'array':\n        return [];\n      case 'boolean':\n        return false;\n      case 'null':\n        return null;\n      case 'number':\n        return 0;\n      case 'object':\n        return {};\n      case 'string':\n      default:\n        // We don't have a datatype for some reason (perhaps additionalProperties was true)\n        return translateString(TranslatableString.NewStringDefault);\n    }\n  }\n\n  /** Handles the adding of a new additional property on the given `schema`. Calls the `onChange` callback once the new\n   * default data for that field has been added to the formData.\n   *\n   * @param schema - The schema element to which the new property is being added\n   */\n  handleAddClick = (schema: S) => () => {\n    if (!schema.additionalProperties) {\n      return;\n    }\n    const { formData, onChange, registry } = this.props;\n    const newFormData = { ...formData } as T;\n\n    let type: RJSFSchema['type'] = undefined;\n    if (isObject(schema.additionalProperties)) {\n      type = schema.additionalProperties.type;\n      let apSchema = schema.additionalProperties;\n      if (REF_KEY in apSchema) {\n        const { schemaUtils } = registry;\n        apSchema = schemaUtils.retrieveSchema({ $ref: apSchema[REF_KEY] } as S, formData);\n        type = apSchema.type;\n      }\n      if (!type && (ANY_OF_KEY in apSchema || ONE_OF_KEY in apSchema)) {\n        type = 'object';\n      }\n    }\n\n    const newKey = this.getAvailableKey('newKey', newFormData);\n    // Cast this to make the `set` work properly\n    set(newFormData as GenericObjectType, newKey, this.getDefaultValue(type));\n\n    onChange(newFormData);\n  };\n\n  /** Renders the `ObjectField` from the given props\n   */\n  render() {\n    const {\n      schema: rawSchema,\n      uiSchema = {},\n      formData,\n      errorSchema,\n      idSchema,\n      name,\n      required = false,\n      disabled = false,\n      readonly = false,\n      hideError,\n      idPrefix,\n      idSeparator,\n      onBlur,\n      onFocus,\n      registry,\n    } = this.props;\n\n    const { fields, formContext, schemaUtils, translateString, globalUiOptions } = registry;\n    const { SchemaField } = fields;\n    const schema: S = schemaUtils.retrieveSchema(rawSchema, formData);\n    const uiOptions = getUiOptions<T, S, F>(uiSchema, globalUiOptions);\n    const { properties: schemaProperties = {} } = schema;\n\n    const title = uiOptions.title ?? schema.title ?? name;\n    const description = uiOptions.description ?? schema.description;\n    let orderedProperties: string[];\n    try {\n      const properties = Object.keys(schemaProperties);\n      orderedProperties = orderProperties(properties, uiOptions.order);\n    } catch (err) {\n      return (\n        <div>\n          <p className='config-error' style={{ color: 'red' }}>\n            <Markdown>\n              {translateString(TranslatableString.InvalidObjectField, [name || 'root', (err as Error).message])}\n            </Markdown>\n          </p>\n          <pre>{JSON.stringify(schema)}</pre>\n        </div>\n      );\n    }\n\n    const Template = getTemplate<'ObjectFieldTemplate', T, S, F>('ObjectFieldTemplate', registry, uiOptions);\n\n    const templateProps = {\n      // getDisplayLabel() always returns false for object types, so just check the `uiOptions.label`\n      title: uiOptions.label === false ? '' : title,\n      description: uiOptions.label === false ? undefined : description,\n      properties: orderedProperties.map((name) => {\n        const addedByAdditionalProperties = has(schema, [PROPERTIES_KEY, name, ADDITIONAL_PROPERTY_FLAG]);\n        const fieldUiSchema = addedByAdditionalProperties ? uiSchema.additionalProperties : uiSchema[name];\n        const hidden = getUiOptions<T, S, F>(fieldUiSchema).widget === 'hidden';\n        const fieldIdSchema: IdSchema<T> = get(idSchema, [name], {});\n\n        return {\n          content: (\n            <SchemaField\n              key={name}\n              name={name}\n              required={this.isRequired(name)}\n              schema={get(schema, [PROPERTIES_KEY, name], {})}\n              uiSchema={fieldUiSchema}\n              errorSchema={get(errorSchema, name)}\n              idSchema={fieldIdSchema}\n              idPrefix={idPrefix}\n              idSeparator={idSeparator}\n              formData={get(formData, name)}\n              formContext={formContext}\n              wasPropertyKeyModified={this.state.wasPropertyKeyModified}\n              onKeyChange={this.onKeyChange(name)}\n              onChange={this.onPropertyChange(name, addedByAdditionalProperties)}\n              onBlur={onBlur}\n              onFocus={onFocus}\n              registry={registry}\n              disabled={disabled}\n              readonly={readonly}\n              hideError={hideError}\n              onDropPropertyClick={this.onDropPropertyClick}\n            />\n          ),\n          name,\n          readonly,\n          disabled,\n          required,\n          hidden,\n        };\n      }),\n      readonly,\n      disabled,\n      required,\n      idSchema,\n      uiSchema,\n      errorSchema,\n      schema,\n      formData,\n      formContext,\n      registry,\n    };\n    return <Template {...templateProps} onAddClick={this.handleAddClick} />;\n  }\n}\n\nexport default ObjectField;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}