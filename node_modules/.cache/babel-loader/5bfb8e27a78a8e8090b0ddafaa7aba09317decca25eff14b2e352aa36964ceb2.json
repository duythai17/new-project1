{"ast":null,"code":"import get from 'lodash/get';\nimport has from 'lodash/has';\nimport isNumber from 'lodash/isNumber';\nimport isObject from 'lodash/isObject';\nimport isString from 'lodash/isString';\nimport reduce from 'lodash/reduce';\nimport times from 'lodash/times';\nimport getFirstMatchingOption from './getFirstMatchingOption';\nimport retrieveSchema, { resolveAllReferences } from './retrieveSchema';\nimport { ONE_OF_KEY, REF_KEY, JUNK_OPTION_ID, ANY_OF_KEY } from '../constants';\nimport guessType from '../guessType';\nimport getDiscriminatorFieldFromSchema from '../getDiscriminatorFieldFromSchema';\nimport getOptionMatchingSimpleDiscriminator from '../getOptionMatchingSimpleDiscriminator';\n/** A junk option used to determine when the getFirstMatchingOption call really matches an option rather than returning\n * the first item\n */\nexport const JUNK_OPTION = {\n  type: 'object',\n  $id: JUNK_OPTION_ID,\n  properties: {\n    __not_really_there__: {\n      type: 'number'\n    }\n  }\n};\n/** Recursive function that calculates the score of a `formData` against the given `schema`. The computation is fairly\n * simple. Initially the total score is 0. When `schema.properties` object exists, then all the `key/value` pairs within\n * the object are processed as follows after obtaining the formValue from `formData` using the `key`:\n * - If the `value` contains a `$ref`, `calculateIndexScore()` is called recursively with the formValue and the new\n *   schema that is the result of the ref in the schema being resolved and that sub-schema's resulting score is added to\n *   the total.\n * - If the `value` contains a `oneOf` and there is a formValue, then score based on the index returned from calling\n *   `getClosestMatchingOption()` of that oneOf.\n * - If the type of the `value` is 'object', `calculateIndexScore()` is called recursively with the formValue and the\n *   `value` itself as the sub-schema, and the score is added to the total.\n * - If the type of the `value` matches the guessed-type of the `formValue`, the score is incremented by 1, UNLESS the\n *   value has a `default` or `const`. In those case, if the `default` or `const` and the `formValue` match, the score\n *   is incremented by another 1 otherwise it is decremented by 1.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param rootSchema - The root JSON schema of the entire form\n * @param schema - The schema for which the score is being calculated\n * @param formData - The form data associated with the schema, used to calculate the score\n * @returns - The score a schema against the formData\n */\nexport function calculateIndexScore(validator, rootSchema, schema, formData = {}) {\n  let totalScore = 0;\n  if (schema) {\n    if (isObject(schema.properties)) {\n      totalScore += reduce(schema.properties, (score, value, key) => {\n        const formValue = get(formData, key);\n        if (typeof value === 'boolean') {\n          return score;\n        }\n        if (has(value, REF_KEY)) {\n          const newSchema = retrieveSchema(validator, value, rootSchema, formValue);\n          return score + calculateIndexScore(validator, rootSchema, newSchema, formValue || {});\n        }\n        if ((has(value, ONE_OF_KEY) || has(value, ANY_OF_KEY)) && formValue) {\n          const key = has(value, ONE_OF_KEY) ? ONE_OF_KEY : ANY_OF_KEY;\n          const discriminator = getDiscriminatorFieldFromSchema(value);\n          return score + getClosestMatchingOption(validator, rootSchema, formValue, get(value, key), -1, discriminator);\n        }\n        if (value.type === 'object') {\n          return score + calculateIndexScore(validator, rootSchema, value, formValue || {});\n        }\n        if (value.type === guessType(formValue)) {\n          // If the types match, then we bump the score by one\n          let newScore = score + 1;\n          if (value.default) {\n            // If the schema contains a readonly default value score the value that matches the default higher and\n            // any non-matching value lower\n            newScore += formValue === value.default ? 1 : -1;\n          } else if (value.const) {\n            // If the schema contains a const value score the value that matches the default higher and\n            // any non-matching value lower\n            newScore += formValue === value.const ? 1 : -1;\n          }\n          // TODO eventually, deal with enums/arrays\n          return newScore;\n        }\n        return score;\n      }, 0);\n    } else if (isString(schema.type) && schema.type === guessType(formData)) {\n      totalScore += 1;\n    }\n  }\n  return totalScore;\n}\n/** Determines which of the given `options` provided most closely matches the `formData`. Using\n * `getFirstMatchingOption()` to match two schemas that differ only by the readOnly, default or const value of a field\n * based on the `formData` and returns 0 when there is no match. Rather than passing in all the `options` at once to\n * this utility, instead an array of valid option indexes is created by iterating over the list of options, call\n * `getFirstMatchingOptions` with a list of one junk option and one good option, seeing if the good option is considered\n * matched.\n *\n * Once the list of valid indexes is created, if there is only one valid index, just return it. Otherwise, if there are\n * no valid indexes, then fill the valid indexes array with the indexes of all the options. Next, the index of the\n * option with the highest score is determined by iterating over the list of valid options, calling\n * `calculateIndexScore()` on each, comparing it against the current best score, and returning the index of the one that\n * eventually has the best score.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param rootSchema - The root JSON schema of the entire form\n * @param formData - The form data associated with the schema\n * @param options - The list of options that can be selected from\n * @param [selectedOption=-1] - The index of the currently selected option, defaulted to -1 if not specified\n * @param [discriminatorField] - The optional name of the field within the options object whose value is used to\n *          determine which option is selected\n * @returns - The index of the option that is the closest match to the `formData` or the `selectedOption` if no match\n */\nexport default function getClosestMatchingOption(validator, rootSchema, formData, options, selectedOption = -1, discriminatorField) {\n  // First resolve any refs in the options\n  const resolvedOptions = options.map(option => {\n    return resolveAllReferences(option, rootSchema, []);\n  });\n  const simpleDiscriminatorMatch = getOptionMatchingSimpleDiscriminator(formData, options, discriminatorField);\n  if (isNumber(simpleDiscriminatorMatch)) {\n    return simpleDiscriminatorMatch;\n  }\n  // Reduce the array of options down to a list of the indexes that are considered matching options\n  const allValidIndexes = resolvedOptions.reduce((validList, option, index) => {\n    const testOptions = [JUNK_OPTION, option];\n    const match = getFirstMatchingOption(validator, formData, testOptions, rootSchema, discriminatorField);\n    // The match is the real option, so add its index to list of valid indexes\n    if (match === 1) {\n      validList.push(index);\n    }\n    return validList;\n  }, []);\n  // There is only one valid index, so return it!\n  if (allValidIndexes.length === 1) {\n    return allValidIndexes[0];\n  }\n  if (!allValidIndexes.length) {\n    // No indexes were valid, so we'll score all the options, add all the indexes\n    times(resolvedOptions.length, i => allValidIndexes.push(i));\n  }\n  const scoreCount = new Set();\n  // Score all the options in the list of valid indexes and return the index with the best score\n  const {\n    bestIndex\n  } = allValidIndexes.reduce((scoreData, index) => {\n    const {\n      bestScore\n    } = scoreData;\n    const option = resolvedOptions[index];\n    const score = calculateIndexScore(validator, rootSchema, option, formData);\n    scoreCount.add(score);\n    if (score > bestScore) {\n      return {\n        bestIndex: index,\n        bestScore: score\n      };\n    }\n    return scoreData;\n  }, {\n    bestIndex: selectedOption,\n    bestScore: 0\n  });\n  // if all scores are the same go with selectedOption\n  if (scoreCount.size === 1 && selectedOption >= 0) {\n    return selectedOption;\n  }\n  return bestIndex;\n}","map":{"version":3,"names":["get","has","isNumber","isObject","isString","reduce","times","getFirstMatchingOption","retrieveSchema","resolveAllReferences","ONE_OF_KEY","REF_KEY","JUNK_OPTION_ID","ANY_OF_KEY","guessType","getDiscriminatorFieldFromSchema","getOptionMatchingSimpleDiscriminator","JUNK_OPTION","type","$id","properties","__not_really_there__","calculateIndexScore","validator","rootSchema","schema","formData","totalScore","score","value","key","formValue","newSchema","discriminator","getClosestMatchingOption","newScore","default","const","options","selectedOption","discriminatorField","resolvedOptions","map","option","simpleDiscriminatorMatch","allValidIndexes","validList","index","testOptions","match","push","length","i","scoreCount","Set","bestIndex","scoreData","bestScore","add","size"],"sources":["D:\\Reactjs\\my-app\\node_modules\\@rjsf\\utils\\src\\schema\\getClosestMatchingOption.ts"],"sourcesContent":["import get from 'lodash/get';\nimport has from 'lodash/has';\nimport isNumber from 'lodash/isNumber';\nimport isObject from 'lodash/isObject';\nimport isString from 'lodash/isString';\nimport reduce from 'lodash/reduce';\nimport times from 'lodash/times';\n\nimport getFirstMatchingOption from './getFirstMatchingOption';\nimport retrieveSchema, { resolveAllReferences } from './retrieveSchema';\nimport { ONE_OF_KEY, REF_KEY, JUNK_OPTION_ID, ANY_OF_KEY } from '../constants';\nimport guessType from '../guessType';\nimport { FormContextType, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\nimport getDiscriminatorFieldFromSchema from '../getDiscriminatorFieldFromSchema';\nimport getOptionMatchingSimpleDiscriminator from '../getOptionMatchingSimpleDiscriminator';\n\n/** A junk option used to determine when the getFirstMatchingOption call really matches an option rather than returning\n * the first item\n */\nexport const JUNK_OPTION: StrictRJSFSchema = {\n  type: 'object',\n  $id: JUNK_OPTION_ID,\n  properties: {\n    __not_really_there__: {\n      type: 'number',\n    },\n  },\n};\n\n/** Recursive function that calculates the score of a `formData` against the given `schema`. The computation is fairly\n * simple. Initially the total score is 0. When `schema.properties` object exists, then all the `key/value` pairs within\n * the object are processed as follows after obtaining the formValue from `formData` using the `key`:\n * - If the `value` contains a `$ref`, `calculateIndexScore()` is called recursively with the formValue and the new\n *   schema that is the result of the ref in the schema being resolved and that sub-schema's resulting score is added to\n *   the total.\n * - If the `value` contains a `oneOf` and there is a formValue, then score based on the index returned from calling\n *   `getClosestMatchingOption()` of that oneOf.\n * - If the type of the `value` is 'object', `calculateIndexScore()` is called recursively with the formValue and the\n *   `value` itself as the sub-schema, and the score is added to the total.\n * - If the type of the `value` matches the guessed-type of the `formValue`, the score is incremented by 1, UNLESS the\n *   value has a `default` or `const`. In those case, if the `default` or `const` and the `formValue` match, the score\n *   is incremented by another 1 otherwise it is decremented by 1.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param rootSchema - The root JSON schema of the entire form\n * @param schema - The schema for which the score is being calculated\n * @param formData - The form data associated with the schema, used to calculate the score\n * @returns - The score a schema against the formData\n */\nexport function calculateIndexScore<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  rootSchema: S,\n  schema?: S,\n  formData: any = {}\n): number {\n  let totalScore = 0;\n  if (schema) {\n    if (isObject(schema.properties)) {\n      totalScore += reduce(\n        schema.properties,\n        (score, value, key) => {\n          const formValue = get(formData, key);\n          if (typeof value === 'boolean') {\n            return score;\n          }\n          if (has(value, REF_KEY)) {\n            const newSchema = retrieveSchema<T, S, F>(validator, value as S, rootSchema, formValue);\n            return score + calculateIndexScore<T, S, F>(validator, rootSchema, newSchema, formValue || {});\n          }\n          if ((has(value, ONE_OF_KEY) || has(value, ANY_OF_KEY)) && formValue) {\n            const key = has(value, ONE_OF_KEY) ? ONE_OF_KEY : ANY_OF_KEY;\n            const discriminator = getDiscriminatorFieldFromSchema<S>(value as S);\n            return (\n              score +\n              getClosestMatchingOption<T, S, F>(\n                validator,\n                rootSchema,\n                formValue,\n                get(value, key) as S[],\n                -1,\n                discriminator\n              )\n            );\n          }\n          if (value.type === 'object') {\n            return score + calculateIndexScore<T, S, F>(validator, rootSchema, value as S, formValue || {});\n          }\n          if (value.type === guessType(formValue)) {\n            // If the types match, then we bump the score by one\n            let newScore = score + 1;\n            if (value.default) {\n              // If the schema contains a readonly default value score the value that matches the default higher and\n              // any non-matching value lower\n              newScore += formValue === value.default ? 1 : -1;\n            } else if (value.const) {\n              // If the schema contains a const value score the value that matches the default higher and\n              // any non-matching value lower\n              newScore += formValue === value.const ? 1 : -1;\n            }\n            // TODO eventually, deal with enums/arrays\n            return newScore;\n          }\n          return score;\n        },\n        0\n      );\n    } else if (isString(schema.type) && schema.type === guessType(formData)) {\n      totalScore += 1;\n    }\n  }\n  return totalScore;\n}\n\n/** Determines which of the given `options` provided most closely matches the `formData`. Using\n * `getFirstMatchingOption()` to match two schemas that differ only by the readOnly, default or const value of a field\n * based on the `formData` and returns 0 when there is no match. Rather than passing in all the `options` at once to\n * this utility, instead an array of valid option indexes is created by iterating over the list of options, call\n * `getFirstMatchingOptions` with a list of one junk option and one good option, seeing if the good option is considered\n * matched.\n *\n * Once the list of valid indexes is created, if there is only one valid index, just return it. Otherwise, if there are\n * no valid indexes, then fill the valid indexes array with the indexes of all the options. Next, the index of the\n * option with the highest score is determined by iterating over the list of valid options, calling\n * `calculateIndexScore()` on each, comparing it against the current best score, and returning the index of the one that\n * eventually has the best score.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param rootSchema - The root JSON schema of the entire form\n * @param formData - The form data associated with the schema\n * @param options - The list of options that can be selected from\n * @param [selectedOption=-1] - The index of the currently selected option, defaulted to -1 if not specified\n * @param [discriminatorField] - The optional name of the field within the options object whose value is used to\n *          determine which option is selected\n * @returns - The index of the option that is the closest match to the `formData` or the `selectedOption` if no match\n */\nexport default function getClosestMatchingOption<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(\n  validator: ValidatorType<T, S, F>,\n  rootSchema: S,\n  formData: T | undefined,\n  options: S[],\n  selectedOption = -1,\n  discriminatorField?: string\n): number {\n  // First resolve any refs in the options\n  const resolvedOptions = options.map((option) => {\n    return resolveAllReferences<S>(option, rootSchema, []);\n  });\n\n  const simpleDiscriminatorMatch = getOptionMatchingSimpleDiscriminator(formData, options, discriminatorField);\n  if (isNumber(simpleDiscriminatorMatch)) {\n    return simpleDiscriminatorMatch;\n  }\n\n  // Reduce the array of options down to a list of the indexes that are considered matching options\n  const allValidIndexes = resolvedOptions.reduce((validList: number[], option, index: number) => {\n    const testOptions: S[] = [JUNK_OPTION as S, option];\n    const match = getFirstMatchingOption<T, S, F>(validator, formData, testOptions, rootSchema, discriminatorField);\n    // The match is the real option, so add its index to list of valid indexes\n    if (match === 1) {\n      validList.push(index);\n    }\n    return validList;\n  }, []);\n\n  // There is only one valid index, so return it!\n  if (allValidIndexes.length === 1) {\n    return allValidIndexes[0];\n  }\n  if (!allValidIndexes.length) {\n    // No indexes were valid, so we'll score all the options, add all the indexes\n    times(resolvedOptions.length, (i) => allValidIndexes.push(i));\n  }\n  type BestType = { bestIndex: number; bestScore: number };\n  const scoreCount = new Set<number>();\n  // Score all the options in the list of valid indexes and return the index with the best score\n  const { bestIndex }: BestType = allValidIndexes.reduce(\n    (scoreData: BestType, index: number) => {\n      const { bestScore } = scoreData;\n      const option = resolvedOptions[index];\n      const score = calculateIndexScore(validator, rootSchema, option, formData);\n      scoreCount.add(score);\n      if (score > bestScore) {\n        return { bestIndex: index, bestScore: score };\n      }\n      return scoreData;\n    },\n    { bestIndex: selectedOption, bestScore: 0 }\n  );\n  // if all scores are the same go with selectedOption\n  if (scoreCount.size === 1 && selectedOption >= 0) {\n    return selectedOption;\n  }\n\n  return bestIndex;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}