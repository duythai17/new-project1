{"ast":null,"code":"import { jsx as _jsx, jsxs as _jsxs } from \"react/jsx-runtime\";\nimport { Component, createRef } from 'react';\nimport { createSchemaUtils, deepEquals, getTemplate, getUiOptions, isObject, mergeObjects, NAME_KEY, RJSF_ADDITONAL_PROPERTIES_FLAG, shouldRender, SUBMIT_BTN_OPTIONS_KEY, toErrorList, UI_GLOBAL_OPTIONS_KEY, UI_OPTIONS_KEY, validationDataMerge } from '@rjsf/utils';\nimport _get from 'lodash/get';\nimport _isEmpty from 'lodash/isEmpty';\nimport _pick from 'lodash/pick';\nimport _toPath from 'lodash/toPath';\nimport getDefaultRegistry from '../getDefaultRegistry';\n/** The `Form` component renders the outer form and all the fields defined in the `schema` */\nexport default class Form extends Component {\n  /** Constructs the `Form` from the `props`. Will setup the initial state from the props. It will also call the\n   * `onChange` handler if the initially provided `formData` is modified to add missing default values as part of the\n   * state construction.\n   *\n   * @param props - The initial props for the `Form`\n   */\n  constructor(props) {\n    super(props);\n    /** Returns the `formData` with only the elements specified in the `fields` list\n     *\n     * @param formData - The data for the `Form`\n     * @param fields - The fields to keep while filtering\n     */\n    this.getUsedFormData = (formData, fields) => {\n      // For the case of a single input form\n      if (fields.length === 0 && typeof formData !== 'object') {\n        return formData;\n      }\n      // _pick has incorrect type definition, it works with string[][], because lodash/hasIn supports it\n      const data = _pick(formData, fields);\n      if (Array.isArray(formData)) {\n        return Object.keys(data).map(key => data[key]);\n      }\n      return data;\n    };\n    /** Returns the list of field names from inspecting the `pathSchema` as well as using the `formData`\n     *\n     * @param pathSchema - The `PathSchema` object for the form\n     * @param [formData] - The form data to use while checking for empty objects/arrays\n     */\n    this.getFieldNames = (pathSchema, formData) => {\n      const getAllPaths = function (_obj) {\n        let acc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n        let paths = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [[]];\n        Object.keys(_obj).forEach(key => {\n          if (typeof _obj[key] === 'object') {\n            const newPaths = paths.map(path => [...path, key]);\n            // If an object is marked with additionalProperties, all its keys are valid\n            if (_obj[key][RJSF_ADDITONAL_PROPERTIES_FLAG] && _obj[key][NAME_KEY] !== '') {\n              acc.push(_obj[key][NAME_KEY]);\n            } else {\n              getAllPaths(_obj[key], acc, newPaths);\n            }\n          } else if (key === NAME_KEY && _obj[key] !== '') {\n            paths.forEach(path => {\n              const formValue = _get(formData, path);\n              // adds path to fieldNames if it points to a value\n              // or an empty object/array\n              if (typeof formValue !== 'object' || _isEmpty(formValue) || Array.isArray(formValue) && formValue.every(val => typeof val !== 'object')) {\n                acc.push(path);\n              }\n            });\n          }\n        });\n        return acc;\n      };\n      return getAllPaths(pathSchema);\n    };\n    /** Function to handle changes made to a field in the `Form`. This handler receives an entirely new copy of the\n     * `formData` along with a new `ErrorSchema`. It will first update the `formData` with any missing default fields and\n     * then, if `omitExtraData` and `liveOmit` are turned on, the `formData` will be filterer to remove any extra data not\n     * in a form field. Then, the resulting formData will be validated if required. The state will be updated with the new\n     * updated (potentially filtered) `formData`, any errors that resulted from validation. Finally the `onChange`\n     * callback will be called if specified with the updated state.\n     *\n     * @param formData - The new form data from a change to a field\n     * @param newErrorSchema - The new `ErrorSchema` based on the field change\n     * @param id - The id of the field that caused the change\n     */\n    this.onChange = (formData, newErrorSchema, id) => {\n      const {\n        extraErrors,\n        omitExtraData,\n        liveOmit,\n        noValidate,\n        liveValidate,\n        onChange\n      } = this.props;\n      const {\n        schemaUtils,\n        schema,\n        retrievedSchema\n      } = this.state;\n      if (isObject(formData) || Array.isArray(formData)) {\n        const newState = this.getStateFromProps(this.props, formData, retrievedSchema);\n        formData = newState.formData;\n      }\n      const mustValidate = !noValidate && liveValidate;\n      let state = {\n        formData,\n        schema\n      };\n      let newFormData = formData;\n      let _retrievedSchema;\n      if (omitExtraData === true && liveOmit === true) {\n        _retrievedSchema = schemaUtils.retrieveSchema(schema, formData);\n        const pathSchema = schemaUtils.toPathSchema(_retrievedSchema, '', formData);\n        const fieldNames = this.getFieldNames(pathSchema, formData);\n        newFormData = this.getUsedFormData(formData, fieldNames);\n        state = {\n          formData: newFormData\n        };\n      }\n      if (mustValidate) {\n        const schemaValidation = this.validate(newFormData, schema, schemaUtils, retrievedSchema);\n        let errors = schemaValidation.errors;\n        let errorSchema = schemaValidation.errorSchema;\n        const schemaValidationErrors = errors;\n        const schemaValidationErrorSchema = errorSchema;\n        if (extraErrors) {\n          const merged = validationDataMerge(schemaValidation, extraErrors);\n          errorSchema = merged.errorSchema;\n          errors = merged.errors;\n        }\n        state = {\n          formData: newFormData,\n          errors,\n          errorSchema,\n          schemaValidationErrors,\n          schemaValidationErrorSchema\n        };\n      } else if (!noValidate && newErrorSchema) {\n        const errorSchema = extraErrors ? mergeObjects(newErrorSchema, extraErrors, 'preventDuplicates') : newErrorSchema;\n        state = {\n          formData: newFormData,\n          errorSchema: errorSchema,\n          errors: toErrorList(errorSchema)\n        };\n      }\n      if (_retrievedSchema) {\n        state.retrievedSchema = _retrievedSchema;\n      }\n      this.setState(state, () => onChange && onChange({\n        ...this.state,\n        ...state\n      }, id));\n    };\n    /**\n     * Callback function to handle reset form data.\n     * - Reset all fields with default values.\n     * - Reset validations and errors\n     *\n     */\n    this.reset = () => {\n      const {\n        onChange\n      } = this.props;\n      const newState = this.getStateFromProps(this.props, undefined);\n      const newFormData = newState.formData;\n      const state = {\n        formData: newFormData,\n        errorSchema: {},\n        errors: [],\n        schemaValidationErrors: [],\n        schemaValidationErrorSchema: {}\n      };\n      this.setState(state, () => onChange && onChange({\n        ...this.state,\n        ...state\n      }));\n    };\n    /** Callback function to handle when a field on the form is blurred. Calls the `onBlur` callback for the `Form` if it\n     * was provided.\n     *\n     * @param id - The unique `id` of the field that was blurred\n     * @param data - The data associated with the field that was blurred\n     */\n    this.onBlur = (id, data) => {\n      const {\n        onBlur\n      } = this.props;\n      if (onBlur) {\n        onBlur(id, data);\n      }\n    };\n    /** Callback function to handle when a field on the form is focused. Calls the `onFocus` callback for the `Form` if it\n     * was provided.\n     *\n     * @param id - The unique `id` of the field that was focused\n     * @param data - The data associated with the field that was focused\n     */\n    this.onFocus = (id, data) => {\n      const {\n        onFocus\n      } = this.props;\n      if (onFocus) {\n        onFocus(id, data);\n      }\n    };\n    /** Callback function to handle when the form is submitted. First, it prevents the default event behavior. Nothing\n     * happens if the target and currentTarget of the event are not the same. It will omit any extra data in the\n     * `formData` in the state if `omitExtraData` is true. It will validate the resulting `formData`, reporting errors\n     * via the `onError()` callback unless validation is disabled. Finally, it will add in any `extraErrors` and then call\n     * back the `onSubmit` callback if it was provided.\n     *\n     * @param event - The submit HTML form event\n     */\n    this.onSubmit = event => {\n      event.preventDefault();\n      if (event.target !== event.currentTarget) {\n        return;\n      }\n      event.persist();\n      const {\n        omitExtraData,\n        extraErrors,\n        noValidate,\n        onSubmit\n      } = this.props;\n      let {\n        formData: newFormData\n      } = this.state;\n      const {\n        schema,\n        schemaUtils\n      } = this.state;\n      if (omitExtraData === true) {\n        const retrievedSchema = schemaUtils.retrieveSchema(schema, newFormData);\n        const pathSchema = schemaUtils.toPathSchema(retrievedSchema, '', newFormData);\n        const fieldNames = this.getFieldNames(pathSchema, newFormData);\n        newFormData = this.getUsedFormData(newFormData, fieldNames);\n      }\n      if (noValidate || this.validateForm()) {\n        // There are no errors generated through schema validation.\n        // Check for user provided errors and update state accordingly.\n        const errorSchema = extraErrors || {};\n        const errors = extraErrors ? toErrorList(extraErrors) : [];\n        this.setState({\n          formData: newFormData,\n          errors,\n          errorSchema,\n          schemaValidationErrors: [],\n          schemaValidationErrorSchema: {}\n        }, () => {\n          if (onSubmit) {\n            onSubmit({\n              ...this.state,\n              formData: newFormData,\n              status: 'submitted'\n            }, event);\n          }\n        });\n      }\n    };\n    if (!props.validator) {\n      throw new Error('A validator is required for Form functionality to work');\n    }\n    this.state = this.getStateFromProps(props, props.formData);\n    if (this.props.onChange && !deepEquals(this.state.formData, this.props.formData)) {\n      this.props.onChange(this.state);\n    }\n    this.formElement = createRef();\n  }\n  /**\n   * `getSnapshotBeforeUpdate` is a React lifecycle method that is invoked right before the most recently rendered\n   * output is committed to the DOM. It enables your component to capture current values (e.g., scroll position) before\n   * they are potentially changed.\n   *\n   * In this case, it checks if the props have changed since the last render. If they have, it computes the next state\n   * of the component using `getStateFromProps` method and returns it along with a `shouldUpdate` flag set to `true` IF\n   * the `nextState` and `prevState` are different, otherwise `false`. This ensures that we have the most up-to-date\n   * state ready to be applied in `componentDidUpdate`.\n   *\n   * If `formData` hasn't changed, it simply returns an object with `shouldUpdate` set to `false`, indicating that a\n   * state update is not necessary.\n   *\n   * @param prevProps - The previous set of props before the update.\n   * @param prevState - The previous state before the update.\n   * @returns Either an object containing the next state and a flag indicating that an update should occur, or an object\n   *        with a flag indicating that an update is not necessary.\n   */\n  getSnapshotBeforeUpdate(prevProps, prevState) {\n    if (!deepEquals(this.props, prevProps)) {\n      const nextState = this.getStateFromProps(this.props, this.props.formData, prevProps.schema !== this.props.schema ? undefined : this.state.retrievedSchema);\n      const shouldUpdate = !deepEquals(nextState, prevState);\n      return {\n        nextState,\n        shouldUpdate\n      };\n    }\n    return {\n      shouldUpdate: false\n    };\n  }\n  /**\n   * `componentDidUpdate` is a React lifecycle method that is invoked immediately after updating occurs. This method is\n   * not called for the initial render.\n   *\n   * Here, it checks if an update is necessary based on the `shouldUpdate` flag received from `getSnapshotBeforeUpdate`.\n   * If an update is required, it applies the next state and, if needed, triggers the `onChange` handler to inform about\n   * changes.\n   *\n   * This method effectively replaces the deprecated `UNSAFE_componentWillReceiveProps`, providing a safer alternative\n   * to handle prop changes and state updates.\n   *\n   * @param _ - The previous set of props.\n   * @param prevState - The previous state of the component before the update.\n   * @param snapshot - The value returned from `getSnapshotBeforeUpdate`.\n   */\n  componentDidUpdate(_, prevState, snapshot) {\n    if (snapshot.shouldUpdate) {\n      const {\n        nextState\n      } = snapshot;\n      if (!deepEquals(nextState.formData, this.props.formData) && !deepEquals(nextState.formData, prevState.formData) && this.props.onChange) {\n        this.props.onChange(nextState);\n      }\n      this.setState(nextState);\n    }\n  }\n  /** Extracts the updated state from the given `props` and `inputFormData`. As part of this process, the\n   * `inputFormData` is first processed to add any missing required defaults. After that, the data is run through the\n   * validation process IF required by the `props`.\n   *\n   * @param props - The props passed to the `Form`\n   * @param inputFormData - The new or current data for the `Form`\n   * @returns - The new state for the `Form`\n   */\n  getStateFromProps(props, inputFormData, retrievedSchema) {\n    const state = this.state || {};\n    const schema = 'schema' in props ? props.schema : this.props.schema;\n    const uiSchema = ('uiSchema' in props ? props.uiSchema : this.props.uiSchema) || {};\n    const edit = typeof inputFormData !== 'undefined';\n    const liveValidate = 'liveValidate' in props ? props.liveValidate : this.props.liveValidate;\n    const mustValidate = edit && !props.noValidate && liveValidate;\n    const rootSchema = schema;\n    const experimental_defaultFormStateBehavior = 'experimental_defaultFormStateBehavior' in props ? props.experimental_defaultFormStateBehavior : this.props.experimental_defaultFormStateBehavior;\n    let schemaUtils = state.schemaUtils;\n    if (!schemaUtils || schemaUtils.doesSchemaUtilsDiffer(props.validator, rootSchema, experimental_defaultFormStateBehavior)) {\n      schemaUtils = createSchemaUtils(props.validator, rootSchema, experimental_defaultFormStateBehavior);\n    }\n    const formData = schemaUtils.getDefaultFormState(schema, inputFormData);\n    const _retrievedSchema = retrievedSchema !== null && retrievedSchema !== void 0 ? retrievedSchema : schemaUtils.retrieveSchema(schema, formData);\n    const getCurrentErrors = () => {\n      if (props.noValidate) {\n        return {\n          errors: [],\n          errorSchema: {}\n        };\n      } else if (!props.liveValidate) {\n        return {\n          errors: state.schemaValidationErrors || [],\n          errorSchema: state.schemaValidationErrorSchema || {}\n        };\n      }\n      return {\n        errors: state.errors || [],\n        errorSchema: state.errorSchema || {}\n      };\n    };\n    let errors;\n    let errorSchema;\n    let schemaValidationErrors = state.schemaValidationErrors;\n    let schemaValidationErrorSchema = state.schemaValidationErrorSchema;\n    if (mustValidate) {\n      const schemaValidation = this.validate(formData, schema, schemaUtils, _retrievedSchema);\n      errors = schemaValidation.errors;\n      errorSchema = schemaValidation.errorSchema;\n      schemaValidationErrors = errors;\n      schemaValidationErrorSchema = errorSchema;\n    } else {\n      const currentErrors = getCurrentErrors();\n      errors = currentErrors.errors;\n      errorSchema = currentErrors.errorSchema;\n    }\n    if (props.extraErrors) {\n      const merged = validationDataMerge({\n        errorSchema,\n        errors\n      }, props.extraErrors);\n      errorSchema = merged.errorSchema;\n      errors = merged.errors;\n    }\n    const idSchema = schemaUtils.toIdSchema(_retrievedSchema, uiSchema['ui:rootFieldId'], formData, props.idPrefix, props.idSeparator);\n    const nextState = {\n      schemaUtils,\n      schema,\n      uiSchema,\n      idSchema,\n      formData,\n      edit,\n      errors,\n      errorSchema,\n      schemaValidationErrors,\n      schemaValidationErrorSchema,\n      retrievedSchema: _retrievedSchema\n    };\n    return nextState;\n  }\n  /** React lifecycle method that is used to determine whether component should be updated.\n   *\n   * @param nextProps - The next version of the props\n   * @param nextState - The next version of the state\n   * @returns - True if the component should be updated, false otherwise\n   */\n  shouldComponentUpdate(nextProps, nextState) {\n    return shouldRender(this, nextProps, nextState);\n  }\n  /** Validates the `formData` against the `schema` using the `altSchemaUtils` (if provided otherwise it uses the\n   * `schemaUtils` in the state), returning the results.\n   *\n   * @param formData - The new form data to validate\n   * @param schema - The schema used to validate against\n   * @param altSchemaUtils - The alternate schemaUtils to use for validation\n   */\n  validate(formData) {\n    let schema = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.props.schema;\n    let altSchemaUtils = arguments.length > 2 ? arguments[2] : undefined;\n    let retrievedSchema = arguments.length > 3 ? arguments[3] : undefined;\n    const schemaUtils = altSchemaUtils ? altSchemaUtils : this.state.schemaUtils;\n    const {\n      customValidate,\n      transformErrors,\n      uiSchema\n    } = this.props;\n    const resolvedSchema = retrievedSchema !== null && retrievedSchema !== void 0 ? retrievedSchema : schemaUtils.retrieveSchema(schema, formData);\n    return schemaUtils.getValidator().validateFormData(formData, resolvedSchema, customValidate, transformErrors, uiSchema);\n  }\n  /** Renders any errors contained in the `state` in using the `ErrorList`, if not disabled by `showErrorList`. */\n  renderErrors(registry) {\n    const {\n      errors,\n      errorSchema,\n      schema,\n      uiSchema\n    } = this.state;\n    const {\n      formContext\n    } = this.props;\n    const options = getUiOptions(uiSchema);\n    const ErrorListTemplate = getTemplate('ErrorListTemplate', registry, options);\n    if (errors && errors.length) {\n      return _jsx(ErrorListTemplate, {\n        errors: errors,\n        errorSchema: errorSchema || {},\n        schema: schema,\n        uiSchema: uiSchema,\n        formContext: formContext,\n        registry: registry\n      });\n    }\n    return null;\n  }\n  /** Returns the registry for the form */\n  getRegistry() {\n    var _a;\n    const {\n      translateString: customTranslateString,\n      uiSchema = {}\n    } = this.props;\n    const {\n      schemaUtils\n    } = this.state;\n    const {\n      fields,\n      templates,\n      widgets,\n      formContext,\n      translateString\n    } = getDefaultRegistry();\n    return {\n      fields: {\n        ...fields,\n        ...this.props.fields\n      },\n      templates: {\n        ...templates,\n        ...this.props.templates,\n        ButtonTemplates: {\n          ...templates.ButtonTemplates,\n          ...((_a = this.props.templates) === null || _a === void 0 ? void 0 : _a.ButtonTemplates)\n        }\n      },\n      widgets: {\n        ...widgets,\n        ...this.props.widgets\n      },\n      rootSchema: this.props.schema,\n      formContext: this.props.formContext || formContext,\n      schemaUtils,\n      translateString: customTranslateString || translateString,\n      globalUiOptions: uiSchema[UI_GLOBAL_OPTIONS_KEY]\n    };\n  }\n  /** Provides a function that can be used to programmatically submit the `Form` */\n  submit() {\n    if (this.formElement.current) {\n      this.formElement.current.dispatchEvent(new CustomEvent('submit', {\n        cancelable: true\n      }));\n      this.formElement.current.requestSubmit();\n    }\n  }\n  /** Attempts to focus on the field associated with the `error`. Uses the `property` field to compute path of the error\n   * field, then, using the `idPrefix` and `idSeparator` converts that path into an id. Then the input element with that\n   * id is attempted to be found using the `formElement` ref. If it is located, then it is focused.\n   *\n   * @param error - The error on which to focus\n   */\n  focusOnError(error) {\n    const {\n      idPrefix = 'root',\n      idSeparator = '_'\n    } = this.props;\n    const {\n      property\n    } = error;\n    const path = _toPath(property);\n    if (path[0] === '') {\n      // Most of the time the `.foo` property results in the first element being empty, so replace it with the idPrefix\n      path[0] = idPrefix;\n    } else {\n      // Otherwise insert the idPrefix into the first location using unshift\n      path.unshift(idPrefix);\n    }\n    const elementId = path.join(idSeparator);\n    let field = this.formElement.current.elements[elementId];\n    if (!field) {\n      // if not an exact match, try finding an input starting with the element id (like radio buttons or checkboxes)\n      field = this.formElement.current.querySelector(\"input[id^=\".concat(elementId));\n    }\n    if (field && field.length) {\n      // If we got a list with length > 0\n      field = field[0];\n    }\n    if (field) {\n      field.focus();\n    }\n  }\n  /** Programmatically validate the form. If `onError` is provided, then it will be called with the list of errors the\n   * same way as would happen on form submission.\n   *\n   * @returns - True if the form is valid, false otherwise.\n   */\n  validateForm() {\n    const {\n      extraErrors,\n      extraErrorsBlockSubmit,\n      focusOnFirstError,\n      onError\n    } = this.props;\n    const {\n      formData,\n      errors: prevErrors\n    } = this.state;\n    const schemaValidation = this.validate(formData);\n    let errors = schemaValidation.errors;\n    let errorSchema = schemaValidation.errorSchema;\n    const schemaValidationErrors = errors;\n    const schemaValidationErrorSchema = errorSchema;\n    const hasError = errors.length > 0 || extraErrors && extraErrorsBlockSubmit;\n    if (hasError) {\n      if (extraErrors) {\n        const merged = validationDataMerge(schemaValidation, extraErrors);\n        errorSchema = merged.errorSchema;\n        errors = merged.errors;\n      }\n      if (focusOnFirstError) {\n        if (typeof focusOnFirstError === 'function') {\n          focusOnFirstError(errors[0]);\n        } else {\n          this.focusOnError(errors[0]);\n        }\n      }\n      this.setState({\n        errors,\n        errorSchema,\n        schemaValidationErrors,\n        schemaValidationErrorSchema\n      }, () => {\n        if (onError) {\n          onError(errors);\n        } else {\n          console.error('Form validation failed', errors);\n        }\n      });\n    } else if (prevErrors.length > 0) {\n      this.setState({\n        errors: [],\n        errorSchema: {},\n        schemaValidationErrors: [],\n        schemaValidationErrorSchema: {}\n      });\n    }\n    return !hasError;\n  }\n  /** Renders the `Form` fields inside the <form> | `tagName` or `_internalFormWrapper`, rendering any errors if\n   * needed along with the submit button or any children of the form.\n   */\n  render() {\n    const {\n      children,\n      id,\n      idPrefix,\n      idSeparator,\n      className = '',\n      tagName,\n      name,\n      method,\n      target,\n      action,\n      autoComplete,\n      enctype,\n      acceptcharset,\n      noHtml5Validate = false,\n      disabled = false,\n      readonly = false,\n      formContext,\n      showErrorList = 'top',\n      _internalFormWrapper\n    } = this.props;\n    const {\n      schema,\n      uiSchema,\n      formData,\n      errorSchema,\n      idSchema\n    } = this.state;\n    const registry = this.getRegistry();\n    const {\n      SchemaField: _SchemaField\n    } = registry.fields;\n    const {\n      SubmitButton\n    } = registry.templates.ButtonTemplates;\n    // The `semantic-ui` and `material-ui` themes have `_internalFormWrapper`s that take an `as` prop that is the\n    // PropTypes.elementType to use for the inner tag, so we'll need to pass `tagName` along if it is provided.\n    // NOTE, the `as` prop is native to `semantic-ui` and is emulated in the `material-ui` theme\n    const as = _internalFormWrapper ? tagName : undefined;\n    const FormTag = _internalFormWrapper || tagName || 'form';\n    let {\n      [SUBMIT_BTN_OPTIONS_KEY]: submitOptions = {}\n    } = getUiOptions(uiSchema);\n    if (disabled) {\n      submitOptions = {\n        ...submitOptions,\n        props: {\n          ...submitOptions.props,\n          disabled: true\n        }\n      };\n    }\n    const submitUiSchema = {\n      [UI_OPTIONS_KEY]: {\n        [SUBMIT_BTN_OPTIONS_KEY]: submitOptions\n      }\n    };\n    return _jsxs(FormTag, {\n      className: className ? className : 'rjsf',\n      id: id,\n      name: name,\n      method: method,\n      target: target,\n      action: action,\n      autoComplete: autoComplete,\n      encType: enctype,\n      acceptCharset: acceptcharset,\n      noValidate: noHtml5Validate,\n      onSubmit: this.onSubmit,\n      as: as,\n      ref: this.formElement,\n      children: [showErrorList === 'top' && this.renderErrors(registry), _jsx(_SchemaField, {\n        name: '',\n        schema: schema,\n        uiSchema: uiSchema,\n        errorSchema: errorSchema,\n        idSchema: idSchema,\n        idPrefix: idPrefix,\n        idSeparator: idSeparator,\n        formContext: formContext,\n        formData: formData,\n        onChange: this.onChange,\n        onBlur: this.onBlur,\n        onFocus: this.onFocus,\n        registry: registry,\n        disabled: disabled,\n        readonly: readonly\n      }), children ? children : _jsx(SubmitButton, {\n        uiSchema: submitUiSchema,\n        registry: registry\n      }), showErrorList === 'bottom' && this.renderErrors(registry)]\n    });\n  }\n}","map":{"version":3,"names":["Component","createRef","createSchemaUtils","deepEquals","getTemplate","getUiOptions","isObject","mergeObjects","NAME_KEY","RJSF_ADDITONAL_PROPERTIES_FLAG","shouldRender","SUBMIT_BTN_OPTIONS_KEY","toErrorList","UI_GLOBAL_OPTIONS_KEY","UI_OPTIONS_KEY","validationDataMerge","_get","_isEmpty","_pick","_toPath","getDefaultRegistry","Form","constructor","props","getUsedFormData","formData","fields","length","data","Array","isArray","Object","keys","map","key","getFieldNames","pathSchema","getAllPaths","_obj","acc","arguments","undefined","paths","forEach","newPaths","path","push","formValue","every","val","onChange","newErrorSchema","id","extraErrors","omitExtraData","liveOmit","noValidate","liveValidate","schemaUtils","schema","retrievedSchema","state","newState","getStateFromProps","mustValidate","newFormData","_retrievedSchema","retrieveSchema","toPathSchema","fieldNames","schemaValidation","validate","errors","errorSchema","schemaValidationErrors","schemaValidationErrorSchema","merged","setState","reset","onBlur","onFocus","onSubmit","event","preventDefault","target","currentTarget","persist","validateForm","status","validator","Error","formElement","getSnapshotBeforeUpdate","prevProps","prevState","nextState","shouldUpdate","componentDidUpdate","_","snapshot","inputFormData","uiSchema","edit","rootSchema","experimental_defaultFormStateBehavior","doesSchemaUtilsDiffer","getDefaultFormState","getCurrentErrors","currentErrors","idSchema","toIdSchema","idPrefix","idSeparator","shouldComponentUpdate","nextProps","altSchemaUtils","customValidate","transformErrors","resolvedSchema","getValidator","validateFormData","renderErrors","registry","formContext","options","ErrorListTemplate","_jsx","getRegistry","translateString","customTranslateString","templates","widgets","ButtonTemplates","_a","globalUiOptions","submit","current","dispatchEvent","CustomEvent","cancelable","requestSubmit","focusOnError","error","property","unshift","elementId","join","field","elements","querySelector","concat","focus","extraErrorsBlockSubmit","focusOnFirstError","onError","prevErrors","hasError","console","render","children","className","tagName","name","method","action","autoComplete","enctype","acceptcharset","noHtml5Validate","disabled","readonly","showErrorList","_internalFormWrapper","SchemaField","_SchemaField","SubmitButton","as","FormTag","submitOptions","submitUiSchema","_jsxs","encType","acceptCharset","ref"],"sources":["D:\\Reactjs\\my-app\\node_modules\\@rjsf\\core\\src\\components\\Form.tsx"],"sourcesContent":["import { Component, ElementType, FormEvent, ReactNode, Ref, RefObject, createRef } from 'react';\nimport {\n  createSchemaUtils,\n  CustomValidator,\n  deepEquals,\n  ErrorSchema,\n  ErrorTransformer,\n  FormContextType,\n  GenericObjectType,\n  getTemplate,\n  getUiOptions,\n  IdSchema,\n  isObject,\n  mergeObjects,\n  NAME_KEY,\n  PathSchema,\n  StrictRJSFSchema,\n  Registry,\n  RegistryFieldsType,\n  RegistryWidgetsType,\n  RJSFSchema,\n  RJSFValidationError,\n  RJSF_ADDITONAL_PROPERTIES_FLAG,\n  SchemaUtilsType,\n  shouldRender,\n  SUBMIT_BTN_OPTIONS_KEY,\n  TemplatesType,\n  toErrorList,\n  UiSchema,\n  UI_GLOBAL_OPTIONS_KEY,\n  UI_OPTIONS_KEY,\n  ValidationData,\n  validationDataMerge,\n  ValidatorType,\n  Experimental_DefaultFormStateBehavior,\n} from '@rjsf/utils';\nimport _get from 'lodash/get';\nimport _isEmpty from 'lodash/isEmpty';\nimport _pick from 'lodash/pick';\nimport _toPath from 'lodash/toPath';\n\nimport getDefaultRegistry from '../getDefaultRegistry';\n\n/** The properties that are passed to the `Form` */\nexport interface FormProps<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any> {\n  /** The JSON schema object for the form */\n  schema: S;\n  /** An implementation of the `ValidatorType` interface that is needed for form validation to work */\n  validator: ValidatorType<T, S, F>;\n  /** The optional children for the form, if provided, it will replace the default `SubmitButton` */\n  children?: ReactNode;\n  /** The uiSchema for the form */\n  uiSchema?: UiSchema<T, S, F>;\n  /** The data for the form, used to prefill a form with existing data */\n  formData?: T;\n  // Form presentation and behavior modifiers\n  /** You can provide a `formContext` object to the form, which is passed down to all fields and widgets. Useful for\n   * implementing context aware fields and widgets.\n   *\n   * NOTE: Setting `{readonlyAsDisabled: false}` on the formContext will make the antd theme treat readOnly fields as\n   * disabled.\n   */\n  formContext?: F;\n  /** To avoid collisions with existing ids in the DOM, it is possible to change the prefix used for ids;\n   * Default is `root`\n   */\n  idPrefix?: string;\n  /** To avoid using a path separator that is present in field names, it is possible to change the separator used for\n   * ids (Default is `_`)\n   */\n  idSeparator?: string;\n  /** It's possible to disable the whole form by setting the `disabled` prop. The `disabled` prop is then forwarded down\n   * to each field of the form. If you just want to disable some fields, see the `ui:disabled` parameter in `uiSchema`\n   */\n  disabled?: boolean;\n  /** It's possible to make the whole form read-only by setting the `readonly` prop. The `readonly` prop is then\n   * forwarded down to each field of the form. If you just want to make some fields read-only, see the `ui:readonly`\n   * parameter in `uiSchema`\n   */\n  readonly?: boolean;\n  // Form registry\n  /** The dictionary of registered fields in the form */\n  fields?: RegistryFieldsType<T, S, F>;\n  /** The dictionary of registered templates in the form; Partial allows a subset to be provided beyond the defaults */\n  templates?: Partial<Omit<TemplatesType<T, S, F>, 'ButtonTemplates'>> & {\n    ButtonTemplates?: Partial<TemplatesType<T, S, F>['ButtonTemplates']>;\n  };\n  /** The dictionary of registered widgets in the form */\n  widgets?: RegistryWidgetsType<T, S, F>;\n  // Callbacks\n  /** If you plan on being notified every time the form data are updated, you can pass an `onChange` handler, which will\n   * receive the same args as `onSubmit` any time a value is updated in the form. Can also return the `id` of the field\n   * that caused the change\n   */\n  onChange?: (data: IChangeEvent<T, S, F>, id?: string) => void;\n  /** To react when submitted form data are invalid, pass an `onError` handler. It will be passed the list of\n   * encountered errors\n   */\n  onError?: (errors: RJSFValidationError[]) => void;\n  /** You can pass a function as the `onSubmit` prop of your `Form` component to listen to when the form is submitted\n   * and its data are valid. It will be passed a result object having a `formData` attribute, which is the valid form\n   * data you're usually after. The original event will also be passed as a second parameter\n   */\n  onSubmit?: (data: IChangeEvent<T, S, F>, event: FormEvent<any>) => void;\n  /** Sometimes you may want to trigger events or modify external state when a field has been touched, so you can pass\n   * an `onBlur` handler, which will receive the id of the input that was blurred and the field value\n   */\n  onBlur?: (id: string, data: any) => void;\n  /** Sometimes you may want to trigger events or modify external state when a field has been focused, so you can pass\n   * an `onFocus` handler, which will receive the id of the input that is focused and the field value\n   */\n  onFocus?: (id: string, data: any) => void;\n  // <form /> HTML attributes\n  /** The value of this prop will be passed to the `accept-charset` HTML attribute on the form */\n  acceptcharset?: string;\n  /** The value of this prop will be passed to the `action` HTML attribute on the form\n   *\n   * NOTE: this just renders the `action` attribute in the HTML markup. There is no real network request being sent to\n   * this `action` on submit. Instead, react-jsonschema-form catches the submit event with `event.preventDefault()`\n   * and then calls the `onSubmit` function, where you could send a request programmatically with `fetch` or similar.\n   */\n  action?: string;\n  /** The value of this prop will be passed to the `autocomplete` HTML attribute on the form */\n  autoComplete?: string;\n  /** The value of this prop will be passed to the `class` HTML attribute on the form */\n  className?: string;\n  /** The value of this prop will be passed to the `enctype` HTML attribute on the form */\n  enctype?: string;\n  /** The value of this prop will be passed to the `id` HTML attribute on the form */\n  id?: string;\n  /** The value of this prop will be passed to the `name` HTML attribute on the form */\n  name?: string;\n  /** The value of this prop will be passed to the `method` HTML attribute on the form */\n  method?: string;\n  /** It's possible to change the default `form` tag name to a different HTML tag, which can be helpful if you are\n   * nesting forms. However, native browser form behaviour, such as submitting when the `Enter` key is pressed, may no\n   * longer work\n   */\n  tagName?: ElementType;\n  /** The value of this prop will be passed to the `target` HTML attribute on the form */\n  target?: string;\n  // Errors and validation\n  /** Formerly the `validate` prop; Takes a function that specifies custom validation rules for the form */\n  customValidate?: CustomValidator<T, S, F>;\n  /** This prop allows passing in custom errors that are augmented with the existing JSON Schema errors on the form; it\n   * can be used to implement asynchronous validation. By default, these are non-blocking errors, meaning that you can\n   * still submit the form when these are the only errors displayed to the user.\n   */\n  extraErrors?: ErrorSchema<T>;\n  /** If set to true, causes the `extraErrors` to become blocking when the form is submitted */\n  extraErrorsBlockSubmit?: boolean;\n  /** If set to true, turns off HTML5 validation on the form; Set to `false` by default */\n  noHtml5Validate?: boolean;\n  /** If set to true, turns off all validation. Set to `false` by default\n   *\n   * @deprecated - In a future release, this switch may be replaced by making `validator` prop optional\n   */\n  noValidate?: boolean;\n  /** If set to true, the form will perform validation and show any validation errors whenever the form data is changed,\n   * rather than just on submit\n   */\n  liveValidate?: boolean;\n  /** If `omitExtraData` and `liveOmit` are both set to true, then extra form data values that are not in any form field\n   * will be removed whenever `onChange` is called. Set to `false` by default\n   */\n  liveOmit?: boolean;\n  /** If set to true, then extra form data values that are not in any form field will be removed whenever `onSubmit` is\n   * called. Set to `false` by default.\n   */\n  omitExtraData?: boolean;\n  /** When this prop is set to `top` or 'bottom', a list of errors (or the custom error list defined in the `ErrorList`) will also\n   * show. When set to false, only inline input validation errors will be shown. Set to `top` by default\n   */\n  showErrorList?: false | 'top' | 'bottom';\n  /** A function can be passed to this prop in order to make modifications to the default errors resulting from JSON\n   * Schema validation\n   */\n  transformErrors?: ErrorTransformer<T, S, F>;\n  /** If set to true, then the first field with an error will receive the focus when the form is submitted with errors\n   */\n  focusOnFirstError?: boolean | ((error: RJSFValidationError) => void);\n  /** Optional string translation function, if provided, allows users to change the translation of the RJSF internal\n   * strings. Some strings contain replaceable parameter values as indicated by `%1`, `%2`, etc. The number after the\n   * `%` indicates the order of the parameter. The ordering of parameters is important because some languages may choose\n   * to put the second parameter before the first in its translation.\n   */\n  translateString?: Registry['translateString'];\n  /** Optional configuration object with flags, if provided, allows users to override default form state behavior\n   * Currently only affecting minItems on array fields and handling of setting defaults based on the value of\n   * `emptyObjectFields`\n   */\n  experimental_defaultFormStateBehavior?: Experimental_DefaultFormStateBehavior;\n  // Private\n  /**\n   * _internalFormWrapper is currently used by the semantic-ui theme to provide a custom wrapper around `<Form />`\n   * that supports the proper rendering of those themes. To use this prop, one must pass a component that takes two\n   * props: `children` and `as`. That component, at minimum, should render the `children` inside of a <form /> tag\n   * unless `as` is provided, in which case, use the `as` prop in place of `<form />`.\n   * i.e.:\n   * ```\n   * export default function InternalForm({ children, as }) {\n   *   const FormTag = as || 'form';\n   *   return <FormTag>{children}</FormTag>;\n   * }\n   * ```\n   *\n   * Use at your own risk as this prop is private and may change at any time without notice.\n   */\n  _internalFormWrapper?: ElementType;\n  /** Support receiving a React ref to the Form\n   */\n  ref?: Ref<Form<T, S, F>>;\n}\n\n/** The data that is contained within the state for the `Form` */\nexport interface FormState<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any> {\n  /** The JSON schema object for the form */\n  schema: S;\n  /** The uiSchema for the form */\n  uiSchema: UiSchema<T, S, F>;\n  /** The `IdSchema` for the form, computed from the `schema`, the `rootFieldId`, the `formData` and the `idPrefix` and\n   * `idSeparator` props.\n   */\n  idSchema: IdSchema<T>;\n  /** The schemaUtils implementation used by the `Form`, created from the `validator` and the `schema` */\n  schemaUtils: SchemaUtilsType<T, S, F>;\n  /** The current data for the form, computed from the `formData` prop and the changes made by the user */\n  formData?: T;\n  /** Flag indicating whether the form is in edit mode, true when `formData` is passed to the form, otherwise false */\n  edit: boolean;\n  /** The current list of errors for the form, includes `extraErrors` */\n  errors: RJSFValidationError[];\n  /** The current errors, in `ErrorSchema` format, for the form, includes `extraErrors` */\n  errorSchema: ErrorSchema<T>;\n  /** The current list of errors for the form directly from schema validation, does NOT include `extraErrors` */\n  schemaValidationErrors: RJSFValidationError[];\n  /** The current errors, in `ErrorSchema` format, for the form directly from schema validation, does NOT include\n   * `extraErrors`\n   */\n  schemaValidationErrorSchema: ErrorSchema<T>;\n  // Private\n  /** @description result of schemaUtils.retrieveSchema(schema, formData). This a memoized value to avoid re calculate at internal functions (getStateFromProps, onChange) */\n  retrievedSchema: S;\n}\n\n/** The event data passed when changes have been made to the form, includes everything from the `FormState` except\n * the schema validation errors. An additional `status` is added when returned from `onSubmit`\n */\nexport interface IChangeEvent<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>\n  extends Omit<FormState<T, S, F>, 'schemaValidationErrors' | 'schemaValidationErrorSchema'> {\n  /** The status of the form when submitted */\n  status?: 'submitted';\n}\n\n/** The `Form` component renders the outer form and all the fields defined in the `schema` */\nexport default class Form<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n> extends Component<FormProps<T, S, F>, FormState<T, S, F>> {\n  /** The ref used to hold the `form` element, this needs to be `any` because `tagName` or `_internalFormWrapper` can\n   * provide any possible type here\n   */\n  formElement: RefObject<any>;\n\n  /** Constructs the `Form` from the `props`. Will setup the initial state from the props. It will also call the\n   * `onChange` handler if the initially provided `formData` is modified to add missing default values as part of the\n   * state construction.\n   *\n   * @param props - The initial props for the `Form`\n   */\n  constructor(props: FormProps<T, S, F>) {\n    super(props);\n\n    if (!props.validator) {\n      throw new Error('A validator is required for Form functionality to work');\n    }\n\n    this.state = this.getStateFromProps(props, props.formData);\n    if (this.props.onChange && !deepEquals(this.state.formData, this.props.formData)) {\n      this.props.onChange(this.state);\n    }\n    this.formElement = createRef();\n  }\n\n  /**\n   * `getSnapshotBeforeUpdate` is a React lifecycle method that is invoked right before the most recently rendered\n   * output is committed to the DOM. It enables your component to capture current values (e.g., scroll position) before\n   * they are potentially changed.\n   *\n   * In this case, it checks if the props have changed since the last render. If they have, it computes the next state\n   * of the component using `getStateFromProps` method and returns it along with a `shouldUpdate` flag set to `true` IF\n   * the `nextState` and `prevState` are different, otherwise `false`. This ensures that we have the most up-to-date\n   * state ready to be applied in `componentDidUpdate`.\n   *\n   * If `formData` hasn't changed, it simply returns an object with `shouldUpdate` set to `false`, indicating that a\n   * state update is not necessary.\n   *\n   * @param prevProps - The previous set of props before the update.\n   * @param prevState - The previous state before the update.\n   * @returns Either an object containing the next state and a flag indicating that an update should occur, or an object\n   *        with a flag indicating that an update is not necessary.\n   */\n  getSnapshotBeforeUpdate(\n    prevProps: FormProps<T, S, F>,\n    prevState: FormState<T, S, F>\n  ): { nextState: FormState<T, S, F>; shouldUpdate: true } | { shouldUpdate: false } {\n    if (!deepEquals(this.props, prevProps)) {\n      const nextState = this.getStateFromProps(\n        this.props,\n        this.props.formData,\n        prevProps.schema !== this.props.schema ? undefined : this.state.retrievedSchema\n      );\n      const shouldUpdate = !deepEquals(nextState, prevState);\n      return { nextState, shouldUpdate };\n    }\n    return { shouldUpdate: false };\n  }\n\n  /**\n   * `componentDidUpdate` is a React lifecycle method that is invoked immediately after updating occurs. This method is\n   * not called for the initial render.\n   *\n   * Here, it checks if an update is necessary based on the `shouldUpdate` flag received from `getSnapshotBeforeUpdate`.\n   * If an update is required, it applies the next state and, if needed, triggers the `onChange` handler to inform about\n   * changes.\n   *\n   * This method effectively replaces the deprecated `UNSAFE_componentWillReceiveProps`, providing a safer alternative\n   * to handle prop changes and state updates.\n   *\n   * @param _ - The previous set of props.\n   * @param prevState - The previous state of the component before the update.\n   * @param snapshot - The value returned from `getSnapshotBeforeUpdate`.\n   */\n  componentDidUpdate(\n    _: FormProps<T, S, F>,\n    prevState: FormState<T, S, F>,\n    snapshot: { nextState: FormState<T, S, F>; shouldUpdate: true } | { shouldUpdate: false }\n  ) {\n    if (snapshot.shouldUpdate) {\n      const { nextState } = snapshot;\n\n      if (\n        !deepEquals(nextState.formData, this.props.formData) &&\n        !deepEquals(nextState.formData, prevState.formData) &&\n        this.props.onChange\n      ) {\n        this.props.onChange(nextState);\n      }\n      this.setState(nextState);\n    }\n  }\n\n  /** Extracts the updated state from the given `props` and `inputFormData`. As part of this process, the\n   * `inputFormData` is first processed to add any missing required defaults. After that, the data is run through the\n   * validation process IF required by the `props`.\n   *\n   * @param props - The props passed to the `Form`\n   * @param inputFormData - The new or current data for the `Form`\n   * @returns - The new state for the `Form`\n   */\n  getStateFromProps(props: FormProps<T, S, F>, inputFormData?: T, retrievedSchema?: S): FormState<T, S, F> {\n    const state: FormState<T, S, F> = this.state || {};\n    const schema = 'schema' in props ? props.schema : this.props.schema;\n    const uiSchema: UiSchema<T, S, F> = ('uiSchema' in props ? props.uiSchema! : this.props.uiSchema!) || {};\n    const edit = typeof inputFormData !== 'undefined';\n    const liveValidate = 'liveValidate' in props ? props.liveValidate : this.props.liveValidate;\n    const mustValidate = edit && !props.noValidate && liveValidate;\n    const rootSchema = schema;\n    const experimental_defaultFormStateBehavior =\n      'experimental_defaultFormStateBehavior' in props\n        ? props.experimental_defaultFormStateBehavior\n        : this.props.experimental_defaultFormStateBehavior;\n    let schemaUtils: SchemaUtilsType<T, S, F> = state.schemaUtils;\n    if (\n      !schemaUtils ||\n      schemaUtils.doesSchemaUtilsDiffer(props.validator, rootSchema, experimental_defaultFormStateBehavior)\n    ) {\n      schemaUtils = createSchemaUtils<T, S, F>(props.validator, rootSchema, experimental_defaultFormStateBehavior);\n    }\n    const formData: T = schemaUtils.getDefaultFormState(schema, inputFormData) as T;\n    const _retrievedSchema = retrievedSchema ?? schemaUtils.retrieveSchema(schema, formData);\n\n    const getCurrentErrors = (): ValidationData<T> => {\n      if (props.noValidate) {\n        return { errors: [], errorSchema: {} };\n      } else if (!props.liveValidate) {\n        return {\n          errors: state.schemaValidationErrors || [],\n          errorSchema: state.schemaValidationErrorSchema || {},\n        };\n      }\n      return {\n        errors: state.errors || [],\n        errorSchema: state.errorSchema || {},\n      };\n    };\n\n    let errors: RJSFValidationError[];\n    let errorSchema: ErrorSchema<T> | undefined;\n    let schemaValidationErrors: RJSFValidationError[] = state.schemaValidationErrors;\n    let schemaValidationErrorSchema: ErrorSchema<T> = state.schemaValidationErrorSchema;\n    if (mustValidate) {\n      const schemaValidation = this.validate(formData, schema, schemaUtils, _retrievedSchema);\n      errors = schemaValidation.errors;\n      errorSchema = schemaValidation.errorSchema;\n      schemaValidationErrors = errors;\n      schemaValidationErrorSchema = errorSchema;\n    } else {\n      const currentErrors = getCurrentErrors();\n      errors = currentErrors.errors;\n      errorSchema = currentErrors.errorSchema;\n    }\n    if (props.extraErrors) {\n      const merged = validationDataMerge({ errorSchema, errors }, props.extraErrors);\n      errorSchema = merged.errorSchema;\n      errors = merged.errors;\n    }\n    const idSchema = schemaUtils.toIdSchema(\n      _retrievedSchema,\n      uiSchema['ui:rootFieldId'],\n      formData,\n      props.idPrefix,\n      props.idSeparator\n    );\n    const nextState: FormState<T, S, F> = {\n      schemaUtils,\n      schema,\n      uiSchema,\n      idSchema,\n      formData,\n      edit,\n      errors,\n      errorSchema,\n      schemaValidationErrors,\n      schemaValidationErrorSchema,\n      retrievedSchema: _retrievedSchema,\n    };\n    return nextState;\n  }\n\n  /** React lifecycle method that is used to determine whether component should be updated.\n   *\n   * @param nextProps - The next version of the props\n   * @param nextState - The next version of the state\n   * @returns - True if the component should be updated, false otherwise\n   */\n  shouldComponentUpdate(nextProps: FormProps<T, S, F>, nextState: FormState<T, S, F>): boolean {\n    return shouldRender(this, nextProps, nextState);\n  }\n\n  /** Validates the `formData` against the `schema` using the `altSchemaUtils` (if provided otherwise it uses the\n   * `schemaUtils` in the state), returning the results.\n   *\n   * @param formData - The new form data to validate\n   * @param schema - The schema used to validate against\n   * @param altSchemaUtils - The alternate schemaUtils to use for validation\n   */\n  validate(\n    formData: T | undefined,\n    schema = this.props.schema,\n    altSchemaUtils?: SchemaUtilsType<T, S, F>,\n    retrievedSchema?: S\n  ): ValidationData<T> {\n    const schemaUtils = altSchemaUtils ? altSchemaUtils : this.state.schemaUtils;\n    const { customValidate, transformErrors, uiSchema } = this.props;\n    const resolvedSchema = retrievedSchema ?? schemaUtils.retrieveSchema(schema, formData);\n    return schemaUtils\n      .getValidator()\n      .validateFormData(formData, resolvedSchema, customValidate, transformErrors, uiSchema);\n  }\n\n  /** Renders any errors contained in the `state` in using the `ErrorList`, if not disabled by `showErrorList`. */\n  renderErrors(registry: Registry<T, S, F>) {\n    const { errors, errorSchema, schema, uiSchema } = this.state;\n    const { formContext } = this.props;\n    const options = getUiOptions<T, S, F>(uiSchema);\n    const ErrorListTemplate = getTemplate<'ErrorListTemplate', T, S, F>('ErrorListTemplate', registry, options);\n\n    if (errors && errors.length) {\n      return (\n        <ErrorListTemplate\n          errors={errors}\n          errorSchema={errorSchema || {}}\n          schema={schema}\n          uiSchema={uiSchema}\n          formContext={formContext}\n          registry={registry}\n        />\n      );\n    }\n    return null;\n  }\n\n  /** Returns the `formData` with only the elements specified in the `fields` list\n   *\n   * @param formData - The data for the `Form`\n   * @param fields - The fields to keep while filtering\n   */\n  getUsedFormData = (formData: T | undefined, fields: string[][]): T | undefined => {\n    // For the case of a single input form\n    if (fields.length === 0 && typeof formData !== 'object') {\n      return formData;\n    }\n\n    // _pick has incorrect type definition, it works with string[][], because lodash/hasIn supports it\n    const data: GenericObjectType = _pick(formData, fields as unknown as string[]);\n    if (Array.isArray(formData)) {\n      return Object.keys(data).map((key: string) => data[key]) as unknown as T;\n    }\n\n    return data as T;\n  };\n\n  /** Returns the list of field names from inspecting the `pathSchema` as well as using the `formData`\n   *\n   * @param pathSchema - The `PathSchema` object for the form\n   * @param [formData] - The form data to use while checking for empty objects/arrays\n   */\n  getFieldNames = (pathSchema: PathSchema<T>, formData?: T): string[][] => {\n    const getAllPaths = (_obj: GenericObjectType, acc: string[][] = [], paths: string[][] = [[]]) => {\n      Object.keys(_obj).forEach((key: string) => {\n        if (typeof _obj[key] === 'object') {\n          const newPaths = paths.map((path) => [...path, key]);\n          // If an object is marked with additionalProperties, all its keys are valid\n          if (_obj[key][RJSF_ADDITONAL_PROPERTIES_FLAG] && _obj[key][NAME_KEY] !== '') {\n            acc.push(_obj[key][NAME_KEY]);\n          } else {\n            getAllPaths(_obj[key], acc, newPaths);\n          }\n        } else if (key === NAME_KEY && _obj[key] !== '') {\n          paths.forEach((path) => {\n            const formValue = _get(formData, path);\n            // adds path to fieldNames if it points to a value\n            // or an empty object/array\n            if (\n              typeof formValue !== 'object' ||\n              _isEmpty(formValue) ||\n              (Array.isArray(formValue) && formValue.every((val) => typeof val !== 'object'))\n            ) {\n              acc.push(path);\n            }\n          });\n        }\n      });\n      return acc;\n    };\n\n    return getAllPaths(pathSchema);\n  };\n\n  /** Function to handle changes made to a field in the `Form`. This handler receives an entirely new copy of the\n   * `formData` along with a new `ErrorSchema`. It will first update the `formData` with any missing default fields and\n   * then, if `omitExtraData` and `liveOmit` are turned on, the `formData` will be filterer to remove any extra data not\n   * in a form field. Then, the resulting formData will be validated if required. The state will be updated with the new\n   * updated (potentially filtered) `formData`, any errors that resulted from validation. Finally the `onChange`\n   * callback will be called if specified with the updated state.\n   *\n   * @param formData - The new form data from a change to a field\n   * @param newErrorSchema - The new `ErrorSchema` based on the field change\n   * @param id - The id of the field that caused the change\n   */\n  onChange = (formData: T | undefined, newErrorSchema?: ErrorSchema<T>, id?: string) => {\n    const { extraErrors, omitExtraData, liveOmit, noValidate, liveValidate, onChange } = this.props;\n    const { schemaUtils, schema, retrievedSchema } = this.state;\n\n    if (isObject(formData) || Array.isArray(formData)) {\n      const newState = this.getStateFromProps(this.props, formData, retrievedSchema);\n      formData = newState.formData;\n    }\n\n    const mustValidate = !noValidate && liveValidate;\n    let state: Partial<FormState<T, S, F>> = { formData, schema };\n    let newFormData = formData;\n\n    let _retrievedSchema: S | undefined;\n    if (omitExtraData === true && liveOmit === true) {\n      _retrievedSchema = schemaUtils.retrieveSchema(schema, formData);\n      const pathSchema = schemaUtils.toPathSchema(_retrievedSchema, '', formData);\n\n      const fieldNames = this.getFieldNames(pathSchema, formData);\n\n      newFormData = this.getUsedFormData(formData, fieldNames);\n      state = {\n        formData: newFormData,\n      };\n    }\n\n    if (mustValidate) {\n      const schemaValidation = this.validate(newFormData, schema, schemaUtils, retrievedSchema);\n      let errors = schemaValidation.errors;\n      let errorSchema = schemaValidation.errorSchema;\n      const schemaValidationErrors = errors;\n      const schemaValidationErrorSchema = errorSchema;\n      if (extraErrors) {\n        const merged = validationDataMerge(schemaValidation, extraErrors);\n        errorSchema = merged.errorSchema;\n        errors = merged.errors;\n      }\n      state = {\n        formData: newFormData,\n        errors,\n        errorSchema,\n        schemaValidationErrors,\n        schemaValidationErrorSchema,\n      };\n    } else if (!noValidate && newErrorSchema) {\n      const errorSchema = extraErrors\n        ? (mergeObjects(newErrorSchema, extraErrors, 'preventDuplicates') as ErrorSchema<T>)\n        : newErrorSchema;\n      state = {\n        formData: newFormData,\n        errorSchema: errorSchema,\n        errors: toErrorList(errorSchema),\n      };\n    }\n    if (_retrievedSchema) {\n      state.retrievedSchema = _retrievedSchema;\n    }\n    this.setState(state as FormState<T, S, F>, () => onChange && onChange({ ...this.state, ...state }, id));\n  };\n\n  /**\n   * Callback function to handle reset form data.\n   * - Reset all fields with default values.\n   * - Reset validations and errors\n   *\n   */\n  reset = () => {\n    const { onChange } = this.props;\n    const newState = this.getStateFromProps(this.props, undefined);\n    const newFormData = newState.formData;\n    const state = {\n      formData: newFormData,\n      errorSchema: {},\n      errors: [] as unknown,\n      schemaValidationErrors: [] as unknown,\n      schemaValidationErrorSchema: {},\n    } as FormState<T, S, F>;\n\n    this.setState(state, () => onChange && onChange({ ...this.state, ...state }));\n  };\n\n  /** Callback function to handle when a field on the form is blurred. Calls the `onBlur` callback for the `Form` if it\n   * was provided.\n   *\n   * @param id - The unique `id` of the field that was blurred\n   * @param data - The data associated with the field that was blurred\n   */\n  onBlur = (id: string, data: any) => {\n    const { onBlur } = this.props;\n    if (onBlur) {\n      onBlur(id, data);\n    }\n  };\n\n  /** Callback function to handle when a field on the form is focused. Calls the `onFocus` callback for the `Form` if it\n   * was provided.\n   *\n   * @param id - The unique `id` of the field that was focused\n   * @param data - The data associated with the field that was focused\n   */\n  onFocus = (id: string, data: any) => {\n    const { onFocus } = this.props;\n    if (onFocus) {\n      onFocus(id, data);\n    }\n  };\n\n  /** Callback function to handle when the form is submitted. First, it prevents the default event behavior. Nothing\n   * happens if the target and currentTarget of the event are not the same. It will omit any extra data in the\n   * `formData` in the state if `omitExtraData` is true. It will validate the resulting `formData`, reporting errors\n   * via the `onError()` callback unless validation is disabled. Finally, it will add in any `extraErrors` and then call\n   * back the `onSubmit` callback if it was provided.\n   *\n   * @param event - The submit HTML form event\n   */\n  onSubmit = (event: FormEvent<any>) => {\n    event.preventDefault();\n    if (event.target !== event.currentTarget) {\n      return;\n    }\n\n    event.persist();\n    const { omitExtraData, extraErrors, noValidate, onSubmit } = this.props;\n    let { formData: newFormData } = this.state;\n    const { schema, schemaUtils } = this.state;\n\n    if (omitExtraData === true) {\n      const retrievedSchema = schemaUtils.retrieveSchema(schema, newFormData);\n      const pathSchema = schemaUtils.toPathSchema(retrievedSchema, '', newFormData);\n\n      const fieldNames = this.getFieldNames(pathSchema, newFormData);\n\n      newFormData = this.getUsedFormData(newFormData, fieldNames);\n    }\n\n    if (noValidate || this.validateForm()) {\n      // There are no errors generated through schema validation.\n      // Check for user provided errors and update state accordingly.\n      const errorSchema = extraErrors || {};\n      const errors = extraErrors ? toErrorList(extraErrors) : [];\n      this.setState(\n        {\n          formData: newFormData,\n          errors,\n          errorSchema,\n          schemaValidationErrors: [],\n          schemaValidationErrorSchema: {},\n        },\n        () => {\n          if (onSubmit) {\n            onSubmit({ ...this.state, formData: newFormData, status: 'submitted' }, event);\n          }\n        }\n      );\n    }\n  };\n\n  /** Returns the registry for the form */\n  getRegistry(): Registry<T, S, F> {\n    const { translateString: customTranslateString, uiSchema = {} } = this.props;\n    const { schemaUtils } = this.state;\n    const { fields, templates, widgets, formContext, translateString } = getDefaultRegistry<T, S, F>();\n    return {\n      fields: { ...fields, ...this.props.fields },\n      templates: {\n        ...templates,\n        ...this.props.templates,\n        ButtonTemplates: {\n          ...templates.ButtonTemplates,\n          ...this.props.templates?.ButtonTemplates,\n        },\n      },\n      widgets: { ...widgets, ...this.props.widgets },\n      rootSchema: this.props.schema,\n      formContext: this.props.formContext || formContext,\n      schemaUtils,\n      translateString: customTranslateString || translateString,\n      globalUiOptions: uiSchema[UI_GLOBAL_OPTIONS_KEY],\n    };\n  }\n\n  /** Provides a function that can be used to programmatically submit the `Form` */\n  submit() {\n    if (this.formElement.current) {\n      this.formElement.current.dispatchEvent(\n        new CustomEvent('submit', {\n          cancelable: true,\n        })\n      );\n      this.formElement.current.requestSubmit();\n    }\n  }\n\n  /** Attempts to focus on the field associated with the `error`. Uses the `property` field to compute path of the error\n   * field, then, using the `idPrefix` and `idSeparator` converts that path into an id. Then the input element with that\n   * id is attempted to be found using the `formElement` ref. If it is located, then it is focused.\n   *\n   * @param error - The error on which to focus\n   */\n  focusOnError(error: RJSFValidationError) {\n    const { idPrefix = 'root', idSeparator = '_' } = this.props;\n    const { property } = error;\n    const path = _toPath(property);\n    if (path[0] === '') {\n      // Most of the time the `.foo` property results in the first element being empty, so replace it with the idPrefix\n      path[0] = idPrefix;\n    } else {\n      // Otherwise insert the idPrefix into the first location using unshift\n      path.unshift(idPrefix);\n    }\n\n    const elementId = path.join(idSeparator);\n    let field = this.formElement.current.elements[elementId];\n    if (!field) {\n      // if not an exact match, try finding an input starting with the element id (like radio buttons or checkboxes)\n      field = this.formElement.current.querySelector(`input[id^=${elementId}`);\n    }\n    if (field && field.length) {\n      // If we got a list with length > 0\n      field = field[0];\n    }\n    if (field) {\n      field.focus();\n    }\n  }\n\n  /** Programmatically validate the form. If `onError` is provided, then it will be called with the list of errors the\n   * same way as would happen on form submission.\n   *\n   * @returns - True if the form is valid, false otherwise.\n   */\n  validateForm() {\n    const { extraErrors, extraErrorsBlockSubmit, focusOnFirstError, onError } = this.props;\n    const { formData, errors: prevErrors } = this.state;\n    const schemaValidation = this.validate(formData);\n    let errors = schemaValidation.errors;\n    let errorSchema = schemaValidation.errorSchema;\n    const schemaValidationErrors = errors;\n    const schemaValidationErrorSchema = errorSchema;\n    const hasError = errors.length > 0 || (extraErrors && extraErrorsBlockSubmit);\n    if (hasError) {\n      if (extraErrors) {\n        const merged = validationDataMerge(schemaValidation, extraErrors);\n        errorSchema = merged.errorSchema;\n        errors = merged.errors;\n      }\n      if (focusOnFirstError) {\n        if (typeof focusOnFirstError === 'function') {\n          focusOnFirstError(errors[0]);\n        } else {\n          this.focusOnError(errors[0]);\n        }\n      }\n      this.setState(\n        {\n          errors,\n          errorSchema,\n          schemaValidationErrors,\n          schemaValidationErrorSchema,\n        },\n        () => {\n          if (onError) {\n            onError(errors);\n          } else {\n            console.error('Form validation failed', errors);\n          }\n        }\n      );\n    } else if (prevErrors.length > 0) {\n      this.setState({\n        errors: [],\n        errorSchema: {},\n        schemaValidationErrors: [],\n        schemaValidationErrorSchema: {},\n      });\n    }\n    return !hasError;\n  }\n\n  /** Renders the `Form` fields inside the <form> | `tagName` or `_internalFormWrapper`, rendering any errors if\n   * needed along with the submit button or any children of the form.\n   */\n  render() {\n    const {\n      children,\n      id,\n      idPrefix,\n      idSeparator,\n      className = '',\n      tagName,\n      name,\n      method,\n      target,\n      action,\n      autoComplete,\n      enctype,\n      acceptcharset,\n      noHtml5Validate = false,\n      disabled = false,\n      readonly = false,\n      formContext,\n      showErrorList = 'top',\n      _internalFormWrapper,\n    } = this.props;\n\n    const { schema, uiSchema, formData, errorSchema, idSchema } = this.state;\n    const registry = this.getRegistry();\n    const { SchemaField: _SchemaField } = registry.fields;\n    const { SubmitButton } = registry.templates.ButtonTemplates;\n    // The `semantic-ui` and `material-ui` themes have `_internalFormWrapper`s that take an `as` prop that is the\n    // PropTypes.elementType to use for the inner tag, so we'll need to pass `tagName` along if it is provided.\n    // NOTE, the `as` prop is native to `semantic-ui` and is emulated in the `material-ui` theme\n    const as = _internalFormWrapper ? tagName : undefined;\n    const FormTag = _internalFormWrapper || tagName || 'form';\n\n    let { [SUBMIT_BTN_OPTIONS_KEY]: submitOptions = {} } = getUiOptions<T, S, F>(uiSchema);\n    if (disabled) {\n      submitOptions = { ...submitOptions, props: { ...submitOptions.props, disabled: true } };\n    }\n    const submitUiSchema = { [UI_OPTIONS_KEY]: { [SUBMIT_BTN_OPTIONS_KEY]: submitOptions } };\n\n    return (\n      <FormTag\n        className={className ? className : 'rjsf'}\n        id={id}\n        name={name}\n        method={method}\n        target={target}\n        action={action}\n        autoComplete={autoComplete}\n        encType={enctype}\n        acceptCharset={acceptcharset}\n        noValidate={noHtml5Validate}\n        onSubmit={this.onSubmit}\n        as={as}\n        ref={this.formElement}\n      >\n        {showErrorList === 'top' && this.renderErrors(registry)}\n        <_SchemaField\n          name=''\n          schema={schema}\n          uiSchema={uiSchema}\n          errorSchema={errorSchema}\n          idSchema={idSchema}\n          idPrefix={idPrefix}\n          idSeparator={idSeparator}\n          formContext={formContext}\n          formData={formData}\n          onChange={this.onChange}\n          onBlur={this.onBlur}\n          onFocus={this.onFocus}\n          registry={registry}\n          disabled={disabled}\n          readonly={readonly}\n        />\n\n        {children ? children : <SubmitButton uiSchema={submitUiSchema} registry={registry} />}\n        {showErrorList === 'bottom' && this.renderErrors(registry)}\n      </FormTag>\n    );\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}