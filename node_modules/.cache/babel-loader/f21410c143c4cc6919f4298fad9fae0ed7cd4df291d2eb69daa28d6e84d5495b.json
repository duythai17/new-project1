{"ast":null,"code":"export {};","map":{"version":3,"names":[],"sources":["D:\\Reactjs\\my-app\\node_modules\\@rjsf\\utils\\src\\types.ts"],"sourcesContent":["import type {\n  ButtonHTMLAttributes,\n  ChangeEvent,\n  ComponentType,\n  HTMLAttributes,\n  ReactElement,\n  ReactNode,\n  StyleHTMLAttributes,\n} from 'react';\nimport { JSONSchema7 } from 'json-schema';\n\nimport { TranslatableString } from './enums';\n\n/** The representation of any generic object type, usually used as an intersection on other types to make them more\n * flexible in the properties they support (i.e. anything else)\n */\nexport type GenericObjectType = {\n  [name: string]: any;\n};\n\n/** Map the JSONSchema7 to our own type so that we can easily bump to a more recent version at some future date and only\n * have to update this one type.\n */\nexport type StrictRJSFSchema = JSONSchema7;\n\n/** Allow for more flexible schemas (i.e. draft-2019) than the strict JSONSchema7\n */\nexport type RJSFSchema = StrictRJSFSchema & GenericObjectType;\n\n/** Alias GenericObjectType as FormContextType to allow us to remap this at some future date\n */\nexport type FormContextType = GenericObjectType;\n\n/** Experimental feature that specifies the Array `minItems` default form state behavior\n */\nexport type Experimental_ArrayMinItems = {\n  /** Optional enumerated flag controlling how array minItems are populated, defaulting to `all`:\n   * - `all`: Legacy behavior, populate minItems entries with default values initially and include an empty array when\n   *        no values have been defined.\n   * - `requiredOnly`: Ignore `minItems` on a field when calculating defaults unless the field is required.\n   * - `never`: Ignore `minItems` on a field even the field is required.\n   */\n  populate?: 'all' | 'requiredOnly' | 'never';\n  /** When `formData` is provided and does not contain `minItems` worth of data, this flag (`false` by default) controls\n   * whether the extra data provided by the defaults is appended onto the existing `formData` items to ensure the\n   * `minItems` condition is met. When false (legacy behavior), only the `formData` provided is merged into the default\n   * form state, even if there are fewer than the `minItems`. When true, the defaults are appended onto the end of the\n   * `formData` until the `minItems` condition is met.\n   */\n  mergeExtraDefaults?: boolean;\n};\n\n/** Experimental features to specify different default form state behaviors. Currently, this affects the\n * handling of optional array fields where `minItems` is set and handling of setting defaults based on the\n * value of `emptyObjectFields`.\n */\nexport type Experimental_DefaultFormStateBehavior = {\n  /** Optional object, that controls how the default form state for arrays with `minItems` is handled. When not provided\n   * it defaults to `{ populate: 'all' }`.\n   */\n  arrayMinItems?: Experimental_ArrayMinItems;\n  /** Optional enumerated flag controlling how empty object fields are populated, defaulting to `populateAllDefaults`:\n   * - `populateAllDefaults`: Legacy behavior - set default when there is a primitive value, an non-empty object field,\n   *        or the field itself is required  |\n   * - `populateRequiredDefaults`: Only sets default when a value is an object and its parent field is required, or it\n   *        is a primitive value and it is required |\n   * - `skipDefaults`: Does not set defaults                                                                                                      |\n   */\n  emptyObjectFields?: 'populateAllDefaults' | 'populateRequiredDefaults' | 'skipDefaults';\n  /**\n   * Optional flag to compute the default form state using allOf and if/then/else schemas. Defaults to `skipDefaults'.\n   */\n  allOf?: 'populateDefaults' | 'skipDefaults';\n};\n\n/** The interface representing a Date object that contains an optional time */\nexport interface DateObject {\n  /** The year of the Date */\n  year: number;\n  /** The month of the Date */\n  month: number;\n  /** The day of the Date */\n  day: number;\n  /** The optional hours for the time of a Date */\n  hour?: number;\n  /** The optional minutes for the time of a Date */\n  minute?: number;\n  /** The optional seconds for the time of a Date */\n  second?: number;\n}\n\n/** Properties describing a Range specification in terms of attribute that can be added to the `HTML` `<input>` */\nexport type RangeSpecType = {\n  /** Specifies the interval between legal numbers in an input field */\n  step?: number;\n  /** Specifies a minimum value for an <input> element */\n  min?: number;\n  /** Specifies the maximum value for an <input> element */\n  max?: number;\n};\n\n/** Properties describing a Range specification in terms of attribute that can be added to the `HTML` `<input>` */\nexport type InputPropsType = Omit<RangeSpecType, 'step'> & {\n  /** Specifies the type of the <input> element */\n  type: string;\n  /** Specifies the interval between legal numbers in an input field or \"any\" */\n  step?: number | 'any';\n  /** Specifies the `autoComplete` value for an <input> element */\n  autoComplete?: HTMLInputElement['autocomplete'];\n};\n\n/** Type describing an id used for a field in the `IdSchema` */\nexport type FieldId = {\n  /** The id for a field */\n  $id: string;\n};\n\n/** Type describing a recursive structure of `FieldId`s for an object with a non-empty set of keys */\nexport type IdSchema<T = any> = FieldId & {\n  /** The set of ids for fields in the recursive object structure */\n  [key in keyof T]?: IdSchema<T[key]>;\n};\n\n/** Type describing a name used for a field in the `PathSchema` */\nexport type FieldPath = {\n  /** The name of a field */\n  $name: string;\n};\n\n/** Type describing a recursive structure of `FieldPath`s for an object with a non-empty set of keys */\nexport type PathSchema<T = any> = FieldPath & {\n  /** The set of names for fields in the recursive object structure */\n  [key in keyof T]?: PathSchema<T[key]>;\n};\n\n/** The type for error produced by RJSF schema validation */\nexport type RJSFValidationError = {\n  /** Name of the error, for example, \"required\" or \"minLength\" */\n  name?: string;\n  /** Message, for example, \"is a required property\" or \"should NOT be shorter than 3 characters\" */\n  message?: string;\n  /** An object with the error params returned by ajv\n   * ([see doc](https://github.com/ajv-validator/ajv/tree/6a671057ea6aae690b5967ee26a0ddf8452c6297#error-parameters)\n   * for more info)\n   */\n  params?: any;\n  /** A string in Javascript property accessor notation to the data path of the field with the error. For example,\n   * `.name` or `['first-name']`\n   */\n  property?: string;\n  /** JSON pointer to the schema of the keyword that failed validation. For example, `#/fields/firstName/required`.\n   * (Note: this may sometimes be wrong due to a [bug in ajv](https://github.com/ajv-validator/ajv/issues/512))\n   */\n  schemaPath?: string;\n  /** Full error name, for example \".name is a required property\" */\n  stack: string;\n};\n\n/** The type that describes an error in a field */\nexport type FieldError = string;\n\n/** The type that describes the list of errors for a field */\nexport type FieldErrors = {\n  /** The list of errors for the field */\n  __errors?: FieldError[];\n};\n\n/** Type describing a recursive structure of `FieldErrors`s for an object with a non-empty set of keys */\nexport type ErrorSchema<T = any> = FieldErrors & {\n  /** The set of errors for fields in the recursive object structure */\n  [key in keyof T]?: ErrorSchema<T[key]>;\n};\n\n/** Type that describes the list of errors for a field being actively validated by a custom validator */\nexport type FieldValidation = FieldErrors & {\n  /** Function that will add a new `message` to the list of errors */\n  addError: (message: string) => void;\n};\n\n/** Type describing a recursive structure of `FieldValidation`s for an object with a non-empty set of keys */\nexport type FormValidation<T = any> = FieldValidation & {\n  /** The set of validation objects for fields in the recursive object structure */\n  [key in keyof T]?: FormValidation<T[key]>;\n};\n\n/** The properties that are passed to an `ErrorListTemplate` implementation */\nexport type ErrorListProps<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any> = {\n  /** The errorSchema constructed by `Form` */\n  errorSchema: ErrorSchema<T>;\n  /** An array of the errors */\n  errors: RJSFValidationError[];\n  /** The `formContext` object that was passed to `Form` */\n  formContext?: F;\n  /** The schema that was passed to `Form` */\n  schema: S;\n  /** The uiSchema that was passed to `Form` */\n  uiSchema?: UiSchema<T, S, F>;\n  /** The `registry` object */\n  registry: Registry<T, S, F>;\n};\n\n/** The properties that are passed to an `FieldErrorTemplate` implementation */\nexport type FieldErrorProps<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any> = {\n  /** The errorSchema constructed by `Form` */\n  errorSchema?: ErrorSchema<T>;\n  /** An array of the errors */\n  errors?: Array<string | ReactElement>;\n  /** The tree of unique ids for every child field */\n  idSchema: IdSchema<T>;\n  /** The schema that was passed to field */\n  schema: S;\n  /** The uiSchema that was passed to field */\n  uiSchema?: UiSchema<T, S, F>;\n  /** The `registry` object */\n  registry: Registry<T, S, F>;\n};\n\n/** The properties that are passed to an `FieldHelpTemplate` implementation */\nexport type FieldHelpProps<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any> = {\n  /** The help information to be rendered */\n  help?: string | ReactElement;\n  /** The tree of unique ids for every child field */\n  idSchema: IdSchema<T>;\n  /** The schema that was passed to field */\n  schema: S;\n  /** The uiSchema that was passed to field */\n  uiSchema?: UiSchema<T, S, F>;\n  /** Flag indicating whether there are errors associated with this field */\n  hasErrors?: boolean;\n  /** The `registry` object */\n  registry: Registry<T, S, F>;\n};\n\n/** The set of `Fields` stored in the `Registry` */\nexport type RegistryFieldsType<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any> = {\n  /** A `Field` indexed by `name` */\n  [name: string]: Field<T, S, F>;\n};\n\n/** The set of `Widgets` stored in the `Registry` */\nexport type RegistryWidgetsType<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any> = {\n  /** A `Widget` indexed by `name` */\n  [name: string]: Widget<T, S, F>;\n};\n\n/** The set of RJSF templates that can be overridden by themes or users */\nexport interface TemplatesType<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any> {\n  /** The template to use while rendering normal or fixed array fields */\n  ArrayFieldTemplate: ComponentType<ArrayFieldTemplateProps<T, S, F>>;\n  /** The template to use while rendering the description for an array field */\n  ArrayFieldDescriptionTemplate: ComponentType<ArrayFieldDescriptionProps<T, S, F>>;\n  /** The template to use while rendering an item in an array field */\n  ArrayFieldItemTemplate: ComponentType<ArrayFieldTemplateItemType<T, S, F>>;\n  /** The template to use while rendering the title for an array field */\n  ArrayFieldTitleTemplate: ComponentType<ArrayFieldTitleProps<T, S, F>>;\n  /** The template to use while rendering the standard html input */\n  BaseInputTemplate: ComponentType<BaseInputTemplateProps<T, S, F>>;\n  /** The template to use for rendering the description of a field */\n  DescriptionFieldTemplate: ComponentType<DescriptionFieldProps<T, S, F>>;\n  /** The template to use while rendering the errors for the whole form */\n  ErrorListTemplate: ComponentType<ErrorListProps<T, S, F>>;\n  /** The template to use while rendering the errors for a single field */\n  FieldErrorTemplate: ComponentType<FieldErrorProps<T, S, F>>;\n  /** The template to use while rendering the errors for a single field */\n  FieldHelpTemplate: ComponentType<FieldHelpProps<T, S, F>>;\n  /** The template to use while rendering a field */\n  FieldTemplate: ComponentType<FieldTemplateProps<T, S, F>>;\n  /** The template to use while rendering an object */\n  ObjectFieldTemplate: ComponentType<ObjectFieldTemplateProps<T, S, F>>;\n  /** The template to use for rendering the title of a field */\n  TitleFieldTemplate: ComponentType<TitleFieldProps<T, S, F>>;\n  /** The template to use for rendering information about an unsupported field type in the schema */\n  UnsupportedFieldTemplate: ComponentType<UnsupportedFieldProps<T, S, F>>;\n  /** The template to use for rendering a field that allows a user to add additional properties */\n  WrapIfAdditionalTemplate: ComponentType<WrapIfAdditionalTemplateProps<T, S, F>>;\n  /** The set of templates associated with buttons in the form */\n  ButtonTemplates: {\n    /** The template to use for the main `Submit` button  */\n    SubmitButton: ComponentType<SubmitButtonProps<T, S, F>>;\n    /** The template to use for the Add button used for AdditionalProperties and Array items */\n    AddButton: ComponentType<IconButtonProps<T, S, F>>;\n    /** The template to use for the Copy button used for Array items */\n    CopyButton: ComponentType<IconButtonProps<T, S, F>>;\n    /** The template to use for the Move Down button used for Array items */\n    MoveDownButton: ComponentType<IconButtonProps<T, S, F>>;\n    /** The template to use for the Move Up button used for Array items */\n    MoveUpButton: ComponentType<IconButtonProps<T, S, F>>;\n    /** The template to use for the Remove button used for AdditionalProperties and Array items */\n    RemoveButton: ComponentType<IconButtonProps<T, S, F>>;\n  };\n}\n\n/** The set of UiSchema options that can be set globally and used as fallbacks at an individual template, field or\n * widget level when no field-level value of the option is provided.\n */\nexport type GlobalUISchemaOptions = {\n  /** Flag, if set to `false`, new items cannot be added to array fields, unless overridden (defaults to true) */\n  addable?: boolean;\n  /** Flag, if set to `true`, array items can be copied (defaults to false) */\n  copyable?: boolean;\n  /** Flag, if set to `false`, array items cannot be ordered (defaults to true) */\n  orderable?: boolean;\n  /** Flag, if set to `false`, array items will not be removable (defaults to true) */\n  removable?: boolean;\n  /** Field labels are rendered by default. Labels may be omitted by setting the `label` option to `false` */\n  label?: boolean;\n  /** When using `additionalProperties`, key collision is prevented by appending a unique integer to the duplicate key.\n   * This option allows you to change the separator between the original key name and the integer. Default is \"-\"\n   */\n  duplicateKeySuffixSeparator?: string;\n};\n\n/** The object containing the registered core, theme and custom fields and widgets as well as the root schema, form\n * context, schema utils and templates.\n */\nexport interface Registry<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any> {\n  /** The set of all fields used by the `Form`. Includes fields from `core`, theme-specific fields and any custom\n   * registered fields\n   */\n  fields: RegistryFieldsType<T, S, F>;\n  /** The set of templates used by the `Form`. Includes templates from `core`, theme-specific fields and any custom\n   * registered templates\n   */\n  templates: TemplatesType<T, S, F>;\n  /** The set of all widgets used by the `Form`. Includes widgets from `core`, theme-specific widgets and any custom\n   * registered widgets\n   */\n  widgets: RegistryWidgetsType<T, S, F>;\n  /** The `formContext` object that was passed to `Form` */\n  formContext: F;\n  /** The root schema, as passed to the `Form`, which can contain referenced definitions */\n  rootSchema: S;\n  /** The current implementation of the `SchemaUtilsType` (from `@rjsf/utils`) in use by the `Form`.  Used to call any\n   * of the validation-schema-based utility functions\n   */\n  schemaUtils: SchemaUtilsType<T, S>;\n  /** The string translation function to use when displaying any of the RJSF strings in templates, fields or widgets */\n  translateString: (stringKey: TranslatableString, params?: string[]) => string;\n  /** The optional global UI Options that are available for all templates, fields and widgets to access */\n  globalUiOptions?: GlobalUISchemaOptions;\n}\n\n/** The properties that are passed to a Field implementation */\nexport interface FieldProps<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>\n  extends GenericObjectType,\n    Pick<HTMLAttributes<HTMLElement>, Exclude<keyof HTMLAttributes<HTMLElement>, 'onBlur' | 'onFocus' | 'onChange'>> {\n  /** The JSON subschema object for this field */\n  schema: S;\n  /** The uiSchema for this field */\n  uiSchema?: UiSchema<T, S, F>;\n  /** The tree of unique ids for every child field */\n  idSchema: IdSchema<T>;\n  /** The data for this field */\n  formData?: T;\n  /** The tree of errors for this field and its children */\n  errorSchema?: ErrorSchema<T>;\n  /** The field change event handler; called with the updated form data and an optional `ErrorSchema` */\n  onChange: (newFormData: T | undefined, es?: ErrorSchema<T>, id?: string) => any;\n  /** The input blur event handler; call it with the field id and value */\n  onBlur: (id: string, value: any) => void;\n  /** The input focus event handler; call it with the field id and value */\n  onFocus: (id: string, value: any) => void;\n  /** The `formContext` object that you passed to `Form` */\n  formContext?: F;\n  /** A boolean value stating if the field should autofocus */\n  autofocus?: boolean;\n  /** A boolean value stating if the field is disabled */\n  disabled: boolean;\n  /** A boolean value stating if the field is hiding its errors */\n  hideError?: boolean;\n  /** A boolean value stating if the field is read-only */\n  readonly: boolean;\n  /** The required status of this field */\n  required?: boolean;\n  /** The unique name of the field, usually derived from the name of the property in the JSONSchema */\n  name: string;\n  /** To avoid collisions with existing ids in the DOM, it is possible to change the prefix used for ids;\n   * Default is `root`\n   */\n  idPrefix?: string;\n  /** To avoid using a path separator that is present in field names, it is possible to change the separator used for\n   * ids (Default is `_`)\n   */\n  idSeparator?: string;\n  /** An array of strings listing all generated error messages from encountered errors for this field */\n  rawErrors?: string[];\n  /** The `registry` object */\n  registry: Registry<T, S, F>;\n}\n\n/** The definition of a React-based Field component */\nexport type Field<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any> = ComponentType<\n  FieldProps<T, S, F>\n>;\n\n/** The properties that are passed to a FieldTemplate implementation */\nexport type FieldTemplateProps<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any> = {\n  /** The id of the field in the hierarchy. You can use it to render a label targeting the wrapped widget */\n  id: string;\n  /** A string containing the base CSS classes, merged with any custom ones defined in your uiSchema */\n  classNames?: string;\n  /** An object containing the style as defined in the `uiSchema` */\n  style?: StyleHTMLAttributes<any>;\n  /** The computed label for this field, as a string */\n  label: string;\n  /** A component instance rendering the field description, if one is defined (this will use any custom\n   * `DescriptionField` defined)\n   */\n  description?: ReactElement;\n  /** A string containing any `ui:description` uiSchema directive defined */\n  rawDescription?: string;\n  /** The field or widget component instance for this field row */\n  children: ReactElement;\n  /** A component instance listing any encountered errors for this field */\n  errors?: ReactElement;\n  /** An array of strings listing all generated error messages from encountered errors for this field */\n  rawErrors?: string[];\n  /** A component instance rendering any `ui:help` uiSchema directive defined */\n  help?: ReactElement;\n  /** A string containing any `ui:help` uiSchema directive defined. **NOTE:** `rawHelp` will be `undefined` if passed\n   * `ui:help` is a React component instead of a string\n   */\n  rawHelp?: string;\n  /** A boolean value stating if the field should be hidden */\n  hidden?: boolean;\n  /** A boolean value stating if the field is required */\n  required?: boolean;\n  /** A boolean value stating if the field is read-only */\n  readonly: boolean;\n  /** A boolean value stating if the field is hiding its errors */\n  hideError?: boolean;\n  /** A boolean value stating if the field is disabled */\n  disabled: boolean;\n  /** A boolean value stating if the label should be rendered or not. This is useful for nested fields in arrays where\n   * you don't want to clutter the UI\n   */\n  displayLabel?: boolean;\n  /** The schema object for this field */\n  schema: S;\n  /** The uiSchema object for this field */\n  uiSchema?: UiSchema<T, S, F>;\n  /** The `formContext` object that was passed to `Form` */\n  formContext?: F;\n  /** The formData for this field */\n  formData?: T;\n  /** The value change event handler; Can be called with a new value to change the value for this field */\n  onChange: FieldProps<T, S, F>['onChange'];\n  /** The key change event handler; Called when the key associated with a field is changed for an additionalProperty */\n  onKeyChange: (value: string) => () => void;\n  /** The property drop/removal event handler; Called when a field is removed in an additionalProperty context */\n  onDropPropertyClick: (value: string) => () => void;\n  /** The `registry` object */\n  registry: Registry<T, S, F>;\n};\n\n/** The properties that are passed to the `UnsupportedFieldTemplate` implementation */\nexport type UnsupportedFieldProps<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any> = {\n  /** The schema object for this field */\n  schema: S;\n  /** The tree of unique ids for every child field */\n  idSchema?: IdSchema<T>;\n  /** The reason why the schema field has an unsupported type */\n  reason: string;\n  /** The `registry` object */\n  registry: Registry<T, S, F>;\n};\n\n/** The properties that are passed to a `TitleFieldTemplate` implementation */\nexport type TitleFieldProps<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any> = {\n  /** The id of the field title in the hierarchy */\n  id: string;\n  /** The title for the field being rendered */\n  title: string;\n  /** The schema object for the field being titled */\n  schema: S;\n  /** The uiSchema object for this title field */\n  uiSchema?: UiSchema<T, S, F>;\n  /** A boolean value stating if the field is required */\n  required?: boolean;\n  /** The `registry` object */\n  registry: Registry<T, S, F>;\n};\n\n/** The properties that are passed to a `DescriptionFieldTemplate` implementation */\nexport type DescriptionFieldProps<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any> = {\n  /** The id of the field description in the hierarchy */\n  id: string;\n  /** The schema object for the field being described */\n  schema: S;\n  /** The uiSchema object for this description field */\n  uiSchema?: UiSchema<T, S, F>;\n  /** The description of the field being rendered */\n  description: string | ReactElement;\n  /** The `registry` object */\n  registry: Registry<T, S, F>;\n};\n\n/** The properties that are passed to a `ArrayFieldTitleTemplate` implementation */\nexport type ArrayFieldTitleProps<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n> = Omit<TitleFieldProps<T, S, F>, 'id' | 'title'> & {\n  /** The title for the field being rendered */\n  title?: string;\n  /** The idSchema of the field in the hierarchy */\n  idSchema: IdSchema<T>;\n};\n\n/** The properties that are passed to a `ArrayFieldDescriptionTemplate` implementation */\nexport type ArrayFieldDescriptionProps<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n> = Omit<DescriptionFieldProps<T, S, F>, 'id' | 'description'> & {\n  /** The description of the field being rendered */\n  description?: string | ReactElement;\n  /** The idSchema of the field in the hierarchy */\n  idSchema: IdSchema<T>;\n};\n\n/** The properties of each element in the ArrayFieldTemplateProps.items array */\nexport type ArrayFieldTemplateItemType<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n> = {\n  /** The html for the item's content */\n  children: ReactElement;\n  /** The className string */\n  className: string;\n  /** A boolean value stating if the array item is disabled */\n  disabled: boolean;\n  /** A boolean value stating whether new items can be added to the array */\n  canAdd: boolean;\n  /** A boolean value stating whether the array item can be copied, assumed false if missing */\n  hasCopy: boolean;\n  /** A boolean value stating whether the array item can be moved down */\n  hasMoveDown: boolean;\n  /** A boolean value stating whether the array item can be moved up */\n  hasMoveUp: boolean;\n  /** A boolean value stating whether the array item can be removed */\n  hasRemove: boolean;\n  /** A boolean value stating whether the array item has a toolbar */\n  hasToolbar: boolean;\n  /** A number stating the index the array item occurs in `items` */\n  index: number;\n  /** A number stating the total number `items` in the array */\n  totalItems: number;\n  /** Returns a function that adds a new item at `index` */\n  onAddIndexClick: (index: number) => (event?: any) => void;\n  /** Returns a function that copies the item at `index` into the position at `index + 1` */\n  onCopyIndexClick: (index: number) => (event?: any) => void;\n  /** Returns a function that removes the item at `index` */\n  onDropIndexClick: (index: number) => (event?: any) => void;\n  /** Returns a function that swaps the items at `index` with `newIndex` */\n  onReorderClick: (index: number, newIndex: number) => (event?: any) => void;\n  /** A boolean value stating if the array item is read-only */\n  readonly: boolean;\n  /** A stable, unique key for the array item */\n  key: string;\n  /** The schema object for this array item */\n  schema: S;\n  /** The uiSchema object for this array item */\n  uiSchema?: UiSchema<T, S, F>;\n  /** The `registry` object */\n  registry: Registry<T, S, F>;\n};\n\n/** The properties that are passed to an ArrayFieldTemplate implementation */\nexport type ArrayFieldTemplateProps<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n> = {\n  /** A boolean value stating whether new elements can be added to the array */\n  canAdd?: boolean;\n  /** The className string */\n  className?: string;\n  /** A boolean value stating if the array is disabled */\n  disabled?: boolean;\n  /** An object containing the id for this object & ids for its properties */\n  idSchema: IdSchema<T>;\n  /** An array of objects representing the items in the array */\n  items: ArrayFieldTemplateItemType<T, S, F>[];\n  /** A function that adds a new item to the array */\n  onAddClick: (event?: any) => void;\n  /** A boolean value stating if the array is read-only */\n  readonly?: boolean;\n  /** A boolean value stating if the array is required */\n  required?: boolean;\n  /** A boolean value stating if the field is hiding its errors */\n  hideError?: boolean;\n  /** The schema object for this array */\n  schema: S;\n  /** The uiSchema object for this array field */\n  uiSchema?: UiSchema<T, S, F>;\n  /** A string value containing the title for the array */\n  title: string;\n  /** The `formContext` object that was passed to Form */\n  formContext?: F;\n  /** The formData for this array */\n  formData?: T;\n  /** An array of strings listing all generated error messages from encountered errors for this widget */\n  rawErrors?: string[];\n  /** The `registry` object */\n  registry: Registry<T, S, F>;\n};\n\n/** The properties of each element in the ObjectFieldTemplateProps.properties array */\nexport type ObjectFieldTemplatePropertyType = {\n  /** The html for the property's content */\n  content: ReactElement;\n  /** A string representing the property name */\n  name: string;\n  /** A boolean value stating if the object property is disabled */\n  disabled: boolean;\n  /** A boolean value stating if the property is read-only */\n  readonly: boolean;\n  /** A boolean value stating if the property should be hidden */\n  hidden: boolean;\n};\n\n/** The properties that are passed to an ObjectFieldTemplate implementation */\nexport type ObjectFieldTemplateProps<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n> = {\n  /** A string value containing the title for the object */\n  title: string;\n  /** A string value containing the description for the object */\n  description?: string;\n  /** A boolean value stating if the object is disabled */\n  disabled?: boolean;\n  /** An array of objects representing the properties in the object */\n  properties: ObjectFieldTemplatePropertyType[];\n  /** Returns a function that adds a new property to the object (to be used with additionalProperties) */\n  onAddClick: (schema: S) => () => void;\n  /** A boolean value stating if the object is read-only */\n  readonly?: boolean;\n  /** A boolean value stating if the object is required */\n  required?: boolean;\n  /** A boolean value stating if the field is hiding its errors */\n  hideError?: boolean;\n  /** The schema object for this object */\n  schema: S;\n  /** The uiSchema object for this object field */\n  uiSchema?: UiSchema<T, S, F>;\n  /** An object containing the id for this object & ids for its properties */\n  idSchema: IdSchema<T>;\n  /** The optional validation errors in the form of an `ErrorSchema` */\n  errorSchema?: ErrorSchema<T>;\n  /** The form data for the object */\n  formData?: T;\n  /** The `formContext` object that was passed to Form */\n  formContext?: F;\n  /** The `registry` object */\n  registry: Registry<T, S, F>;\n};\n\n/** The properties that are passed to a WrapIfAdditionalTemplate implementation */\nexport type WrapIfAdditionalTemplateProps<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n> = {\n  /** The field or widget component instance for this field row */\n  children: ReactNode;\n} & Pick<\n  FieldTemplateProps<T, S, F>,\n  | 'id'\n  | 'classNames'\n  | 'style'\n  | 'label'\n  | 'required'\n  | 'readonly'\n  | 'disabled'\n  | 'schema'\n  | 'uiSchema'\n  | 'onKeyChange'\n  | 'onDropPropertyClick'\n  | 'registry'\n>;\n\n/** The properties that are passed to a Widget implementation */\nexport interface WidgetProps<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>\n  extends GenericObjectType,\n    Pick<HTMLAttributes<HTMLElement>, Exclude<keyof HTMLAttributes<HTMLElement>, 'onBlur' | 'onFocus'>> {\n  /** The generated id for this widget, used to provide unique `name`s and `id`s for the HTML field elements rendered by\n   * widgets\n   */\n  id: string;\n  /** The unique name of the field, usually derived from the name of the property in the JSONSchema; Provided in support\n   * of custom widgets.\n   */\n  name: string;\n  /** The JSONSchema subschema object for this widget */\n  schema: S;\n  /** The uiSchema for this widget */\n  uiSchema?: UiSchema<T, S, F>;\n  /** The current value for this widget */\n  value: any;\n  /** The required status of this widget */\n  required?: boolean;\n  /** A boolean value stating if the widget is disabled */\n  disabled?: boolean;\n  /** A boolean value stating if the widget is read-only */\n  readonly?: boolean;\n  /** A boolean value stating if the widget is hiding its errors */\n  hideError?: boolean;\n  /** A boolean value stating if the widget should autofocus */\n  autofocus?: boolean;\n  /** The placeholder for the widget, if any */\n  placeholder?: string;\n  /** A map of UI Options passed as a prop to the component, including the optional `enumOptions`\n   * which is a special case on top of `UIOptionsType` needed only by widgets\n   */\n  options: NonNullable<UIOptionsType<T, S, F>> & {\n    /** The enum options list for a type that supports them */\n    enumOptions?: EnumOptionsType<S>[];\n  };\n  /** The `formContext` object that you passed to `Form` */\n  formContext?: F;\n  /** The input blur event handler; call it with the widget id and value */\n  onBlur: (id: string, value: any) => void;\n  /** The value change event handler; call it with the new value every time it changes */\n  onChange: (value: any) => void;\n  /** The input focus event handler; call it with the widget id and value */\n  onFocus: (id: string, value: any) => void;\n  /** The computed label for this widget, as a string */\n  label: string;\n  /** A boolean value, if true, will cause the label to be hidden. This is useful for nested fields where you don't want\n   * to clutter the UI. Customized via `label` in the `UiSchema`\n   */\n  hideLabel?: boolean;\n  /** A boolean value stating if the widget can accept multiple values */\n  multiple?: boolean;\n  /** An array of strings listing all generated error messages from encountered errors for this widget */\n  rawErrors?: string[];\n  /** The `registry` object */\n  registry: Registry<T, S, F>;\n}\n\n/** The definition of a React-based Widget component */\nexport type Widget<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any> = ComponentType<\n  WidgetProps<T, S, F>\n>;\n\n/** The properties that are passed to the BaseInputTemplate */\nexport interface BaseInputTemplateProps<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n> extends WidgetProps<T, S, F> {\n  /** A `BaseInputTemplate` implements a default `onChange` handler that it passes to the HTML input component to handle\n   * the `ChangeEvent`. Sometimes a widget may need to handle the `ChangeEvent` using custom logic. If that is the case,\n   * that widget should provide its own handler via this prop.\n   */\n  onChangeOverride?: (event: ChangeEvent<HTMLInputElement>) => void;\n}\n\n/** The type that defines the props used by the Submit button */\nexport type SubmitButtonProps<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any> = {\n  /** The uiSchema for this widget */\n  uiSchema?: UiSchema<T, S, F>;\n  /** The `registry` object */\n  registry: Registry<T, S, F>;\n};\n\n/** The type that defines the props for an Icon button, extending from a basic HTML button attributes */\nexport type IconButtonProps<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n> = ButtonHTMLAttributes<HTMLButtonElement> & {\n  /** An alternative specification for the type of the icon button */\n  iconType?: string;\n  /** The name representation or actual react element implementation for the icon */\n  icon?: string | ReactElement;\n  /** The uiSchema for this widget */\n  uiSchema?: UiSchema<T, S, F>;\n  /** The `registry` object */\n  registry: Registry<T, S, F>;\n};\n\n/** The type that defines how to change the behavior of the submit button for the form */\nexport type UISchemaSubmitButtonOptions = {\n  /** The text of the submit button. Set to \"Submit\" by default */\n  submitText?: string;\n  /** Flag, if `true`, removes the submit button completely from the form */\n  norender?: boolean;\n  /** Any other props to be passed to the submit button itself */\n  props?: GenericObjectType & {\n    /** A boolean value stating if the submit button is disabled */\n    disabled?: boolean;\n    /** The class name for the submit button */\n    className?: string;\n  };\n};\n\n/** This type represents an element used to render an enum option */\nexport type EnumOptionsType<S extends StrictRJSFSchema = RJSFSchema> = {\n  /** The value for the enum option */\n  value: any;\n  /** The label for the enum options */\n  label: string;\n  /** The schema associated with the enum option when the option represents a `oneOf` or `anyOf` choice */\n  schema?: S;\n};\n\n/** This type remaps the keys of `Type` to prepend `ui:` onto them. As a result it does not need to be exported */\ntype MakeUIType<Type> = {\n  [Property in keyof Type as `ui:${string & Property}`]: Type[Property];\n};\n\n/** This type represents all the known supported options in the `ui:options` property, kept separate in order to\n * remap the keys. It also contains all the properties, optionally, of `TemplatesType` except \"ButtonTemplates\"\n */\ntype UIOptionsBaseType<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any> = Partial<\n  Omit<TemplatesType<T, S, F>, 'ButtonTemplates'>\n> &\n  GlobalUISchemaOptions & {\n    /** Any classnames that the user wants to be applied to a field in the ui */\n    classNames?: string;\n    /** Any custom style that the user wants to apply to a field in the ui, applied on the same element as classNames */\n    style?: StyleHTMLAttributes<any>;\n    /** We know that for title, it will be a string, if it is provided */\n    title?: string;\n    /** We know that for description, it will be a string, if it is provided */\n    description?: string;\n    /** We know that for placeholder, it will be a string, if it is provided */\n    placeholder?: string;\n    /** Used to add text next to a field to guide the end user in filling it in */\n    help?: string;\n    /** Flag, if set to `true`, will mark the field as automatically focused on a text input or textarea input */\n    autofocus?: boolean;\n    /** Use to mark the field as supporting auto complete on a text input or textarea input */\n    autocomplete?: HTMLInputElement['autocomplete'];\n    /** Flag, if set to `true`, will mark all child widgets from a given field as disabled */\n    disabled?: boolean;\n    /** The default value to use when an input for a field is empty */\n    emptyValue?: any;\n    /** Will disable any of the enum options specified in the array (by value) */\n    enumDisabled?: Array<string | number | boolean>;\n    /** Flag, if set to `true`, will hide the default error display for the given field AND all of its child fields in the\n     * hierarchy\n     */\n    hideError?: boolean;\n    /** Flag, if set to `true`, will mark all child widgets from a given field as read-only */\n    readonly?: boolean;\n    /** This property allows you to reorder the properties that are shown for a particular object */\n    order?: string[];\n    /** Flag, if set to `true`, will cause the `FileWidget` to show a preview (with download for non-image files) */\n    filePreview?: boolean;\n    /** Flag, if set to `true`, will mark a list of checkboxes as displayed all on one line instead of one per row */\n    inline?: boolean;\n    /** Used to change the input type (for example, `tel` or `email`) for an <input> */\n    inputType?: string;\n    /** Provides a means to set the initial height of a textarea widget */\n    rows?: number;\n    /** If submitButtonOptions is provided it should match the `UISchemaSubmitButtonOptions` type */\n    submitButtonOptions?: UISchemaSubmitButtonOptions;\n    /** Allows RJSF to override the default widget implementation by specifying either the name of a widget that is used\n     * to look up an implementation from the `widgets` list or an actual one-off widget implementation itself\n     */\n    widget?: Widget<T, S, F> | string;\n  };\n\n/** The type that represents the Options potentially provided by `ui:options` */\nexport type UIOptionsType<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n> = UIOptionsBaseType<T, S, F> & {\n  /** Anything else will be one of these types */\n  [key: string]: boolean | number | string | object | any[] | null | undefined;\n};\n\n/** Type describing the well-known properties of the `UiSchema` while also supporting all user defined properties,\n * starting with `ui:`.\n */\nexport type UiSchema<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n> = GenericObjectType &\n  MakeUIType<UIOptionsBaseType<T, S, F>> & {\n    /** The set of Globally relevant UI Schema options that are read from the root-level UiSchema and stored in the\n     * Registry for use everywhere.\n     */\n    'ui:globalOptions'?: GlobalUISchemaOptions;\n    /** Allows the form to generate a unique prefix for the `Form`'s root prefix  */\n    'ui:rootFieldId'?: string;\n    /** Allows RJSF to override the default field implementation by specifying either the name of a field that is used\n     * to look up an implementation from the `fields` list or an actual one-off `Field` component implementation itself\n     */\n    'ui:field'?: Field<T, S, F> | string;\n    /** By default, any field that is rendered for an `anyOf`/`oneOf` schema will be wrapped inside the `AnyOfField` or\n     * `OneOfField` component. This default behavior may be undesirable if your custom field already handles behavior\n     * related to choosing one or more subschemas contained in the `anyOf`/`oneOf` schema.\n     * By providing a `true` value for this flag in association with a custom `ui:field`, the wrapped components will be\n     * omitted, so just one instance of the custom field will be rendered. If the flag is omitted or set to `false`,\n     * your custom field will be wrapped by `AnyOfField`/`OneOfField`.\n     */\n    'ui:fieldReplacesAnyOrOneOf'?: boolean;\n    /** An object that contains all the potential UI options in a single object */\n    'ui:options'?: UIOptionsType<T, S, F>;\n  };\n\n/** A `CustomValidator` function takes in a `formData`, `errors` and `uiSchema` objects and returns the given `errors`\n * object back, while potentially adding additional messages to the `errors`\n */\nexport type CustomValidator<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any> = (\n  formData: T | undefined,\n  errors: FormValidation<T>,\n  uiSchema?: UiSchema<T, S, F>\n) => FormValidation<T>;\n\n/** An `ErrorTransformer` function will take in a list of `errors` & a `uiSchema` and potentially return a\n * transformation of those errors in what ever way it deems necessary\n */\nexport type ErrorTransformer<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any> = (\n  errors: RJSFValidationError[],\n  uiSchema?: UiSchema<T, S, F>\n) => RJSFValidationError[];\n\n/** The type that describes the data that is returned from the `ValidatorType.validateFormData()` function */\nexport type ValidationData<T> = {\n  /** The validation errors as a list of `RJSFValidationError` objects */\n  errors: RJSFValidationError[];\n  /** The validation errors in the form of an `ErrorSchema` */\n  errorSchema: ErrorSchema<T>;\n};\n\n/** The interface that describes the validation functions that are provided by a Validator implementation used by the\n * schema utilities.\n */\nexport interface ValidatorType<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any> {\n  /** This function processes the `formData` with an optional user contributed `customValidate` function, which receives\n   * the form data and a `errorHandler` function that will be used to add custom validation errors for each field. Also\n   * supports a `transformErrors` function that will take the raw AJV validation errors, prior to custom validation and\n   * transform them in what ever way it chooses.\n   *\n   * @param formData - The form data to validate\n   * @param schema - The schema against which to validate the form data\n   * @param [customValidate] - An optional function that is used to perform custom validation\n   * @param [transformErrors] - An optional function that is used to transform errors after AJV validation\n   * @param [uiSchema] - An optional uiSchema that is passed to `transformErrors` and `customValidate`\n   */\n  validateFormData(\n    formData: T | undefined,\n    schema: S,\n    customValidate?: CustomValidator<T, S, F>,\n    transformErrors?: ErrorTransformer<T, S, F>,\n    uiSchema?: UiSchema<T, S, F>\n  ): ValidationData<T>;\n  /** Converts an `errorSchema` into a list of `RJSFValidationErrors`\n   *\n   * @param errorSchema - The `ErrorSchema` instance to convert\n   * @param [fieldPath=[]] - The current field path, defaults to [] if not specified\n   * @deprecated - Use the `toErrorList()` function provided by `@rjsf/utils` instead. This function will be removed in\n   *        the next major release.\n   */\n  toErrorList(errorSchema?: ErrorSchema<T>, fieldPath?: string[]): RJSFValidationError[];\n  /** Validates data against a schema, returning true if the data is valid, or\n   * false otherwise. If the schema is invalid, then this function will return\n   * false.\n   *\n   * @param schema - The schema against which to validate the form data   * @param schema\n   * @param formData - The form data to validate\n   * @param rootSchema - The root schema used to provide $ref resolutions\n   */\n  isValid(schema: S, formData: T | undefined, rootSchema: S): boolean;\n  /** Runs the pure validation of the `schema` and `formData` without any of the RJSF functionality. Provided for use\n   * by the playground. Returns the `errors` from the validation\n   *\n   * @param schema - The schema against which to validate the form data\n   * @param formData - The form data to validate\n   */\n  rawValidation<Result = any>(schema: S, formData?: T): { errors?: Result[]; validationError?: Error };\n}\n\n/** The `SchemaUtilsType` interface provides a wrapper around the publicly exported APIs in the `@rjsf/utils/schema`\n * directory such that one does not have to explicitly pass the `validator` or `rootSchema` to each method. Since both\n * the `validator` and `rootSchema` generally does not change across a `Form`, this allows for providing a simplified\n * set of APIs to the `@rjsf/core` components and the various themes as well.\n */\nexport interface SchemaUtilsType<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any> {\n  /** Returns the `ValidatorType` in the `SchemaUtilsType`\n   *\n   * @returns - The `ValidatorType`\n   */\n  getValidator(): ValidatorType<T, S, F>;\n  /** Determines whether either the `validator` and `rootSchema` differ from the ones associated with this instance of\n   * the `SchemaUtilsType`. If either `validator` or `rootSchema` are falsy, then return false to prevent the creation\n   * of a new `SchemaUtilsType` with incomplete properties.\n   *\n   * @param validator - An implementation of the `ValidatorType` interface that will be compared against the current one\n   * @param rootSchema - The root schema that will be compared against the current one\n   * @param [experimental_defaultFormStateBehavior] - Optional configuration object, if provided, allows users to override default form state behavior\n   * @returns - True if the `SchemaUtilsType` differs from the given `validator` or `rootSchema`\n   */\n  doesSchemaUtilsDiffer(\n    validator: ValidatorType<T, S, F>,\n    rootSchema: S,\n    experimental_defaultFormStateBehavior?: Experimental_DefaultFormStateBehavior\n  ): boolean;\n  /** Returns the superset of `formData` that includes the given set updated to include any missing fields that have\n   * computed to have defaults provided in the `schema`.\n   *\n   * @param schema - The schema for which the default state is desired\n   * @param [formData] - The current formData, if any, onto which to provide any missing defaults\n   * @param [includeUndefinedValues=false] - Optional flag, if true, cause undefined values to be added as defaults.\n   *          If \"excludeObjectChildren\", cause undefined values for this object and pass `includeUndefinedValues` as\n   *          false when computing defaults for any nested object properties.\n   * @returns - The resulting `formData` with all the defaults provided\n   */\n  getDefaultFormState(\n    schema: S,\n    formData?: T,\n    includeUndefinedValues?: boolean | 'excludeObjectChildren'\n  ): T | T[] | undefined;\n  /** Determines whether the combination of `schema` and `uiSchema` properties indicates that the label for the `schema`\n   * should be displayed in a UI.\n   *\n   * @param schema - The schema for which the display label flag is desired\n   * @param [uiSchema] - The UI schema from which to derive potentially displayable information\n   * @param [globalOptions={}] - The Global UI Schema from which to get any fallback `xxx` options\n   * @returns - True if the label should be displayed or false if it should not\n   */\n  getDisplayLabel(schema: S, uiSchema?: UiSchema<T, S, F>, globalOptions?: GlobalUISchemaOptions): boolean;\n  /** Determines which of the given `options` provided most closely matches the `formData`.\n   * Returns the index of the option that is valid and is the closest match, or 0 if there is no match.\n   *\n   * The closest match is determined using the number of matching properties, and more heavily favors options with\n   * matching readOnly, default, or const values.\n   *\n   * @param formData - The form data associated with the schema\n   * @param options - The list of options that can be selected from\n   * @param [selectedOption] - The index of the currently selected option, defaulted to -1 if not specified\n   * @param [discriminatorField] - The optional name of the field within the options object whose value is used to\n   *          determine which option is selected\n   * @returns - The index of the option that is the closest match to the `formData` or the `selectedOption` if no match\n   */\n  getClosestMatchingOption(\n    formData: T | undefined,\n    options: S[],\n    selectedOption?: number,\n    discriminatorField?: string\n  ): number;\n  /** Given the `formData` and list of `options`, attempts to find the index of the first option that matches the data.\n   * Always returns the first option if there is nothing that matches.\n   *\n   * @param formData - The current formData, if any, used to figure out a match\n   * @param options - The list of options to find a matching options from\n   * @param [discriminatorField] - The optional name of the field within the options object whose value is used to\n   *          determine which option is selected\n   * @returns - The firstindex of the matched option or 0 if none is available\n   */\n  getFirstMatchingOption(formData: T | undefined, options: S[], discriminatorField?: string): number;\n  /** Given the `formData` and list of `options`, attempts to find the index of the option that best matches the data.\n   * Deprecated, use `getFirstMatchingOption()` instead.\n   *\n   * @param formData - The current formData, if any, onto which to provide any missing defaults\n   * @param options - The list of options to find a matching options from\n   * @param [discriminatorField] - The optional name of the field within the options object whose value is used to\n   *          determine which option is selected\n   * @returns - The index of the matched option or 0 if none is available\n   * @deprecated\n   */\n  getMatchingOption(formData: T | undefined, options: S[], discriminatorField?: string): number;\n  /** Checks to see if the `schema` and `uiSchema` combination represents an array of files\n   *\n   * @param schema - The schema for which check for array of files flag is desired\n   * @param [uiSchema] - The UI schema from which to check the widget\n   * @returns - True if schema/uiSchema contains an array of files, otherwise false\n   */\n  isFilesArray(schema: S, uiSchema?: UiSchema<T, S, F>): boolean;\n  /** Checks to see if the `schema` combination represents a multi-select\n   *\n   * @param schema - The schema for which check for a multi-select flag is desired\n   * @returns - True if schema contains a multi-select, otherwise false\n   */\n  isMultiSelect(schema: S): boolean;\n  /** Checks to see if the `schema` combination represents a select\n   *\n   * @param schema - The schema for which check for a select flag is desired\n   * @returns - True if schema contains a select, otherwise false\n   */\n  isSelect(schema: S): boolean;\n  /** Merges the errors in `additionalErrorSchema` into the existing `validationData` by combining the hierarchies in\n   * the two `ErrorSchema`s and then appending the error list from the `additionalErrorSchema` obtained by calling\n   * `validator.toErrorList()` onto the `errors` in the `validationData`. If no `additionalErrorSchema` is passed, then\n   * `validationData` is returned.\n   *\n   * @param validationData - The current `ValidationData` into which to merge the additional errors\n   * @param [additionalErrorSchema] - The additional set of errors\n   * @returns - The `validationData` with the additional errors from `additionalErrorSchema` merged into it, if provided\n   * @deprecated - Use the `validationDataMerge()` function exported from `@rjsf/utils` instead. This function will be\n   *        removed in the next major release.\n   */\n  mergeValidationData(validationData: ValidationData<T>, additionalErrorSchema?: ErrorSchema<T>): ValidationData<T>;\n  /** Retrieves an expanded schema that has had all of its conditions, additional properties, references and\n   * dependencies resolved and merged into the `schema` given a `rawFormData` that is used to do the potentially\n   * recursive resolution.\n   *\n   * @param schema - The schema for which retrieving a schema is desired\n   * @param [formData] - The current formData, if any, to assist retrieving a schema\n   * @returns - The schema having its conditions, additional properties, references and dependencies resolved\n   */\n  retrieveSchema(schema: S, formData?: T): S;\n  /** Sanitize the `data` associated with the `oldSchema` so it is considered appropriate for the `newSchema`. If the\n   * new schema does not contain any properties, then `undefined` is returned to clear all the form data. Due to the\n   * nature of schemas, this sanitization happens recursively for nested objects of data. Also, any properties in the\n   * old schema that are non-existent in the new schema are set to `undefined`.\n   *\n   * @param [newSchema] - The new schema for which the data is being sanitized\n   * @param [oldSchema] - The old schema from which the data originated\n   * @param [data={}] - The form data associated with the schema, defaulting to an empty object when undefined\n   * @returns - The new form data, with all of the fields uniquely associated with the old schema set\n   *      to `undefined`. Will return `undefined` if the new schema is not an object containing properties.\n   */\n  sanitizeDataForNewSchema(newSchema?: S, oldSchema?: S, data?: any): T;\n  /** Generates an `IdSchema` object for the `schema`, recursively\n   *\n   * @param schema - The schema for which the display label flag is desired\n   * @param [id] - The base id for the schema\n   * @param [formData] - The current formData, if any, onto which to provide any missing defaults\n   * @param [idPrefix='root'] - The prefix to use for the id\n   * @param [idSeparator='_'] - The separator to use for the path segments in the id\n   * @returns - The `IdSchema` object for the `schema`\n   */\n  toIdSchema(schema: S, id?: string, formData?: T, idPrefix?: string, idSeparator?: string): IdSchema<T>;\n  /** Generates an `PathSchema` object for the `schema`, recursively\n   *\n   * @param schema - The schema for which the display label flag is desired\n   * @param [name] - The base name for the schema\n   * @param [formData] - The current formData, if any, onto which to provide any missing defaults\n   * @returns - The `PathSchema` object for the `schema`\n   */\n  toPathSchema(schema: S, name?: string, formData?: T): PathSchema<T>;\n}\n"],"mappings":""},"metadata":{},"sourceType":"module","externalDependencies":[]}