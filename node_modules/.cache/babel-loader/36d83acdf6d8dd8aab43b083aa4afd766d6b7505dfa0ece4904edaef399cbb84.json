{"ast":null,"code":"import { jsx as _jsx } from \"react/jsx-runtime\";\nimport { createElement } from 'react';\nimport ReactIs from 'react-is';\nimport get from 'lodash/get';\nimport set from 'lodash/set';\nimport getSchemaType from './getSchemaType';\n/** The map of schema types to widget type to widget name\n */\nconst widgetMap = {\n  boolean: {\n    checkbox: 'CheckboxWidget',\n    radio: 'RadioWidget',\n    select: 'SelectWidget',\n    hidden: 'HiddenWidget'\n  },\n  string: {\n    text: 'TextWidget',\n    password: 'PasswordWidget',\n    email: 'EmailWidget',\n    hostname: 'TextWidget',\n    ipv4: 'TextWidget',\n    ipv6: 'TextWidget',\n    uri: 'URLWidget',\n    'data-url': 'FileWidget',\n    radio: 'RadioWidget',\n    select: 'SelectWidget',\n    textarea: 'TextareaWidget',\n    hidden: 'HiddenWidget',\n    date: 'DateWidget',\n    datetime: 'DateTimeWidget',\n    'date-time': 'DateTimeWidget',\n    'alt-date': 'AltDateWidget',\n    'alt-datetime': 'AltDateTimeWidget',\n    time: 'TimeWidget',\n    color: 'ColorWidget',\n    file: 'FileWidget'\n  },\n  number: {\n    text: 'TextWidget',\n    select: 'SelectWidget',\n    updown: 'UpDownWidget',\n    range: 'RangeWidget',\n    radio: 'RadioWidget',\n    hidden: 'HiddenWidget'\n  },\n  integer: {\n    text: 'TextWidget',\n    select: 'SelectWidget',\n    updown: 'UpDownWidget',\n    range: 'RangeWidget',\n    radio: 'RadioWidget',\n    hidden: 'HiddenWidget'\n  },\n  array: {\n    select: 'SelectWidget',\n    checkboxes: 'CheckboxesWidget',\n    files: 'FileWidget',\n    hidden: 'HiddenWidget'\n  }\n};\n/** Wraps the given widget with stateless functional component that will merge any `defaultProps.options` with the\n * `options` that are provided in the props. It will add the wrapper component as a `MergedWidget` property onto the\n * `Widget` so that future attempts to wrap `AWidget` will return the already existing wrapper.\n *\n * @param AWidget - A widget that will be wrapped or one that is already wrapped\n * @returns - The wrapper widget\n */\nfunction mergeWidgetOptions(AWidget) {\n  let MergedWidget = get(AWidget, 'MergedWidget');\n  // cache return value as property of widget for proper react reconciliation\n  if (!MergedWidget) {\n    const defaultOptions = AWidget.defaultProps && AWidget.defaultProps.options || {};\n    MergedWidget = _ref => {\n      let {\n        options,\n        ...props\n      } = _ref;\n      return _jsx(AWidget, {\n        options: {\n          ...defaultOptions,\n          ...options\n        },\n        ...props\n      });\n    };\n    set(AWidget, 'MergedWidget', MergedWidget);\n  }\n  return MergedWidget;\n}\n/** Given a schema representing a field to render and either the name or actual `Widget` implementation, returns the\n * React component that is used to render the widget. If the `widget` is already a React component, then it is wrapped\n * with a `MergedWidget`. Otherwise an attempt is made to look up the widget inside of the `registeredWidgets` map based\n * on the schema type and `widget` name. If no widget component can be found an `Error` is thrown.\n *\n * @param schema - The schema for the field\n * @param [widget] - Either the name of the widget OR a `Widget` implementation to use\n * @param [registeredWidgets={}] - A registry of widget name to `Widget` implementation\n * @returns - The `Widget` component to use\n * @throws - An error if there is no `Widget` component that can be returned\n */\nexport default function getWidget(schema, widget) {\n  let registeredWidgets = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const type = getSchemaType(schema);\n  if (typeof widget === 'function' || widget && ReactIs.isForwardRef(createElement(widget)) || ReactIs.isMemo(widget)) {\n    return mergeWidgetOptions(widget);\n  }\n  if (typeof widget !== 'string') {\n    throw new Error(\"Unsupported widget definition: \".concat(typeof widget));\n  }\n  if (widget in registeredWidgets) {\n    const registeredWidget = registeredWidgets[widget];\n    return getWidget(schema, registeredWidget, registeredWidgets);\n  }\n  if (typeof type === 'string') {\n    if (!(type in widgetMap)) {\n      throw new Error(\"No widget for type '\".concat(type, \"'\"));\n    }\n    if (widget in widgetMap[type]) {\n      const registeredWidget = registeredWidgets[widgetMap[type][widget]];\n      return getWidget(schema, registeredWidget, registeredWidgets);\n    }\n  }\n  throw new Error(\"No widget '\".concat(widget, \"' for type '\").concat(type, \"'\"));\n}","map":{"version":3,"names":["createElement","ReactIs","get","set","getSchemaType","widgetMap","boolean","checkbox","radio","select","hidden","string","text","password","email","hostname","ipv4","ipv6","uri","textarea","date","datetime","time","color","file","number","updown","range","integer","array","checkboxes","files","mergeWidgetOptions","AWidget","MergedWidget","defaultOptions","defaultProps","options","_ref","props","_jsx","getWidget","schema","widget","registeredWidgets","arguments","length","undefined","type","isForwardRef","isMemo","Error","concat","registeredWidget"],"sources":["D:\\Reactjs\\my-app\\node_modules\\@rjsf\\utils\\src\\getWidget.tsx"],"sourcesContent":["import { createElement } from 'react';\nimport ReactIs from 'react-is';\nimport get from 'lodash/get';\nimport set from 'lodash/set';\n\nimport { FormContextType, RJSFSchema, Widget, RegistryWidgetsType, StrictRJSFSchema } from './types';\nimport getSchemaType from './getSchemaType';\n\n/** The map of schema types to widget type to widget name\n */\nconst widgetMap: { [k: string]: { [j: string]: string } } = {\n  boolean: {\n    checkbox: 'CheckboxWidget',\n    radio: 'RadioWidget',\n    select: 'SelectWidget',\n    hidden: 'HiddenWidget',\n  },\n  string: {\n    text: 'TextWidget',\n    password: 'PasswordWidget',\n    email: 'EmailWidget',\n    hostname: 'TextWidget',\n    ipv4: 'TextWidget',\n    ipv6: 'TextWidget',\n    uri: 'URLWidget',\n    'data-url': 'FileWidget',\n    radio: 'RadioWidget',\n    select: 'SelectWidget',\n    textarea: 'TextareaWidget',\n    hidden: 'HiddenWidget',\n    date: 'DateWidget',\n    datetime: 'DateTimeWidget',\n    'date-time': 'DateTimeWidget',\n    'alt-date': 'AltDateWidget',\n    'alt-datetime': 'AltDateTimeWidget',\n    time: 'TimeWidget',\n    color: 'ColorWidget',\n    file: 'FileWidget',\n  },\n  number: {\n    text: 'TextWidget',\n    select: 'SelectWidget',\n    updown: 'UpDownWidget',\n    range: 'RangeWidget',\n    radio: 'RadioWidget',\n    hidden: 'HiddenWidget',\n  },\n  integer: {\n    text: 'TextWidget',\n    select: 'SelectWidget',\n    updown: 'UpDownWidget',\n    range: 'RangeWidget',\n    radio: 'RadioWidget',\n    hidden: 'HiddenWidget',\n  },\n  array: {\n    select: 'SelectWidget',\n    checkboxes: 'CheckboxesWidget',\n    files: 'FileWidget',\n    hidden: 'HiddenWidget',\n  },\n};\n\n/** Wraps the given widget with stateless functional component that will merge any `defaultProps.options` with the\n * `options` that are provided in the props. It will add the wrapper component as a `MergedWidget` property onto the\n * `Widget` so that future attempts to wrap `AWidget` will return the already existing wrapper.\n *\n * @param AWidget - A widget that will be wrapped or one that is already wrapped\n * @returns - The wrapper widget\n */\nfunction mergeWidgetOptions<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  AWidget: Widget<T, S, F>\n) {\n  let MergedWidget: Widget<T, S, F> | undefined = get(AWidget, 'MergedWidget');\n  // cache return value as property of widget for proper react reconciliation\n  if (!MergedWidget) {\n    const defaultOptions = (AWidget.defaultProps && AWidget.defaultProps.options) || {};\n    MergedWidget = ({ options, ...props }) => {\n      return <AWidget options={{ ...defaultOptions, ...options }} {...props} />;\n    };\n    set(AWidget, 'MergedWidget', MergedWidget);\n  }\n  return MergedWidget;\n}\n\n/** Given a schema representing a field to render and either the name or actual `Widget` implementation, returns the\n * React component that is used to render the widget. If the `widget` is already a React component, then it is wrapped\n * with a `MergedWidget`. Otherwise an attempt is made to look up the widget inside of the `registeredWidgets` map based\n * on the schema type and `widget` name. If no widget component can be found an `Error` is thrown.\n *\n * @param schema - The schema for the field\n * @param [widget] - Either the name of the widget OR a `Widget` implementation to use\n * @param [registeredWidgets={}] - A registry of widget name to `Widget` implementation\n * @returns - The `Widget` component to use\n * @throws - An error if there is no `Widget` component that can be returned\n */\nexport default function getWidget<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  schema: RJSFSchema,\n  widget?: Widget<T, S, F> | string,\n  registeredWidgets: RegistryWidgetsType<T, S, F> = {}\n): Widget<T, S, F> {\n  const type = getSchemaType(schema);\n\n  if (\n    typeof widget === 'function' ||\n    (widget && ReactIs.isForwardRef(createElement(widget))) ||\n    ReactIs.isMemo(widget)\n  ) {\n    return mergeWidgetOptions<T, S, F>(widget as Widget<T, S, F>);\n  }\n\n  if (typeof widget !== 'string') {\n    throw new Error(`Unsupported widget definition: ${typeof widget}`);\n  }\n\n  if (widget in registeredWidgets) {\n    const registeredWidget = registeredWidgets[widget];\n    return getWidget<T, S, F>(schema, registeredWidget, registeredWidgets);\n  }\n\n  if (typeof type === 'string') {\n    if (!(type in widgetMap)) {\n      throw new Error(`No widget for type '${type}'`);\n    }\n\n    if (widget in widgetMap[type]) {\n      const registeredWidget = registeredWidgets[widgetMap[type][widget]];\n      return getWidget<T, S, F>(schema, registeredWidget, registeredWidgets);\n    }\n  }\n\n  throw new Error(`No widget '${widget}' for type '${type}'`);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}