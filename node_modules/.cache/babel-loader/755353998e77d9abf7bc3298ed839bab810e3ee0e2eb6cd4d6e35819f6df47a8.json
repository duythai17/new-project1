{"ast":null,"code":"import jsonpointer from 'jsonpointer';\nimport omit from 'lodash/omit';\nimport { REF_KEY } from './constants';\n/** Splits out the value at the `key` in `object` from the `object`, returning an array that contains in the first\n * location, the `object` minus the `key: value` and in the second location the `value`.\n *\n * @param key - The key from the object to extract\n * @param object - The object from which to extract the element\n * @returns - An array with the first value being the object minus the `key` element and the second element being the\n *      value from `object[key]`\n */\nexport function splitKeyElementFromObject(key, object) {\n  const value = object[key];\n  const remaining = omit(object, [key]);\n  return [remaining, value];\n}\n/** Given the name of a `$ref` from within a schema, using the `rootSchema`, look up and return the sub-schema using the\n * path provided by that reference. If `#` is not the first character of the reference, or the path does not exist in\n * the schema, then throw an Error. Otherwise return the sub-schema. Also deals with nested `$ref`s in the sub-schema.\n *\n * @param $ref - The ref string for which the schema definition is desired\n * @param [rootSchema={}] - The root schema in which to search for the definition\n * @returns - The sub-schema within the `rootSchema` which matches the `$ref` if it exists\n * @throws - Error indicating that no schema for that reference exists\n */\nexport default function findSchemaDefinition($ref, rootSchema = {}) {\n  let ref = $ref || '';\n  if (ref.startsWith('#')) {\n    // Decode URI fragment representation.\n    ref = decodeURIComponent(ref.substring(1));\n  } else {\n    throw new Error(`Could not find a definition for ${$ref}.`);\n  }\n  const current = jsonpointer.get(rootSchema, ref);\n  if (current === undefined) {\n    throw new Error(`Could not find a definition for ${$ref}.`);\n  }\n  if (current[REF_KEY]) {\n    const [remaining, theRef] = splitKeyElementFromObject(REF_KEY, current);\n    const subSchema = findSchemaDefinition(theRef, rootSchema);\n    if (Object.keys(remaining).length > 0) {\n      return {\n        ...remaining,\n        ...subSchema\n      };\n    }\n    return subSchema;\n  }\n  return current;\n}","map":{"version":3,"names":["jsonpointer","omit","REF_KEY","splitKeyElementFromObject","key","object","value","remaining","findSchemaDefinition","$ref","rootSchema","ref","startsWith","decodeURIComponent","substring","Error","current","get","undefined","theRef","subSchema","Object","keys","length"],"sources":["D:\\Reactjs\\my-app\\node_modules\\@rjsf\\utils\\src\\findSchemaDefinition.ts"],"sourcesContent":["import jsonpointer from 'jsonpointer';\nimport omit from 'lodash/omit';\n\nimport { REF_KEY } from './constants';\nimport { GenericObjectType, RJSFSchema, StrictRJSFSchema } from './types';\n\n/** Splits out the value at the `key` in `object` from the `object`, returning an array that contains in the first\n * location, the `object` minus the `key: value` and in the second location the `value`.\n *\n * @param key - The key from the object to extract\n * @param object - The object from which to extract the element\n * @returns - An array with the first value being the object minus the `key` element and the second element being the\n *      value from `object[key]`\n */\nexport function splitKeyElementFromObject(key: string, object: GenericObjectType) {\n  const value = object[key];\n  const remaining = omit(object, [key]);\n  return [remaining, value];\n}\n\n/** Given the name of a `$ref` from within a schema, using the `rootSchema`, look up and return the sub-schema using the\n * path provided by that reference. If `#` is not the first character of the reference, or the path does not exist in\n * the schema, then throw an Error. Otherwise return the sub-schema. Also deals with nested `$ref`s in the sub-schema.\n *\n * @param $ref - The ref string for which the schema definition is desired\n * @param [rootSchema={}] - The root schema in which to search for the definition\n * @returns - The sub-schema within the `rootSchema` which matches the `$ref` if it exists\n * @throws - Error indicating that no schema for that reference exists\n */\nexport default function findSchemaDefinition<S extends StrictRJSFSchema = RJSFSchema>(\n  $ref?: string,\n  rootSchema: S = {} as S\n): S {\n  let ref = $ref || '';\n  if (ref.startsWith('#')) {\n    // Decode URI fragment representation.\n    ref = decodeURIComponent(ref.substring(1));\n  } else {\n    throw new Error(`Could not find a definition for ${$ref}.`);\n  }\n  const current: S = jsonpointer.get(rootSchema, ref);\n  if (current === undefined) {\n    throw new Error(`Could not find a definition for ${$ref}.`);\n  }\n  if (current[REF_KEY]) {\n    const [remaining, theRef] = splitKeyElementFromObject(REF_KEY, current);\n    const subSchema = findSchemaDefinition<S>(theRef, rootSchema);\n    if (Object.keys(remaining).length > 0) {\n      return { ...remaining, ...subSchema };\n    }\n    return subSchema;\n  }\n  return current;\n}\n"],"mappings":"AAAA,OAAOA,WAAW,MAAM,aAAa;AACrC,OAAOC,IAAI,MAAM,aAAa;AAE9B,SAASC,OAAO,QAAQ,aAAa;AAGrC;;;;;;;;AAQA,OAAM,SAAUC,yBAAyBA,CAACC,GAAW,EAAEC,MAAyB;EAC9E,MAAMC,KAAK,GAAGD,MAAM,CAACD,GAAG,CAAC;EACzB,MAAMG,SAAS,GAAGN,IAAI,CAACI,MAAM,EAAE,CAACD,GAAG,CAAC,CAAC;EACrC,OAAO,CAACG,SAAS,EAAED,KAAK,CAAC;AAC3B;AAEA;;;;;;;;;AASA,eAAc,SAAUE,oBAAoBA,CAC1CC,IAAa,EACbC,UAAA,GAAgB,EAAO;EAEvB,IAAIC,GAAG,GAAGF,IAAI,IAAI,EAAE;EACpB,IAAIE,GAAG,CAACC,UAAU,CAAC,GAAG,CAAC,EAAE;IACvB;IACAD,GAAG,GAAGE,kBAAkB,CAACF,GAAG,CAACG,SAAS,CAAC,CAAC,CAAC,CAAC;GAC3C,MAAM;IACL,MAAM,IAAIC,KAAK,CAAC,mCAAmCN,IAAI,GAAG,CAAC;;EAE7D,MAAMO,OAAO,GAAMhB,WAAW,CAACiB,GAAG,CAACP,UAAU,EAAEC,GAAG,CAAC;EACnD,IAAIK,OAAO,KAAKE,SAAS,EAAE;IACzB,MAAM,IAAIH,KAAK,CAAC,mCAAmCN,IAAI,GAAG,CAAC;;EAE7D,IAAIO,OAAO,CAACd,OAAO,CAAC,EAAE;IACpB,MAAM,CAACK,SAAS,EAAEY,MAAM,CAAC,GAAGhB,yBAAyB,CAACD,OAAO,EAAEc,OAAO,CAAC;IACvE,MAAMI,SAAS,GAAGZ,oBAAoB,CAAIW,MAAM,EAAET,UAAU,CAAC;IAC7D,IAAIW,MAAM,CAACC,IAAI,CAACf,SAAS,CAAC,CAACgB,MAAM,GAAG,CAAC,EAAE;MACrC,OAAO;QAAE,GAAGhB,SAAS;QAAE,GAAGa;MAAS,CAAE;;IAEvC,OAAOA,SAAS;;EAElB,OAAOJ,OAAO;AAChB"},"metadata":{},"sourceType":"module","externalDependencies":[]}