{"ast":null,"code":"import { jsx as _jsx } from \"react/jsx-runtime\";\nimport { getWidget, getUiOptions, optionsList, TranslatableString } from '@rjsf/utils';\nimport isObject from 'lodash/isObject';\n/** The `BooleanField` component is used to render a field in the schema is boolean. It constructs `enumOptions` for the\n * two boolean values based on the various alternatives in the schema.\n *\n * @param props - The `FieldProps` for this template\n */\nfunction BooleanField(props) {\n  var _a, _b;\n  const {\n    schema,\n    name,\n    uiSchema,\n    idSchema,\n    formData,\n    registry,\n    required,\n    disabled,\n    readonly,\n    hideError,\n    autofocus,\n    onChange,\n    onFocus,\n    onBlur,\n    rawErrors\n  } = props;\n  const {\n    title\n  } = schema;\n  const {\n    widgets,\n    formContext,\n    translateString,\n    globalUiOptions\n  } = registry;\n  const {\n    widget = 'checkbox',\n    title: uiTitle,\n    // Unlike the other fields, don't use `getDisplayLabel()` since it always returns false for the boolean type\n    label: displayLabel = true,\n    ...options\n  } = getUiOptions(uiSchema, globalUiOptions);\n  const Widget = getWidget(schema, widget, widgets);\n  const yes = translateString(TranslatableString.YesLabel);\n  const no = translateString(TranslatableString.NoLabel);\n  let enumOptions;\n  const label = (_a = uiTitle !== null && uiTitle !== void 0 ? uiTitle : title) !== null && _a !== void 0 ? _a : name;\n  if (Array.isArray(schema.oneOf)) {\n    enumOptions = optionsList({\n      oneOf: schema.oneOf.map(option => {\n        if (isObject(option)) {\n          return {\n            ...option,\n            title: option.title || (option.const === true ? yes : no)\n          };\n        }\n        return undefined;\n      }).filter(o => o) // cast away the error that typescript can't grok is fixed\n    });\n  } else {\n    // We deprecated enumNames in v5. It's intentionally omitted from RSJFSchema type, so we need to cast here.\n    const schemaWithEnumNames = schema;\n    const enums = (_b = schema.enum) !== null && _b !== void 0 ? _b : [true, false];\n    if (!schemaWithEnumNames.enumNames && enums.length === 2 && enums.every(v => typeof v === 'boolean')) {\n      enumOptions = [{\n        value: enums[0],\n        label: enums[0] ? yes : no\n      }, {\n        value: enums[1],\n        label: enums[1] ? yes : no\n      }];\n    } else {\n      enumOptions = optionsList({\n        enum: enums,\n        // NOTE: enumNames is deprecated, but still supported for now.\n        enumNames: schemaWithEnumNames.enumNames\n      });\n    }\n  }\n  return _jsx(Widget, {\n    options: {\n      ...options,\n      enumOptions\n    },\n    schema: schema,\n    uiSchema: uiSchema,\n    id: idSchema.$id,\n    name: name,\n    onChange: onChange,\n    onFocus: onFocus,\n    onBlur: onBlur,\n    label: label,\n    hideLabel: !displayLabel,\n    value: formData,\n    required: required,\n    disabled: disabled,\n    readonly: readonly,\n    hideError: hideError,\n    registry: registry,\n    formContext: formContext,\n    autofocus: autofocus,\n    rawErrors: rawErrors\n  });\n}\nexport default BooleanField;","map":{"version":3,"names":["getWidget","getUiOptions","optionsList","TranslatableString","isObject","BooleanField","props","schema","name","uiSchema","idSchema","formData","registry","required","disabled","readonly","hideError","autofocus","onChange","onFocus","onBlur","rawErrors","title","widgets","formContext","translateString","globalUiOptions","widget","uiTitle","label","displayLabel","options","Widget","yes","YesLabel","no","NoLabel","enumOptions","_a","Array","isArray","oneOf","map","option","const","undefined","filter","o","schemaWithEnumNames","enums","_b","enum","enumNames","length","every","v","value","_jsx","id","$id","hideLabel"],"sources":["D:\\Reactjs\\my-app\\node_modules\\@rjsf\\core\\src\\components\\fields\\BooleanField.tsx"],"sourcesContent":["import {\n  getWidget,\n  getUiOptions,\n  optionsList,\n  FieldProps,\n  FormContextType,\n  EnumOptionsType,\n  RJSFSchema,\n  StrictRJSFSchema,\n  TranslatableString,\n} from '@rjsf/utils';\nimport isObject from 'lodash/isObject';\n\n/** The `BooleanField` component is used to render a field in the schema is boolean. It constructs `enumOptions` for the\n * two boolean values based on the various alternatives in the schema.\n *\n * @param props - The `FieldProps` for this template\n */\nfunction BooleanField<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  props: FieldProps<T, S, F>\n) {\n  const {\n    schema,\n    name,\n    uiSchema,\n    idSchema,\n    formData,\n    registry,\n    required,\n    disabled,\n    readonly,\n    hideError,\n    autofocus,\n    onChange,\n    onFocus,\n    onBlur,\n    rawErrors,\n  } = props;\n  const { title } = schema;\n  const { widgets, formContext, translateString, globalUiOptions } = registry;\n  const {\n    widget = 'checkbox',\n    title: uiTitle,\n    // Unlike the other fields, don't use `getDisplayLabel()` since it always returns false for the boolean type\n    label: displayLabel = true,\n    ...options\n  } = getUiOptions<T, S, F>(uiSchema, globalUiOptions);\n  const Widget = getWidget(schema, widget, widgets);\n  const yes = translateString(TranslatableString.YesLabel);\n  const no = translateString(TranslatableString.NoLabel);\n  let enumOptions: EnumOptionsType<S>[] | undefined;\n  const label = uiTitle ?? title ?? name;\n  if (Array.isArray(schema.oneOf)) {\n    enumOptions = optionsList<S>({\n      oneOf: schema.oneOf\n        .map((option) => {\n          if (isObject(option)) {\n            return {\n              ...option,\n              title: option.title || (option.const === true ? yes : no),\n            };\n          }\n          return undefined;\n        })\n        .filter((o: any) => o) as S[], // cast away the error that typescript can't grok is fixed\n    } as unknown as S);\n  } else {\n    // We deprecated enumNames in v5. It's intentionally omitted from RSJFSchema type, so we need to cast here.\n    const schemaWithEnumNames = schema as S & { enumNames?: string[] };\n    const enums = schema.enum ?? [true, false];\n    if (!schemaWithEnumNames.enumNames && enums.length === 2 && enums.every((v: any) => typeof v === 'boolean')) {\n      enumOptions = [\n        {\n          value: enums[0],\n          label: enums[0] ? yes : no,\n        },\n        {\n          value: enums[1],\n          label: enums[1] ? yes : no,\n        },\n      ];\n    } else {\n      enumOptions = optionsList<S>({\n        enum: enums,\n        // NOTE: enumNames is deprecated, but still supported for now.\n        enumNames: schemaWithEnumNames.enumNames,\n      } as unknown as S);\n    }\n  }\n\n  return (\n    <Widget\n      options={{ ...options, enumOptions }}\n      schema={schema}\n      uiSchema={uiSchema}\n      id={idSchema.$id}\n      name={name}\n      onChange={onChange}\n      onFocus={onFocus}\n      onBlur={onBlur}\n      label={label}\n      hideLabel={!displayLabel}\n      value={formData}\n      required={required}\n      disabled={disabled}\n      readonly={readonly}\n      hideError={hideError}\n      registry={registry}\n      formContext={formContext}\n      autofocus={autofocus}\n      rawErrors={rawErrors}\n    />\n  );\n}\n\nexport default BooleanField;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}