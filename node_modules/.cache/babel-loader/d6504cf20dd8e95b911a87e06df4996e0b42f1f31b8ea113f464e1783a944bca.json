{"ast":null,"code":"import get from 'lodash/get';\nimport has from 'lodash/has';\nimport { PROPERTIES_KEY, REF_KEY } from '../constants';\nimport retrieveSchema from './retrieveSchema';\nconst NO_VALUE = Symbol('no Value');\n/** Sanitize the `data` associated with the `oldSchema` so it is considered appropriate for the `newSchema`. If the new\n * schema does not contain any properties, then `undefined` is returned to clear all the form data. Due to the nature\n * of schemas, this sanitization happens recursively for nested objects of data. Also, any properties in the old schema\n * that are non-existent in the new schema are set to `undefined`. The data sanitization process has the following flow:\n *\n * - If the new schema is an object that contains a `properties` object then:\n *   - Create a `removeOldSchemaData` object, setting each key in the `oldSchema.properties` having `data` to undefined\n *   - Create an empty `nestedData` object for use in the key filtering below:\n *   - Iterate over each key in the `newSchema.properties` as follows:\n *     - Get the `formValue` of the key from the `data`\n *     - Get the `oldKeySchema` and `newKeyedSchema` for the key, defaulting to `{}` when it doesn't exist\n *     - Retrieve the schema for any refs within each `oldKeySchema` and/or `newKeySchema`\n *     - Get the types of the old and new keyed schemas and if the old doesn't exist or the old & new are the same then:\n *       - If `removeOldSchemaData` has an entry for the key, delete it since the new schema has the same property\n *       - If type of the key in the new schema is `object`:\n *         - Store the value from the recursive `sanitizeDataForNewSchema` call in `nestedData[key]`\n *       - Otherwise, check for default or const values:\n *         - Get the old and new `default` values from the schema and check:\n *           - If the new `default` value does not match the form value:\n *             - If the old `default` value DOES match the form value, then:\n *               - Replace `removeOldSchemaData[key]` with the new `default`\n *               - Otherwise, if the new schema is `readOnly` then replace `removeOldSchemaData[key]` with undefined\n *         - Get the old and new `const` values from the schema and check:\n *           - If the new `const` value does not match the form value:\n *           - If the old `const` value DOES match the form value, then:\n *             - Replace `removeOldSchemaData[key]` with the new `const`\n *             - Otherwise, replace `removeOldSchemaData[key]` with undefined\n *   - Once all keys have been processed, return an object built as follows:\n *     - `{ ...removeOldSchemaData, ...nestedData, ...pick(data, keysToKeep) }`\n * - If the new and old schema types are array and the `data` is an array then:\n *   - If the type of the old and new schema `items` are a non-array objects:\n *     - Retrieve the schema for any refs within each `oldKeySchema.items` and/or `newKeySchema.items`\n *     - If the `type`s of both items are the same (or the old does not have a type):\n *       - If the type is \"object\", then:\n *         - For each element in the `data` recursively sanitize the data, stopping at `maxItems` if specified\n *       - Otherwise, just return the `data` removing any values after `maxItems` if it is set\n *   - If the type of the old and new schema `items` are booleans of the same value, return `data` as is\n * - Otherwise return `undefined`\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param rootSchema - The root JSON schema of the entire form\n * @param [newSchema] - The new schema for which the data is being sanitized\n * @param [oldSchema] - The old schema from which the data originated\n * @param [data={}] - The form data associated with the schema, defaulting to an empty object when undefined\n * @returns - The new form data, with all the fields uniquely associated with the old schema set\n *      to `undefined`. Will return `undefined` if the new schema is not an object containing properties.\n */\nexport default function sanitizeDataForNewSchema(validator, rootSchema, newSchema, oldSchema, data = {}) {\n  // By default, we will clear the form data\n  let newFormData;\n  // If the new schema is of type object and that object contains a list of properties\n  if (has(newSchema, PROPERTIES_KEY)) {\n    // Create an object containing root-level keys in the old schema, setting each key to undefined to remove the data\n    const removeOldSchemaData = {};\n    if (has(oldSchema, PROPERTIES_KEY)) {\n      const properties = get(oldSchema, PROPERTIES_KEY, {});\n      Object.keys(properties).forEach(key => {\n        if (has(data, key)) {\n          removeOldSchemaData[key] = undefined;\n        }\n      });\n    }\n    const keys = Object.keys(get(newSchema, PROPERTIES_KEY, {}));\n    // Create a place to store nested data that will be a side-effect of the filter\n    const nestedData = {};\n    keys.forEach(key => {\n      const formValue = get(data, key);\n      let oldKeyedSchema = get(oldSchema, [PROPERTIES_KEY, key], {});\n      let newKeyedSchema = get(newSchema, [PROPERTIES_KEY, key], {});\n      // Resolve the refs if they exist\n      if (has(oldKeyedSchema, REF_KEY)) {\n        oldKeyedSchema = retrieveSchema(validator, oldKeyedSchema, rootSchema, formValue);\n      }\n      if (has(newKeyedSchema, REF_KEY)) {\n        newKeyedSchema = retrieveSchema(validator, newKeyedSchema, rootSchema, formValue);\n      }\n      // Now get types and see if they are the same\n      const oldSchemaTypeForKey = get(oldKeyedSchema, 'type');\n      const newSchemaTypeForKey = get(newKeyedSchema, 'type');\n      // Check if the old option has the same key with the same type\n      if (!oldSchemaTypeForKey || oldSchemaTypeForKey === newSchemaTypeForKey) {\n        if (has(removeOldSchemaData, key)) {\n          // SIDE-EFFECT: remove the undefined value for a key that has the same type between the old and new schemas\n          delete removeOldSchemaData[key];\n        }\n        // If it is an object, we'll recurse and store the resulting sanitized data for the key\n        if (newSchemaTypeForKey === 'object' || newSchemaTypeForKey === 'array' && Array.isArray(formValue)) {\n          // SIDE-EFFECT: process the new schema type of object recursively to save iterations\n          const itemData = sanitizeDataForNewSchema(validator, rootSchema, newKeyedSchema, oldKeyedSchema, formValue);\n          if (itemData !== undefined || newSchemaTypeForKey === 'array') {\n            // only put undefined values for the array type and not the object type\n            nestedData[key] = itemData;\n          }\n        } else {\n          // Ok, the non-object types match, let's make sure that a default or a const of a different value is replaced\n          // with the new default or const. This allows the case where two schemas differ that only by the default/const\n          // value to be properly selected\n          const newOptionDefault = get(newKeyedSchema, 'default', NO_VALUE);\n          const oldOptionDefault = get(oldKeyedSchema, 'default', NO_VALUE);\n          if (newOptionDefault !== NO_VALUE && newOptionDefault !== formValue) {\n            if (oldOptionDefault === formValue) {\n              // If the old default matches the formValue, we'll update the new value to match the new default\n              removeOldSchemaData[key] = newOptionDefault;\n            } else if (get(newKeyedSchema, 'readOnly') === true) {\n              // If the new schema has the default set to read-only, treat it like a const and remove the value\n              removeOldSchemaData[key] = undefined;\n            }\n          }\n          const newOptionConst = get(newKeyedSchema, 'const', NO_VALUE);\n          const oldOptionConst = get(oldKeyedSchema, 'const', NO_VALUE);\n          if (newOptionConst !== NO_VALUE && newOptionConst !== formValue) {\n            // Since this is a const, if the old value matches, replace the value with the new const otherwise clear it\n            removeOldSchemaData[key] = oldOptionConst === formValue ? newOptionConst : undefined;\n          }\n        }\n      }\n    });\n    newFormData = {\n      ...(typeof data == 'string' || Array.isArray(data) ? undefined : data),\n      ...removeOldSchemaData,\n      ...nestedData\n    };\n    // First apply removing the old schema data, then apply the nested data, then apply the old data keys to keep\n  } else if (get(oldSchema, 'type') === 'array' && get(newSchema, 'type') === 'array' && Array.isArray(data)) {\n    let oldSchemaItems = get(oldSchema, 'items');\n    let newSchemaItems = get(newSchema, 'items');\n    // If any of the array types `items` are arrays (remember arrays are objects) then we'll just drop the data\n    // Eventually, we may want to deal with when either of the `items` are arrays since those tuple validations\n    if (typeof oldSchemaItems === 'object' && typeof newSchemaItems === 'object' && !Array.isArray(oldSchemaItems) && !Array.isArray(newSchemaItems)) {\n      if (has(oldSchemaItems, REF_KEY)) {\n        oldSchemaItems = retrieveSchema(validator, oldSchemaItems, rootSchema, data);\n      }\n      if (has(newSchemaItems, REF_KEY)) {\n        newSchemaItems = retrieveSchema(validator, newSchemaItems, rootSchema, data);\n      }\n      // Now get types and see if they are the same\n      const oldSchemaType = get(oldSchemaItems, 'type');\n      const newSchemaType = get(newSchemaItems, 'type');\n      // Check if the old option has the same key with the same type\n      if (!oldSchemaType || oldSchemaType === newSchemaType) {\n        const maxItems = get(newSchema, 'maxItems', -1);\n        if (newSchemaType === 'object') {\n          newFormData = data.reduce((newValue, aValue) => {\n            const itemValue = sanitizeDataForNewSchema(validator, rootSchema, newSchemaItems, oldSchemaItems, aValue);\n            if (itemValue !== undefined && (maxItems < 0 || newValue.length < maxItems)) {\n              newValue.push(itemValue);\n            }\n            return newValue;\n          }, []);\n        } else {\n          newFormData = maxItems > 0 && data.length > maxItems ? data.slice(0, maxItems) : data;\n        }\n      }\n    } else if (typeof oldSchemaItems === 'boolean' && typeof newSchemaItems === 'boolean' && oldSchemaItems === newSchemaItems) {\n      // If they are both booleans and have the same value just return the data as is otherwise fall-thru to undefined\n      newFormData = data;\n    }\n    // Also probably want to deal with `prefixItems` as tuples with the latest 2020 draft\n  }\n  return newFormData;\n}","map":{"version":3,"names":["get","has","PROPERTIES_KEY","REF_KEY","retrieveSchema","NO_VALUE","Symbol","sanitizeDataForNewSchema","validator","rootSchema","newSchema","oldSchema","data","newFormData","removeOldSchemaData","properties","Object","keys","forEach","key","undefined","nestedData","formValue","oldKeyedSchema","newKeyedSchema","oldSchemaTypeForKey","newSchemaTypeForKey","Array","isArray","itemData","newOptionDefault","oldOptionDefault","newOptionConst","oldOptionConst","oldSchemaItems","newSchemaItems","oldSchemaType","newSchemaType","maxItems","reduce","newValue","aValue","itemValue","length","push","slice"],"sources":["D:\\Reactjs\\my-app\\node_modules\\@rjsf\\utils\\src\\schema\\sanitizeDataForNewSchema.ts"],"sourcesContent":["import get from 'lodash/get';\nimport has from 'lodash/has';\n\nimport { FormContextType, GenericObjectType, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\nimport { PROPERTIES_KEY, REF_KEY } from '../constants';\nimport retrieveSchema from './retrieveSchema';\n\nconst NO_VALUE = Symbol('no Value');\n\n/** Sanitize the `data` associated with the `oldSchema` so it is considered appropriate for the `newSchema`. If the new\n * schema does not contain any properties, then `undefined` is returned to clear all the form data. Due to the nature\n * of schemas, this sanitization happens recursively for nested objects of data. Also, any properties in the old schema\n * that are non-existent in the new schema are set to `undefined`. The data sanitization process has the following flow:\n *\n * - If the new schema is an object that contains a `properties` object then:\n *   - Create a `removeOldSchemaData` object, setting each key in the `oldSchema.properties` having `data` to undefined\n *   - Create an empty `nestedData` object for use in the key filtering below:\n *   - Iterate over each key in the `newSchema.properties` as follows:\n *     - Get the `formValue` of the key from the `data`\n *     - Get the `oldKeySchema` and `newKeyedSchema` for the key, defaulting to `{}` when it doesn't exist\n *     - Retrieve the schema for any refs within each `oldKeySchema` and/or `newKeySchema`\n *     - Get the types of the old and new keyed schemas and if the old doesn't exist or the old & new are the same then:\n *       - If `removeOldSchemaData` has an entry for the key, delete it since the new schema has the same property\n *       - If type of the key in the new schema is `object`:\n *         - Store the value from the recursive `sanitizeDataForNewSchema` call in `nestedData[key]`\n *       - Otherwise, check for default or const values:\n *         - Get the old and new `default` values from the schema and check:\n *           - If the new `default` value does not match the form value:\n *             - If the old `default` value DOES match the form value, then:\n *               - Replace `removeOldSchemaData[key]` with the new `default`\n *               - Otherwise, if the new schema is `readOnly` then replace `removeOldSchemaData[key]` with undefined\n *         - Get the old and new `const` values from the schema and check:\n *           - If the new `const` value does not match the form value:\n *           - If the old `const` value DOES match the form value, then:\n *             - Replace `removeOldSchemaData[key]` with the new `const`\n *             - Otherwise, replace `removeOldSchemaData[key]` with undefined\n *   - Once all keys have been processed, return an object built as follows:\n *     - `{ ...removeOldSchemaData, ...nestedData, ...pick(data, keysToKeep) }`\n * - If the new and old schema types are array and the `data` is an array then:\n *   - If the type of the old and new schema `items` are a non-array objects:\n *     - Retrieve the schema for any refs within each `oldKeySchema.items` and/or `newKeySchema.items`\n *     - If the `type`s of both items are the same (or the old does not have a type):\n *       - If the type is \"object\", then:\n *         - For each element in the `data` recursively sanitize the data, stopping at `maxItems` if specified\n *       - Otherwise, just return the `data` removing any values after `maxItems` if it is set\n *   - If the type of the old and new schema `items` are booleans of the same value, return `data` as is\n * - Otherwise return `undefined`\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param rootSchema - The root JSON schema of the entire form\n * @param [newSchema] - The new schema for which the data is being sanitized\n * @param [oldSchema] - The old schema from which the data originated\n * @param [data={}] - The form data associated with the schema, defaulting to an empty object when undefined\n * @returns - The new form data, with all the fields uniquely associated with the old schema set\n *      to `undefined`. Will return `undefined` if the new schema is not an object containing properties.\n */\nexport default function sanitizeDataForNewSchema<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(validator: ValidatorType<T, S, F>, rootSchema: S, newSchema?: S, oldSchema?: S, data: any = {}): T {\n  // By default, we will clear the form data\n  let newFormData;\n  // If the new schema is of type object and that object contains a list of properties\n  if (has(newSchema, PROPERTIES_KEY)) {\n    // Create an object containing root-level keys in the old schema, setting each key to undefined to remove the data\n    const removeOldSchemaData: GenericObjectType = {};\n    if (has(oldSchema, PROPERTIES_KEY)) {\n      const properties = get(oldSchema, PROPERTIES_KEY, {});\n      Object.keys(properties).forEach((key) => {\n        if (has(data, key)) {\n          removeOldSchemaData[key] = undefined;\n        }\n      });\n    }\n    const keys: string[] = Object.keys(get(newSchema, PROPERTIES_KEY, {}));\n    // Create a place to store nested data that will be a side-effect of the filter\n    const nestedData: GenericObjectType = {};\n    keys.forEach((key) => {\n      const formValue = get(data, key);\n      let oldKeyedSchema: S = get(oldSchema, [PROPERTIES_KEY, key], {});\n      let newKeyedSchema: S = get(newSchema, [PROPERTIES_KEY, key], {});\n      // Resolve the refs if they exist\n      if (has(oldKeyedSchema, REF_KEY)) {\n        oldKeyedSchema = retrieveSchema<T, S, F>(validator, oldKeyedSchema, rootSchema, formValue);\n      }\n      if (has(newKeyedSchema, REF_KEY)) {\n        newKeyedSchema = retrieveSchema<T, S, F>(validator, newKeyedSchema, rootSchema, formValue);\n      }\n      // Now get types and see if they are the same\n      const oldSchemaTypeForKey = get(oldKeyedSchema, 'type');\n      const newSchemaTypeForKey = get(newKeyedSchema, 'type');\n      // Check if the old option has the same key with the same type\n      if (!oldSchemaTypeForKey || oldSchemaTypeForKey === newSchemaTypeForKey) {\n        if (has(removeOldSchemaData, key)) {\n          // SIDE-EFFECT: remove the undefined value for a key that has the same type between the old and new schemas\n          delete removeOldSchemaData[key];\n        }\n        // If it is an object, we'll recurse and store the resulting sanitized data for the key\n        if (newSchemaTypeForKey === 'object' || (newSchemaTypeForKey === 'array' && Array.isArray(formValue))) {\n          // SIDE-EFFECT: process the new schema type of object recursively to save iterations\n          const itemData = sanitizeDataForNewSchema<T, S, F>(\n            validator,\n            rootSchema,\n            newKeyedSchema,\n            oldKeyedSchema,\n            formValue\n          );\n          if (itemData !== undefined || newSchemaTypeForKey === 'array') {\n            // only put undefined values for the array type and not the object type\n            nestedData[key] = itemData;\n          }\n        } else {\n          // Ok, the non-object types match, let's make sure that a default or a const of a different value is replaced\n          // with the new default or const. This allows the case where two schemas differ that only by the default/const\n          // value to be properly selected\n          const newOptionDefault = get(newKeyedSchema, 'default', NO_VALUE);\n          const oldOptionDefault = get(oldKeyedSchema, 'default', NO_VALUE);\n          if (newOptionDefault !== NO_VALUE && newOptionDefault !== formValue) {\n            if (oldOptionDefault === formValue) {\n              // If the old default matches the formValue, we'll update the new value to match the new default\n              removeOldSchemaData[key] = newOptionDefault;\n            } else if (get(newKeyedSchema, 'readOnly') === true) {\n              // If the new schema has the default set to read-only, treat it like a const and remove the value\n              removeOldSchemaData[key] = undefined;\n            }\n          }\n\n          const newOptionConst = get(newKeyedSchema, 'const', NO_VALUE);\n          const oldOptionConst = get(oldKeyedSchema, 'const', NO_VALUE);\n          if (newOptionConst !== NO_VALUE && newOptionConst !== formValue) {\n            // Since this is a const, if the old value matches, replace the value with the new const otherwise clear it\n            removeOldSchemaData[key] = oldOptionConst === formValue ? newOptionConst : undefined;\n          }\n        }\n      }\n    });\n\n    newFormData = {\n      ...(typeof data == 'string' || Array.isArray(data) ? undefined : data),\n      ...removeOldSchemaData,\n      ...nestedData,\n    };\n    // First apply removing the old schema data, then apply the nested data, then apply the old data keys to keep\n  } else if (get(oldSchema, 'type') === 'array' && get(newSchema, 'type') === 'array' && Array.isArray(data)) {\n    let oldSchemaItems = get(oldSchema, 'items');\n    let newSchemaItems = get(newSchema, 'items');\n    // If any of the array types `items` are arrays (remember arrays are objects) then we'll just drop the data\n    // Eventually, we may want to deal with when either of the `items` are arrays since those tuple validations\n    if (\n      typeof oldSchemaItems === 'object' &&\n      typeof newSchemaItems === 'object' &&\n      !Array.isArray(oldSchemaItems) &&\n      !Array.isArray(newSchemaItems)\n    ) {\n      if (has(oldSchemaItems, REF_KEY)) {\n        oldSchemaItems = retrieveSchema<T, S, F>(validator, oldSchemaItems as S, rootSchema, data as T);\n      }\n      if (has(newSchemaItems, REF_KEY)) {\n        newSchemaItems = retrieveSchema<T, S, F>(validator, newSchemaItems as S, rootSchema, data as T);\n      }\n      // Now get types and see if they are the same\n      const oldSchemaType = get(oldSchemaItems, 'type');\n      const newSchemaType = get(newSchemaItems, 'type');\n      // Check if the old option has the same key with the same type\n      if (!oldSchemaType || oldSchemaType === newSchemaType) {\n        const maxItems = get(newSchema, 'maxItems', -1);\n        if (newSchemaType === 'object') {\n          newFormData = data.reduce((newValue, aValue) => {\n            const itemValue = sanitizeDataForNewSchema<T, S, F>(\n              validator,\n              rootSchema,\n              newSchemaItems as S,\n              oldSchemaItems as S,\n              aValue\n            );\n            if (itemValue !== undefined && (maxItems < 0 || newValue.length < maxItems)) {\n              newValue.push(itemValue);\n            }\n            return newValue;\n          }, []);\n        } else {\n          newFormData = maxItems > 0 && data.length > maxItems ? data.slice(0, maxItems) : data;\n        }\n      }\n    } else if (\n      typeof oldSchemaItems === 'boolean' &&\n      typeof newSchemaItems === 'boolean' &&\n      oldSchemaItems === newSchemaItems\n    ) {\n      // If they are both booleans and have the same value just return the data as is otherwise fall-thru to undefined\n      newFormData = data;\n    }\n    // Also probably want to deal with `prefixItems` as tuples with the latest 2020 draft\n  }\n  return newFormData as T;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}