{"ast":null,"code":"import { jsx as _jsx, jsxs as _jsxs } from \"react/jsx-runtime\";\nimport { Component } from 'react';\nimport get from 'lodash/get';\nimport isEmpty from 'lodash/isEmpty';\nimport omit from 'lodash/omit';\nimport { deepEquals, ERRORS_KEY, getDiscriminatorFieldFromSchema, getUiOptions, getWidget, mergeSchemas, TranslatableString } from '@rjsf/utils';\n/** The `AnyOfField` component is used to render a field in the schema that is an `anyOf`, `allOf` or `oneOf`. It tracks\n * the currently selected option and cleans up any irrelevant data in `formData`.\n *\n * @param props - The `FieldProps` for this template\n */\nclass AnyOfField extends Component {\n  /** Constructs an `AnyOfField` with the given `props` to initialize the initially selected option in state\n   *\n   * @param props - The `FieldProps` for this template\n   */\n  constructor(props) {\n    super(props);\n    /** Callback handler to remember what the currently selected option is. In addition to that the `formData` is updated\n     * to remove properties that are not part of the newly selected option schema, and then the updated data is passed to\n     * the `onChange` handler.\n     *\n     * @param option - The new option value being selected\n     */\n    this.onOptionChange = option => {\n      const {\n        selectedOption,\n        retrievedOptions\n      } = this.state;\n      const {\n        formData,\n        onChange,\n        registry\n      } = this.props;\n      const {\n        schemaUtils\n      } = registry;\n      const intOption = option !== undefined ? parseInt(option, 10) : -1;\n      if (intOption === selectedOption) {\n        return;\n      }\n      const newOption = intOption >= 0 ? retrievedOptions[intOption] : undefined;\n      const oldOption = selectedOption >= 0 ? retrievedOptions[selectedOption] : undefined;\n      let newFormData = schemaUtils.sanitizeDataForNewSchema(newOption, oldOption, formData);\n      if (newFormData && newOption) {\n        // Call getDefaultFormState to make sure defaults are populated on change. Pass \"excludeObjectChildren\"\n        // so that only the root objects themselves are created without adding undefined children properties\n        newFormData = schemaUtils.getDefaultFormState(newOption, newFormData, 'excludeObjectChildren');\n      }\n      onChange(newFormData, undefined, this.getFieldId());\n      this.setState({\n        selectedOption: intOption\n      });\n    };\n    const {\n      formData,\n      options,\n      registry: {\n        schemaUtils\n      }\n    } = this.props;\n    // cache the retrieved options in state in case they have $refs to save doing it later\n    const retrievedOptions = options.map(opt => schemaUtils.retrieveSchema(opt, formData));\n    this.state = {\n      retrievedOptions,\n      selectedOption: this.getMatchingOption(0, formData, retrievedOptions)\n    };\n  }\n  /** React lifecycle method that is called when the props and/or state for this component is updated. It recomputes the\n   * currently selected option based on the overall `formData`\n   *\n   * @param prevProps - The previous `FieldProps` for this template\n   * @param prevState - The previous `AnyOfFieldState` for this template\n   */\n  componentDidUpdate(prevProps, prevState) {\n    const {\n      formData,\n      options,\n      idSchema\n    } = this.props;\n    const {\n      selectedOption\n    } = this.state;\n    let newState = this.state;\n    if (!deepEquals(prevProps.options, options)) {\n      const {\n        registry: {\n          schemaUtils\n        }\n      } = this.props;\n      // re-cache the retrieved options in state in case they have $refs to save doing it later\n      const retrievedOptions = options.map(opt => schemaUtils.retrieveSchema(opt, formData));\n      newState = {\n        selectedOption,\n        retrievedOptions\n      };\n    }\n    if (!deepEquals(formData, prevProps.formData) && idSchema.$id === prevProps.idSchema.$id) {\n      const {\n        retrievedOptions\n      } = newState;\n      const matchingOption = this.getMatchingOption(selectedOption, formData, retrievedOptions);\n      if (prevState && matchingOption !== selectedOption) {\n        newState = {\n          selectedOption: matchingOption,\n          retrievedOptions\n        };\n      }\n    }\n    if (newState !== this.state) {\n      this.setState(newState);\n    }\n  }\n  /** Determines the best matching option for the given `formData` and `options`.\n   *\n   * @param formData - The new formData\n   * @param options - The list of options to choose from\n   * @return - The index of the `option` that best matches the `formData`\n   */\n  getMatchingOption(selectedOption, formData, options) {\n    const {\n      schema,\n      registry: {\n        schemaUtils\n      }\n    } = this.props;\n    const discriminator = getDiscriminatorFieldFromSchema(schema);\n    const option = schemaUtils.getClosestMatchingOption(formData, options, selectedOption, discriminator);\n    return option;\n  }\n  getFieldId() {\n    const {\n      idSchema,\n      schema\n    } = this.props;\n    return `${idSchema.$id}${schema.oneOf ? '__oneof_select' : '__anyof_select'}`;\n  }\n  /** Renders the `AnyOfField` selector along with a `SchemaField` for the value of the `formData`\n   */\n  render() {\n    const {\n      name,\n      disabled = false,\n      errorSchema = {},\n      formContext,\n      onBlur,\n      onFocus,\n      registry,\n      schema,\n      uiSchema\n    } = this.props;\n    const {\n      widgets,\n      fields,\n      translateString,\n      globalUiOptions,\n      schemaUtils\n    } = registry;\n    const {\n      SchemaField: _SchemaField\n    } = fields;\n    const {\n      selectedOption,\n      retrievedOptions\n    } = this.state;\n    const {\n      widget = 'select',\n      placeholder,\n      autofocus,\n      autocomplete,\n      title = schema.title,\n      ...uiOptions\n    } = getUiOptions(uiSchema, globalUiOptions);\n    const Widget = getWidget({\n      type: 'number'\n    }, widget, widgets);\n    const rawErrors = get(errorSchema, ERRORS_KEY, []);\n    const fieldErrorSchema = omit(errorSchema, [ERRORS_KEY]);\n    const displayLabel = schemaUtils.getDisplayLabel(schema, uiSchema, globalUiOptions);\n    const option = selectedOption >= 0 ? retrievedOptions[selectedOption] || null : null;\n    let optionSchema;\n    if (option) {\n      // merge top level required field\n      const {\n        required\n      } = schema;\n      // Merge in all the non-oneOf/anyOf properties and also skip the special ADDITIONAL_PROPERTY_FLAG property\n      optionSchema = required ? mergeSchemas({\n        required\n      }, option) : option;\n    }\n    const translateEnum = title ? TranslatableString.TitleOptionPrefix : TranslatableString.OptionPrefix;\n    const translateParams = title ? [title] : [];\n    const enumOptions = retrievedOptions.map((opt, index) => ({\n      label: opt.title || translateString(translateEnum, translateParams.concat(String(index + 1))),\n      value: index\n    }));\n    return _jsxs(\"div\", {\n      className: 'panel panel-default panel-body',\n      children: [_jsx(\"div\", {\n        className: 'form-group',\n        children: _jsx(Widget, {\n          id: this.getFieldId(),\n          name: `${name}${schema.oneOf ? '__oneof_select' : '__anyof_select'}`,\n          schema: {\n            type: 'number',\n            default: 0\n          },\n          onChange: this.onOptionChange,\n          onBlur: onBlur,\n          onFocus: onFocus,\n          disabled: disabled || isEmpty(enumOptions),\n          multiple: false,\n          rawErrors: rawErrors,\n          errorSchema: fieldErrorSchema,\n          value: selectedOption >= 0 ? selectedOption : undefined,\n          options: {\n            enumOptions,\n            ...uiOptions\n          },\n          registry: registry,\n          formContext: formContext,\n          placeholder: placeholder,\n          autocomplete: autocomplete,\n          autofocus: autofocus,\n          label: title !== null && title !== void 0 ? title : name,\n          hideLabel: !displayLabel\n        })\n      }), option !== null && _jsx(_SchemaField, {\n        ...this.props,\n        schema: optionSchema\n      })]\n    });\n  }\n}\nexport default AnyOfField;","map":{"version":3,"names":["Component","get","isEmpty","omit","deepEquals","ERRORS_KEY","getDiscriminatorFieldFromSchema","getUiOptions","getWidget","mergeSchemas","TranslatableString","AnyOfField","constructor","props","onOptionChange","option","selectedOption","retrievedOptions","state","formData","onChange","registry","schemaUtils","intOption","undefined","parseInt","newOption","oldOption","newFormData","sanitizeDataForNewSchema","getDefaultFormState","getFieldId","setState","options","map","opt","retrieveSchema","getMatchingOption","componentDidUpdate","prevProps","prevState","idSchema","newState","$id","matchingOption","schema","discriminator","getClosestMatchingOption","oneOf","render","name","disabled","errorSchema","formContext","onBlur","onFocus","uiSchema","widgets","fields","translateString","globalUiOptions","SchemaField","_SchemaField","widget","placeholder","autofocus","autocomplete","title","uiOptions","Widget","type","rawErrors","fieldErrorSchema","displayLabel","getDisplayLabel","optionSchema","required","translateEnum","TitleOptionPrefix","OptionPrefix","translateParams","enumOptions","index","label","concat","String","value","_jsxs","className","children","_jsx","id","default","multiple","hideLabel"],"sources":["D:\\Reactjs\\my-app\\node_modules\\@rjsf\\core\\src\\components\\fields\\MultiSchemaField.tsx"],"sourcesContent":["import { Component } from 'react';\nimport get from 'lodash/get';\nimport isEmpty from 'lodash/isEmpty';\nimport omit from 'lodash/omit';\nimport {\n  deepEquals,\n  ERRORS_KEY,\n  FieldProps,\n  FormContextType,\n  getDiscriminatorFieldFromSchema,\n  getUiOptions,\n  getWidget,\n  mergeSchemas,\n  RJSFSchema,\n  StrictRJSFSchema,\n  TranslatableString,\n} from '@rjsf/utils';\n\n/** Type used for the state of the `AnyOfField` component */\ntype AnyOfFieldState<S extends StrictRJSFSchema = RJSFSchema> = {\n  /** The currently selected option */\n  selectedOption: number;\n  /** The option schemas after retrieving all $refs */\n  retrievedOptions: S[];\n};\n\n/** The `AnyOfField` component is used to render a field in the schema that is an `anyOf`, `allOf` or `oneOf`. It tracks\n * the currently selected option and cleans up any irrelevant data in `formData`.\n *\n * @param props - The `FieldProps` for this template\n */\nclass AnyOfField<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any> extends Component<\n  FieldProps<T, S, F>,\n  AnyOfFieldState<S>\n> {\n  /** Constructs an `AnyOfField` with the given `props` to initialize the initially selected option in state\n   *\n   * @param props - The `FieldProps` for this template\n   */\n  constructor(props: FieldProps<T, S, F>) {\n    super(props);\n\n    const {\n      formData,\n      options,\n      registry: { schemaUtils },\n    } = this.props;\n    // cache the retrieved options in state in case they have $refs to save doing it later\n    const retrievedOptions = options.map((opt: S) => schemaUtils.retrieveSchema(opt, formData));\n\n    this.state = {\n      retrievedOptions,\n      selectedOption: this.getMatchingOption(0, formData, retrievedOptions),\n    };\n  }\n\n  /** React lifecycle method that is called when the props and/or state for this component is updated. It recomputes the\n   * currently selected option based on the overall `formData`\n   *\n   * @param prevProps - The previous `FieldProps` for this template\n   * @param prevState - The previous `AnyOfFieldState` for this template\n   */\n  componentDidUpdate(prevProps: Readonly<FieldProps<T, S, F>>, prevState: Readonly<AnyOfFieldState>) {\n    const { formData, options, idSchema } = this.props;\n    const { selectedOption } = this.state;\n    let newState = this.state;\n    if (!deepEquals(prevProps.options, options)) {\n      const {\n        registry: { schemaUtils },\n      } = this.props;\n      // re-cache the retrieved options in state in case they have $refs to save doing it later\n      const retrievedOptions = options.map((opt: S) => schemaUtils.retrieveSchema(opt, formData));\n      newState = { selectedOption, retrievedOptions };\n    }\n    if (!deepEquals(formData, prevProps.formData) && idSchema.$id === prevProps.idSchema.$id) {\n      const { retrievedOptions } = newState;\n      const matchingOption = this.getMatchingOption(selectedOption, formData, retrievedOptions);\n\n      if (prevState && matchingOption !== selectedOption) {\n        newState = { selectedOption: matchingOption, retrievedOptions };\n      }\n    }\n    if (newState !== this.state) {\n      this.setState(newState);\n    }\n  }\n\n  /** Determines the best matching option for the given `formData` and `options`.\n   *\n   * @param formData - The new formData\n   * @param options - The list of options to choose from\n   * @return - The index of the `option` that best matches the `formData`\n   */\n  getMatchingOption(selectedOption: number, formData: T | undefined, options: S[]) {\n    const {\n      schema,\n      registry: { schemaUtils },\n    } = this.props;\n\n    const discriminator = getDiscriminatorFieldFromSchema<S>(schema);\n    const option = schemaUtils.getClosestMatchingOption(formData, options, selectedOption, discriminator);\n    return option;\n  }\n\n  /** Callback handler to remember what the currently selected option is. In addition to that the `formData` is updated\n   * to remove properties that are not part of the newly selected option schema, and then the updated data is passed to\n   * the `onChange` handler.\n   *\n   * @param option - The new option value being selected\n   */\n  onOptionChange = (option?: string) => {\n    const { selectedOption, retrievedOptions } = this.state;\n    const { formData, onChange, registry } = this.props;\n    const { schemaUtils } = registry;\n    const intOption = option !== undefined ? parseInt(option, 10) : -1;\n    if (intOption === selectedOption) {\n      return;\n    }\n    const newOption = intOption >= 0 ? retrievedOptions[intOption] : undefined;\n    const oldOption = selectedOption >= 0 ? retrievedOptions[selectedOption] : undefined;\n\n    let newFormData = schemaUtils.sanitizeDataForNewSchema(newOption, oldOption, formData);\n    if (newFormData && newOption) {\n      // Call getDefaultFormState to make sure defaults are populated on change. Pass \"excludeObjectChildren\"\n      // so that only the root objects themselves are created without adding undefined children properties\n      newFormData = schemaUtils.getDefaultFormState(newOption, newFormData, 'excludeObjectChildren') as T;\n    }\n    onChange(newFormData, undefined, this.getFieldId());\n\n    this.setState({ selectedOption: intOption });\n  };\n\n  getFieldId() {\n    const { idSchema, schema } = this.props;\n    return `${idSchema.$id}${schema.oneOf ? '__oneof_select' : '__anyof_select'}`;\n  }\n\n  /** Renders the `AnyOfField` selector along with a `SchemaField` for the value of the `formData`\n   */\n  render() {\n    const {\n      name,\n      disabled = false,\n      errorSchema = {},\n      formContext,\n      onBlur,\n      onFocus,\n      registry,\n      schema,\n      uiSchema,\n    } = this.props;\n\n    const { widgets, fields, translateString, globalUiOptions, schemaUtils } = registry;\n    const { SchemaField: _SchemaField } = fields;\n    const { selectedOption, retrievedOptions } = this.state;\n    const {\n      widget = 'select',\n      placeholder,\n      autofocus,\n      autocomplete,\n      title = schema.title,\n      ...uiOptions\n    } = getUiOptions<T, S, F>(uiSchema, globalUiOptions);\n    const Widget = getWidget<T, S, F>({ type: 'number' }, widget, widgets);\n    const rawErrors = get(errorSchema, ERRORS_KEY, []);\n    const fieldErrorSchema = omit(errorSchema, [ERRORS_KEY]);\n    const displayLabel = schemaUtils.getDisplayLabel(schema, uiSchema, globalUiOptions);\n\n    const option = selectedOption >= 0 ? retrievedOptions[selectedOption] || null : null;\n    let optionSchema: S;\n\n    if (option) {\n      // merge top level required field\n      const { required } = schema;\n      // Merge in all the non-oneOf/anyOf properties and also skip the special ADDITIONAL_PROPERTY_FLAG property\n      optionSchema = required ? (mergeSchemas({ required }, option) as S) : option;\n    }\n\n    const translateEnum: TranslatableString = title\n      ? TranslatableString.TitleOptionPrefix\n      : TranslatableString.OptionPrefix;\n    const translateParams = title ? [title] : [];\n    const enumOptions = retrievedOptions.map((opt: { title?: string }, index: number) => ({\n      label: opt.title || translateString(translateEnum, translateParams.concat(String(index + 1))),\n      value: index,\n    }));\n\n    return (\n      <div className='panel panel-default panel-body'>\n        <div className='form-group'>\n          <Widget\n            id={this.getFieldId()}\n            name={`${name}${schema.oneOf ? '__oneof_select' : '__anyof_select'}`}\n            schema={{ type: 'number', default: 0 } as S}\n            onChange={this.onOptionChange}\n            onBlur={onBlur}\n            onFocus={onFocus}\n            disabled={disabled || isEmpty(enumOptions)}\n            multiple={false}\n            rawErrors={rawErrors}\n            errorSchema={fieldErrorSchema}\n            value={selectedOption >= 0 ? selectedOption : undefined}\n            options={{ enumOptions, ...uiOptions }}\n            registry={registry}\n            formContext={formContext}\n            placeholder={placeholder}\n            autocomplete={autocomplete}\n            autofocus={autofocus}\n            label={title ?? name}\n            hideLabel={!displayLabel}\n          />\n        </div>\n        {option !== null && <_SchemaField {...this.props} schema={optionSchema!} />}\n      </div>\n    );\n  }\n}\n\nexport default AnyOfField;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}