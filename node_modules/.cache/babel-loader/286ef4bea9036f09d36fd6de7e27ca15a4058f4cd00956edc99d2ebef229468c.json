{"ast":null,"code":"import get from 'lodash/get';\nimport has from 'lodash/has';\nimport isNumber from 'lodash/isNumber';\nimport { PROPERTIES_KEY } from '../constants';\nimport getOptionMatchingSimpleDiscriminator from '../getOptionMatchingSimpleDiscriminator';\n/** Given the `formData` and list of `options`, attempts to find the index of the option that best matches the data.\n * Deprecated, use `getFirstMatchingOption()` instead.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param formData - The current formData, if any, used to figure out a match\n * @param options - The list of options to find a matching options from\n * @param rootSchema - The root schema, used to primarily to look up `$ref`s\n * @param [discriminatorField] - The optional name of the field within the options object whose value is used to\n *          determine which option is selected\n * @returns - The index of the matched option or 0 if none is available\n * @deprecated\n */\nexport default function getMatchingOption(validator, formData, options, rootSchema, discriminatorField) {\n  // For performance, skip validating subschemas if formData is undefined. We just\n  // want to get the first option in that case.\n  if (formData === undefined) {\n    return 0;\n  }\n  const simpleDiscriminatorMatch = getOptionMatchingSimpleDiscriminator(formData, options, discriminatorField);\n  if (isNumber(simpleDiscriminatorMatch)) {\n    return simpleDiscriminatorMatch;\n  }\n  for (let i = 0; i < options.length; i++) {\n    const option = options[i];\n    // If we have a discriminator field, then we will use this to make the determination\n    if (discriminatorField && has(option, [PROPERTIES_KEY, discriminatorField])) {\n      const value = get(formData, discriminatorField);\n      const discriminator = get(option, [PROPERTIES_KEY, discriminatorField], {});\n      if (validator.isValid(discriminator, value, rootSchema)) {\n        return i;\n      }\n    } else if (option[PROPERTIES_KEY]) {\n      // If the schema describes an object then we need to add slightly more\n      // strict matching to the schema, because unless the schema uses the\n      // \"requires\" keyword, an object will match the schema as long as it\n      // doesn't have matching keys with a conflicting type. To do this we use an\n      // \"anyOf\" with an array of requires. This augmentation expresses that the\n      // schema should match if any of the keys in the schema are present on the\n      // object and pass validation.\n      //\n      // Create an \"anyOf\" schema that requires at least one of the keys in the\n      // \"properties\" object\n      const requiresAnyOf = {\n        anyOf: Object.keys(option[PROPERTIES_KEY]).map(key => ({\n          required: [key]\n        }))\n      };\n      let augmentedSchema;\n      // If the \"anyOf\" keyword already exists, wrap the augmentation in an \"allOf\"\n      if (option.anyOf) {\n        // Create a shallow clone of the option\n        const {\n          ...shallowClone\n        } = option;\n        if (!shallowClone.allOf) {\n          shallowClone.allOf = [];\n        } else {\n          // If \"allOf\" already exists, shallow clone the array\n          shallowClone.allOf = shallowClone.allOf.slice();\n        }\n        shallowClone.allOf.push(requiresAnyOf);\n        augmentedSchema = shallowClone;\n      } else {\n        augmentedSchema = Object.assign({}, option, requiresAnyOf);\n      }\n      // Remove the \"required\" field as it's likely that not all fields have\n      // been filled in yet, which will mean that the schema is not valid\n      delete augmentedSchema.required;\n      if (validator.isValid(augmentedSchema, formData, rootSchema)) {\n        return i;\n      }\n    } else if (validator.isValid(option, formData, rootSchema)) {\n      return i;\n    }\n  }\n  return 0;\n}","map":{"version":3,"names":["get","has","isNumber","PROPERTIES_KEY","getOptionMatchingSimpleDiscriminator","getMatchingOption","validator","formData","options","rootSchema","discriminatorField","undefined","simpleDiscriminatorMatch","i","length","option","value","discriminator","isValid","requiresAnyOf","anyOf","Object","keys","map","key","required","augmentedSchema","shallowClone","allOf","slice","push","assign"],"sources":["D:\\Reactjs\\my-app\\node_modules\\@rjsf\\utils\\src\\schema\\getMatchingOption.ts"],"sourcesContent":["import get from 'lodash/get';\nimport has from 'lodash/has';\nimport isNumber from 'lodash/isNumber';\n\nimport { PROPERTIES_KEY } from '../constants';\nimport { FormContextType, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\nimport getOptionMatchingSimpleDiscriminator from '../getOptionMatchingSimpleDiscriminator';\n\n/** Given the `formData` and list of `options`, attempts to find the index of the option that best matches the data.\n * Deprecated, use `getFirstMatchingOption()` instead.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param formData - The current formData, if any, used to figure out a match\n * @param options - The list of options to find a matching options from\n * @param rootSchema - The root schema, used to primarily to look up `$ref`s\n * @param [discriminatorField] - The optional name of the field within the options object whose value is used to\n *          determine which option is selected\n * @returns - The index of the matched option or 0 if none is available\n * @deprecated\n */\nexport default function getMatchingOption<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(\n  validator: ValidatorType<T, S, F>,\n  formData: T | undefined,\n  options: S[],\n  rootSchema: S,\n  discriminatorField?: string\n): number {\n  // For performance, skip validating subschemas if formData is undefined. We just\n  // want to get the first option in that case.\n  if (formData === undefined) {\n    return 0;\n  }\n\n  const simpleDiscriminatorMatch = getOptionMatchingSimpleDiscriminator(formData, options, discriminatorField);\n  if (isNumber(simpleDiscriminatorMatch)) {\n    return simpleDiscriminatorMatch;\n  }\n\n  for (let i = 0; i < options.length; i++) {\n    const option = options[i];\n\n    // If we have a discriminator field, then we will use this to make the determination\n    if (discriminatorField && has(option, [PROPERTIES_KEY, discriminatorField])) {\n      const value = get(formData, discriminatorField);\n      const discriminator = get(option, [PROPERTIES_KEY, discriminatorField], {});\n      if (validator.isValid(discriminator, value, rootSchema)) {\n        return i;\n      }\n    } else if (option[PROPERTIES_KEY]) {\n      // If the schema describes an object then we need to add slightly more\n      // strict matching to the schema, because unless the schema uses the\n      // \"requires\" keyword, an object will match the schema as long as it\n      // doesn't have matching keys with a conflicting type. To do this we use an\n      // \"anyOf\" with an array of requires. This augmentation expresses that the\n      // schema should match if any of the keys in the schema are present on the\n      // object and pass validation.\n      //\n      // Create an \"anyOf\" schema that requires at least one of the keys in the\n      // \"properties\" object\n      const requiresAnyOf = {\n        anyOf: Object.keys(option[PROPERTIES_KEY]).map((key) => ({\n          required: [key],\n        })),\n      };\n\n      let augmentedSchema;\n\n      // If the \"anyOf\" keyword already exists, wrap the augmentation in an \"allOf\"\n      if (option.anyOf) {\n        // Create a shallow clone of the option\n        const { ...shallowClone } = option;\n\n        if (!shallowClone.allOf) {\n          shallowClone.allOf = [];\n        } else {\n          // If \"allOf\" already exists, shallow clone the array\n          shallowClone.allOf = shallowClone.allOf.slice();\n        }\n\n        shallowClone.allOf.push(requiresAnyOf);\n\n        augmentedSchema = shallowClone;\n      } else {\n        augmentedSchema = Object.assign({}, option, requiresAnyOf);\n      }\n\n      // Remove the \"required\" field as it's likely that not all fields have\n      // been filled in yet, which will mean that the schema is not valid\n      delete augmentedSchema.required;\n\n      if (validator.isValid(augmentedSchema, formData, rootSchema)) {\n        return i;\n      }\n    } else if (validator.isValid(option, formData, rootSchema)) {\n      return i;\n    }\n  }\n  return 0;\n}\n"],"mappings":"AAAA,OAAOA,GAAG,MAAM,YAAY;AAC5B,OAAOC,GAAG,MAAM,YAAY;AAC5B,OAAOC,QAAQ,MAAM,iBAAiB;AAEtC,SAASC,cAAc,QAAQ,cAAc;AAE7C,OAAOC,oCAAoC,MAAM,yCAAyC;AAE1F;;;;;;;;;;;;AAYA,eAAc,SAAUC,iBAAiBA,CAKvCC,SAAiC,EACjCC,QAAuB,EACvBC,OAAY,EACZC,UAAa,EACbC,kBAA2B;EAE3B;EACA;EACA,IAAIH,QAAQ,KAAKI,SAAS,EAAE;IAC1B,OAAO,CAAC;;EAGV,MAAMC,wBAAwB,GAAGR,oCAAoC,CAACG,QAAQ,EAAEC,OAAO,EAAEE,kBAAkB,CAAC;EAC5G,IAAIR,QAAQ,CAACU,wBAAwB,CAAC,EAAE;IACtC,OAAOA,wBAAwB;;EAGjC,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGL,OAAO,CAACM,MAAM,EAAED,CAAC,EAAE,EAAE;IACvC,MAAME,MAAM,GAAGP,OAAO,CAACK,CAAC,CAAC;IAEzB;IACA,IAAIH,kBAAkB,IAAIT,GAAG,CAACc,MAAM,EAAE,CAACZ,cAAc,EAAEO,kBAAkB,CAAC,CAAC,EAAE;MAC3E,MAAMM,KAAK,GAAGhB,GAAG,CAACO,QAAQ,EAAEG,kBAAkB,CAAC;MAC/C,MAAMO,aAAa,GAAGjB,GAAG,CAACe,MAAM,EAAE,CAACZ,cAAc,EAAEO,kBAAkB,CAAC,EAAE,EAAE,CAAC;MAC3E,IAAIJ,SAAS,CAACY,OAAO,CAACD,aAAa,EAAED,KAAK,EAAEP,UAAU,CAAC,EAAE;QACvD,OAAOI,CAAC;;KAEX,MAAM,IAAIE,MAAM,CAACZ,cAAc,CAAC,EAAE;MACjC;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA,MAAMgB,aAAa,GAAG;QACpBC,KAAK,EAAEC,MAAM,CAACC,IAAI,CAACP,MAAM,CAACZ,cAAc,CAAC,CAAC,CAACoB,GAAG,CAAEC,GAAG,KAAM;UACvDC,QAAQ,EAAE,CAACD,GAAG;SACf,CAAC;OACH;MAED,IAAIE,eAAe;MAEnB;MACA,IAAIX,MAAM,CAACK,KAAK,EAAE;QAChB;QACA,MAAM;UAAE,GAAGO;QAAY,CAAE,GAAGZ,MAAM;QAElC,IAAI,CAACY,YAAY,CAACC,KAAK,EAAE;UACvBD,YAAY,CAACC,KAAK,GAAG,EAAE;SACxB,MAAM;UACL;UACAD,YAAY,CAACC,KAAK,GAAGD,YAAY,CAACC,KAAK,CAACC,KAAK,EAAE;;QAGjDF,YAAY,CAACC,KAAK,CAACE,IAAI,CAACX,aAAa,CAAC;QAEtCO,eAAe,GAAGC,YAAY;OAC/B,MAAM;QACLD,eAAe,GAAGL,MAAM,CAACU,MAAM,CAAC,EAAE,EAAEhB,MAAM,EAAEI,aAAa,CAAC;;MAG5D;MACA;MACA,OAAOO,eAAe,CAACD,QAAQ;MAE/B,IAAInB,SAAS,CAACY,OAAO,CAACQ,eAAe,EAAEnB,QAAQ,EAAEE,UAAU,CAAC,EAAE;QAC5D,OAAOI,CAAC;;KAEX,MAAM,IAAIP,SAAS,CAACY,OAAO,CAACH,MAAM,EAAER,QAAQ,EAAEE,UAAU,CAAC,EAAE;MAC1D,OAAOI,CAAC;;;EAGZ,OAAO,CAAC;AACV"},"metadata":{},"sourceType":"module","externalDependencies":[]}