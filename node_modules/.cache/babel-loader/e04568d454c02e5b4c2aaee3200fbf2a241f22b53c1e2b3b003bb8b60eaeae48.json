{"ast":null,"code":"import enumOptionsValueForIndex from './enumOptionsValueForIndex';\nimport isNil from 'lodash/isNil';\n/** Add the enum option value at the `valueIndex` to the list of `selected` values in the proper order as defined by\n * `allEnumOptions`\n *\n * @param valueIndex - The index of the value that should be selected\n * @param selected - The current list of selected values\n * @param [allEnumOptions=[]] - The list of all the known enumOptions\n * @returns - The updated list of selected enum values with enum value at the `valueIndex` added to it\n */\nexport default function enumOptionsSelectValue(valueIndex, selected, allEnumOptions = []) {\n  const value = enumOptionsValueForIndex(valueIndex, allEnumOptions);\n  if (!isNil(value)) {\n    const index = allEnumOptions.findIndex(opt => value === opt.value);\n    const all = allEnumOptions.map(({\n      value: val\n    }) => val);\n    const updated = selected.slice(0, index).concat(value, selected.slice(index));\n    // As inserting values at predefined index positions doesn't work with empty\n    // arrays, we need to reorder the updated selection to match the initial order\n    return updated.sort((a, b) => Number(all.indexOf(a) > all.indexOf(b)));\n  }\n  return selected;\n}","map":{"version":3,"names":["enumOptionsValueForIndex","isNil","enumOptionsSelectValue","valueIndex","selected","allEnumOptions","value","index","findIndex","opt","all","map","val","updated","slice","concat","sort","a","b","Number","indexOf"],"sources":["D:\\Reactjs\\my-app\\node_modules\\@rjsf\\utils\\src\\enumOptionsSelectValue.ts"],"sourcesContent":["import { EnumOptionsType, RJSFSchema, StrictRJSFSchema } from './types';\nimport enumOptionsValueForIndex from './enumOptionsValueForIndex';\nimport isNil from 'lodash/isNil';\n\n/** Add the enum option value at the `valueIndex` to the list of `selected` values in the proper order as defined by\n * `allEnumOptions`\n *\n * @param valueIndex - The index of the value that should be selected\n * @param selected - The current list of selected values\n * @param [allEnumOptions=[]] - The list of all the known enumOptions\n * @returns - The updated list of selected enum values with enum value at the `valueIndex` added to it\n */\nexport default function enumOptionsSelectValue<S extends StrictRJSFSchema = RJSFSchema>(\n  valueIndex: string | number,\n  selected: EnumOptionsType<S>['value'][],\n  allEnumOptions: EnumOptionsType<S>[] = []\n) {\n  const value = enumOptionsValueForIndex<S>(valueIndex, allEnumOptions);\n  if (!isNil(value)) {\n    const index = allEnumOptions.findIndex((opt) => value === opt.value);\n    const all = allEnumOptions.map(({ value: val }) => val);\n    const updated = selected.slice(0, index).concat(value, selected.slice(index));\n    // As inserting values at predefined index positions doesn't work with empty\n    // arrays, we need to reorder the updated selection to match the initial order\n    return updated.sort((a, b) => Number(all.indexOf(a) > all.indexOf(b)));\n  }\n  return selected;\n}\n"],"mappings":"AACA,OAAOA,wBAAwB,MAAM,4BAA4B;AACjE,OAAOC,KAAK,MAAM,cAAc;AAEhC;;;;;;;;AAQA,eAAc,SAAUC,sBAAsBA,CAC5CC,UAA2B,EAC3BC,QAAuC,EACvCC,cAAA,GAAuC,EAAE;EAEzC,MAAMC,KAAK,GAAGN,wBAAwB,CAAIG,UAAU,EAAEE,cAAc,CAAC;EACrE,IAAI,CAACJ,KAAK,CAACK,KAAK,CAAC,EAAE;IACjB,MAAMC,KAAK,GAAGF,cAAc,CAACG,SAAS,CAAEC,GAAG,IAAKH,KAAK,KAAKG,GAAG,CAACH,KAAK,CAAC;IACpE,MAAMI,GAAG,GAAGL,cAAc,CAACM,GAAG,CAAC,CAAC;MAAEL,KAAK,EAAEM;IAAG,CAAE,KAAKA,GAAG,CAAC;IACvD,MAAMC,OAAO,GAAGT,QAAQ,CAACU,KAAK,CAAC,CAAC,EAAEP,KAAK,CAAC,CAACQ,MAAM,CAACT,KAAK,EAAEF,QAAQ,CAACU,KAAK,CAACP,KAAK,CAAC,CAAC;IAC7E;IACA;IACA,OAAOM,OAAO,CAACG,IAAI,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAKC,MAAM,CAACT,GAAG,CAACU,OAAO,CAACH,CAAC,CAAC,GAAGP,GAAG,CAACU,OAAO,CAACF,CAAC,CAAC,CAAC,CAAC;;EAExE,OAAOd,QAAQ;AACjB"},"metadata":{},"sourceType":"module","externalDependencies":[]}