{"ast":null,"code":"/** Given a list of `properties` and an `order` list, returns a list that contains the `properties` ordered correctly.\n * If `order` is not an array, then the untouched `properties` list is returned. Otherwise `properties` is ordered per\n * the `order` list. If `order` contains a '*' then any `properties` that are not mentioned explicity in `order` will be\n * places in the location of the `*`.\n *\n * @param properties - The list of property keys to be ordered\n * @param order - An array of property keys to be ordered first, with an optional '*' property\n * @returns - A list with the `properties` ordered\n * @throws - Error when the properties cannot be ordered correctly\n */\nexport default function orderProperties(properties, order) {\n  if (!Array.isArray(order)) {\n    return properties;\n  }\n  const arrayToHash = arr => arr.reduce((prev, curr) => {\n    prev[curr] = true;\n    return prev;\n  }, {});\n  const errorPropList = arr => arr.length > 1 ? \"properties '\".concat(arr.join(\"', '\"), \"'\") : \"property '\".concat(arr[0], \"'\");\n  const propertyHash = arrayToHash(properties);\n  const orderFiltered = order.filter(prop => prop === '*' || propertyHash[prop]);\n  const orderHash = arrayToHash(orderFiltered);\n  const rest = properties.filter(prop => !orderHash[prop]);\n  const restIndex = orderFiltered.indexOf('*');\n  if (restIndex === -1) {\n    if (rest.length) {\n      throw new Error(\"uiSchema order list does not contain \".concat(errorPropList(rest)));\n    }\n    return orderFiltered;\n  }\n  if (restIndex !== orderFiltered.lastIndexOf('*')) {\n    throw new Error('uiSchema order list contains more than one wildcard item');\n  }\n  const complete = [...orderFiltered];\n  complete.splice(restIndex, 1, ...rest);\n  return complete;\n}","map":{"version":3,"names":["orderProperties","properties","order","Array","isArray","arrayToHash","arr","reduce","prev","curr","errorPropList","length","concat","join","propertyHash","orderFiltered","filter","prop","orderHash","rest","restIndex","indexOf","Error","lastIndexOf","complete","splice"],"sources":["D:\\Reactjs\\my-app\\node_modules\\@rjsf\\utils\\src\\orderProperties.ts"],"sourcesContent":["import { GenericObjectType } from './types';\n\n/** Given a list of `properties` and an `order` list, returns a list that contains the `properties` ordered correctly.\n * If `order` is not an array, then the untouched `properties` list is returned. Otherwise `properties` is ordered per\n * the `order` list. If `order` contains a '*' then any `properties` that are not mentioned explicity in `order` will be\n * places in the location of the `*`.\n *\n * @param properties - The list of property keys to be ordered\n * @param order - An array of property keys to be ordered first, with an optional '*' property\n * @returns - A list with the `properties` ordered\n * @throws - Error when the properties cannot be ordered correctly\n */\nexport default function orderProperties(properties: string[], order?: string[]): string[] {\n  if (!Array.isArray(order)) {\n    return properties;\n  }\n\n  const arrayToHash = (arr: string[]) =>\n    arr.reduce((prev: GenericObjectType, curr) => {\n      prev[curr] = true;\n      return prev;\n    }, {});\n  const errorPropList = (arr: string[]) =>\n    arr.length > 1 ? `properties '${arr.join(\"', '\")}'` : `property '${arr[0]}'`;\n  const propertyHash = arrayToHash(properties);\n  const orderFiltered = order.filter((prop) => prop === '*' || propertyHash[prop]);\n  const orderHash = arrayToHash(orderFiltered);\n\n  const rest = properties.filter((prop: string) => !orderHash[prop]);\n  const restIndex = orderFiltered.indexOf('*');\n  if (restIndex === -1) {\n    if (rest.length) {\n      throw new Error(`uiSchema order list does not contain ${errorPropList(rest)}`);\n    }\n    return orderFiltered;\n  }\n  if (restIndex !== orderFiltered.lastIndexOf('*')) {\n    throw new Error('uiSchema order list contains more than one wildcard item');\n  }\n\n  const complete = [...orderFiltered];\n  complete.splice(restIndex, 1, ...rest);\n  return complete;\n}\n"],"mappings":"AAEA;;;;;;;;;;AAUA,eAAc,SAAUA,eAAeA,CAACC,UAAoB,EAAEC,KAAgB;EAC5E,IAAI,CAACC,KAAK,CAACC,OAAO,CAACF,KAAK,CAAC,EAAE;IACzB,OAAOD,UAAU;;EAGnB,MAAMI,WAAW,GAAIC,GAAa,IAChCA,GAAG,CAACC,MAAM,CAAC,CAACC,IAAuB,EAAEC,IAAI,KAAI;IAC3CD,IAAI,CAACC,IAAI,CAAC,GAAG,IAAI;IACjB,OAAOD,IAAI;EACb,CAAC,EAAE,EAAE,CAAC;EACR,MAAME,aAAa,GAAIJ,GAAa,IAClCA,GAAG,CAACK,MAAM,GAAG,CAAC,kBAAAC,MAAA,CAAkBN,GAAG,CAACO,IAAI,CAAC,MAAM,CAAC,sBAAAD,MAAA,CAAmBN,GAAG,CAAC,CAAC,CAAC,MAAG;EAC9E,MAAMQ,YAAY,GAAGT,WAAW,CAACJ,UAAU,CAAC;EAC5C,MAAMc,aAAa,GAAGb,KAAK,CAACc,MAAM,CAAEC,IAAI,IAAKA,IAAI,KAAK,GAAG,IAAIH,YAAY,CAACG,IAAI,CAAC,CAAC;EAChF,MAAMC,SAAS,GAAGb,WAAW,CAACU,aAAa,CAAC;EAE5C,MAAMI,IAAI,GAAGlB,UAAU,CAACe,MAAM,CAAEC,IAAY,IAAK,CAACC,SAAS,CAACD,IAAI,CAAC,CAAC;EAClE,MAAMG,SAAS,GAAGL,aAAa,CAACM,OAAO,CAAC,GAAG,CAAC;EAC5C,IAAID,SAAS,KAAK,CAAC,CAAC,EAAE;IACpB,IAAID,IAAI,CAACR,MAAM,EAAE;MACf,MAAM,IAAIW,KAAK,yCAAAV,MAAA,CAAyCF,aAAa,CAACS,IAAI,CAAC,CAAE,CAAC;;IAEhF,OAAOJ,aAAa;;EAEtB,IAAIK,SAAS,KAAKL,aAAa,CAACQ,WAAW,CAAC,GAAG,CAAC,EAAE;IAChD,MAAM,IAAID,KAAK,CAAC,0DAA0D,CAAC;;EAG7E,MAAME,QAAQ,GAAG,CAAC,GAAGT,aAAa,CAAC;EACnCS,QAAQ,CAACC,MAAM,CAACL,SAAS,EAAE,CAAC,EAAE,GAAGD,IAAI,CAAC;EACtC,OAAOK,QAAQ;AACjB"},"metadata":{},"sourceType":"module","externalDependencies":[]}