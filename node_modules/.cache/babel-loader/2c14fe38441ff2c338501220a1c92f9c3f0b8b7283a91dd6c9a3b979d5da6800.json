{"ast":null,"code":"import union from 'lodash/union';\nimport { REQUIRED_KEY } from './constants';\nimport getSchemaType from './getSchemaType';\nimport isObject from './isObject';\n/** Recursively merge deeply nested schemas. The difference between `mergeSchemas` and `mergeObjects` is that\n * `mergeSchemas` only concats arrays for values under the 'required' keyword, and when it does, it doesn't include\n * duplicate values.\n *\n * @param obj1 - The first schema object to merge\n * @param obj2 - The second schema object to merge\n * @returns - The merged schema object\n */\nexport default function mergeSchemas(obj1, obj2) {\n  const acc = Object.assign({}, obj1); // Prevent mutation of source object.\n  return Object.keys(obj2).reduce((acc, key) => {\n    const left = obj1 ? obj1[key] : {},\n      right = obj2[key];\n    if (obj1 && key in obj1 && isObject(right)) {\n      acc[key] = mergeSchemas(left, right);\n    } else if (obj1 && obj2 && (getSchemaType(obj1) === 'object' || getSchemaType(obj2) === 'object') && key === REQUIRED_KEY && Array.isArray(left) && Array.isArray(right)) {\n      // Don't include duplicate values when merging 'required' fields.\n      acc[key] = union(left, right);\n    } else {\n      acc[key] = right;\n    }\n    return acc;\n  }, acc);\n}","map":{"version":3,"names":["union","REQUIRED_KEY","getSchemaType","isObject","mergeSchemas","obj1","obj2","acc","Object","assign","keys","reduce","key","left","right","Array","isArray"],"sources":["D:\\Reactjs\\my-app\\node_modules\\@rjsf\\utils\\src\\mergeSchemas.ts"],"sourcesContent":["import union from 'lodash/union';\n\nimport { REQUIRED_KEY } from './constants';\nimport getSchemaType from './getSchemaType';\nimport isObject from './isObject';\nimport { GenericObjectType } from './types';\n\n/** Recursively merge deeply nested schemas. The difference between `mergeSchemas` and `mergeObjects` is that\n * `mergeSchemas` only concats arrays for values under the 'required' keyword, and when it does, it doesn't include\n * duplicate values.\n *\n * @param obj1 - The first schema object to merge\n * @param obj2 - The second schema object to merge\n * @returns - The merged schema object\n */\nexport default function mergeSchemas(obj1: GenericObjectType, obj2: GenericObjectType) {\n  const acc = Object.assign({}, obj1); // Prevent mutation of source object.\n  return Object.keys(obj2).reduce((acc, key) => {\n    const left = obj1 ? obj1[key] : {},\n      right = obj2[key];\n    if (obj1 && key in obj1 && isObject(right)) {\n      acc[key] = mergeSchemas(left, right);\n    } else if (\n      obj1 &&\n      obj2 &&\n      (getSchemaType(obj1) === 'object' || getSchemaType(obj2) === 'object') &&\n      key === REQUIRED_KEY &&\n      Array.isArray(left) &&\n      Array.isArray(right)\n    ) {\n      // Don't include duplicate values when merging 'required' fields.\n      acc[key] = union(left, right);\n    } else {\n      acc[key] = right;\n    }\n    return acc;\n  }, acc);\n}\n"],"mappings":"AAAA,OAAOA,KAAK,MAAM,cAAc;AAEhC,SAASC,YAAY,QAAQ,aAAa;AAC1C,OAAOC,aAAa,MAAM,iBAAiB;AAC3C,OAAOC,QAAQ,MAAM,YAAY;AAGjC;;;;;;;;AAQA,eAAc,SAAUC,YAAYA,CAACC,IAAuB,EAAEC,IAAuB;EACnF,MAAMC,GAAG,GAAGC,MAAM,CAACC,MAAM,CAAC,EAAE,EAAEJ,IAAI,CAAC,CAAC,CAAC;EACrC,OAAOG,MAAM,CAACE,IAAI,CAACJ,IAAI,CAAC,CAACK,MAAM,CAAC,CAACJ,GAAG,EAAEK,GAAG,KAAI;IAC3C,MAAMC,IAAI,GAAGR,IAAI,GAAGA,IAAI,CAACO,GAAG,CAAC,GAAG,EAAE;MAChCE,KAAK,GAAGR,IAAI,CAACM,GAAG,CAAC;IACnB,IAAIP,IAAI,IAAIO,GAAG,IAAIP,IAAI,IAAIF,QAAQ,CAACW,KAAK,CAAC,EAAE;MAC1CP,GAAG,CAACK,GAAG,CAAC,GAAGR,YAAY,CAACS,IAAI,EAAEC,KAAK,CAAC;KACrC,MAAM,IACLT,IAAI,IACJC,IAAI,KACHJ,aAAa,CAACG,IAAI,CAAC,KAAK,QAAQ,IAAIH,aAAa,CAACI,IAAI,CAAC,KAAK,QAAQ,CAAC,IACtEM,GAAG,KAAKX,YAAY,IACpBc,KAAK,CAACC,OAAO,CAACH,IAAI,CAAC,IACnBE,KAAK,CAACC,OAAO,CAACF,KAAK,CAAC,EACpB;MACA;MACAP,GAAG,CAACK,GAAG,CAAC,GAAGZ,KAAK,CAACa,IAAI,EAAEC,KAAK,CAAC;KAC9B,MAAM;MACLP,GAAG,CAACK,GAAG,CAAC,GAAGE,KAAK;;IAElB,OAAOP,GAAG;EACZ,CAAC,EAAEA,GAAG,CAAC;AACT"},"metadata":{},"sourceType":"module","externalDependencies":[]}