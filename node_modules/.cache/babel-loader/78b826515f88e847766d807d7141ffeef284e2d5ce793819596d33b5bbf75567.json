{"ast":null,"code":"import get from 'lodash/get';\nimport isEqual from 'lodash/isEqual';\nimport set from 'lodash/set';\nimport { ALL_OF_KEY, ANY_OF_KEY, ADDITIONAL_PROPERTIES_KEY, DEPENDENCIES_KEY, ITEMS_KEY, NAME_KEY, ONE_OF_KEY, PROPERTIES_KEY, REF_KEY, RJSF_ADDITONAL_PROPERTIES_FLAG } from '../constants';\nimport getDiscriminatorFieldFromSchema from '../getDiscriminatorFieldFromSchema';\nimport getClosestMatchingOption from './getClosestMatchingOption';\nimport retrieveSchema from './retrieveSchema';\n/** An internal helper that generates an `PathSchema` object for the `schema`, recursively with protection against\n * infinite recursion\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param schema - The schema for which the `PathSchema` is desired\n * @param [name=''] - The base name for the schema\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\n * @param [formData] - The current formData, if any, to assist retrieving a schema\n * @param [_recurseList=[]] - The list of retrieved schemas currently being recursed, used to prevent infinite recursion\n * @returns - The `PathSchema` object for the `schema`\n */\nfunction toPathSchemaInternal(validator, schema, name, rootSchema, formData, _recurseList = []) {\n  if (REF_KEY in schema || DEPENDENCIES_KEY in schema || ALL_OF_KEY in schema) {\n    const _schema = retrieveSchema(validator, schema, rootSchema, formData);\n    const sameSchemaIndex = _recurseList.findIndex(item => isEqual(item, _schema));\n    if (sameSchemaIndex === -1) {\n      return toPathSchemaInternal(validator, _schema, name, rootSchema, formData, _recurseList.concat(_schema));\n    }\n  }\n  let pathSchema = {\n    [NAME_KEY]: name.replace(/^\\./, '')\n  };\n  if (ONE_OF_KEY in schema || ANY_OF_KEY in schema) {\n    const xxxOf = ONE_OF_KEY in schema ? schema.oneOf : schema.anyOf;\n    const discriminator = getDiscriminatorFieldFromSchema(schema);\n    const index = getClosestMatchingOption(validator, rootSchema, formData, xxxOf, 0, discriminator);\n    const _schema = xxxOf[index];\n    pathSchema = {\n      ...pathSchema,\n      ...toPathSchemaInternal(validator, _schema, name, rootSchema, formData, _recurseList)\n    };\n  }\n  if (ADDITIONAL_PROPERTIES_KEY in schema && schema[ADDITIONAL_PROPERTIES_KEY] !== false) {\n    set(pathSchema, RJSF_ADDITONAL_PROPERTIES_FLAG, true);\n  }\n  if (ITEMS_KEY in schema && Array.isArray(formData)) {\n    const {\n      items: schemaItems,\n      additionalItems: schemaAdditionalItems\n    } = schema;\n    if (Array.isArray(schemaItems)) {\n      formData.forEach((element, i) => {\n        if (schemaItems[i]) {\n          pathSchema[i] = toPathSchemaInternal(validator, schemaItems[i], `${name}.${i}`, rootSchema, element, _recurseList);\n        } else if (schemaAdditionalItems) {\n          pathSchema[i] = toPathSchemaInternal(validator, schemaAdditionalItems, `${name}.${i}`, rootSchema, element, _recurseList);\n        } else {\n          console.warn(`Unable to generate path schema for \"${name}.${i}\". No schema defined for it`);\n        }\n      });\n    } else {\n      formData.forEach((element, i) => {\n        pathSchema[i] = toPathSchemaInternal(validator, schemaItems, `${name}.${i}`, rootSchema, element, _recurseList);\n      });\n    }\n  } else if (PROPERTIES_KEY in schema) {\n    for (const property in schema.properties) {\n      const field = get(schema, [PROPERTIES_KEY, property]);\n      pathSchema[property] = toPathSchemaInternal(validator, field, `${name}.${property}`, rootSchema,\n      // It's possible that formData is not an object -- this can happen if an\n      // array item has just been added, but not populated with data yet\n      get(formData, [property]), _recurseList);\n    }\n  }\n  return pathSchema;\n}\n/** Generates an `PathSchema` object for the `schema`, recursively\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param schema - The schema for which the `PathSchema` is desired\n * @param [name=''] - The base name for the schema\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\n * @param [formData] - The current formData, if any, to assist retrieving a schema\n * @returns - The `PathSchema` object for the `schema`\n */\nexport default function toPathSchema(validator, schema, name = '', rootSchema, formData) {\n  return toPathSchemaInternal(validator, schema, name, rootSchema, formData);\n}","map":{"version":3,"names":["get","isEqual","set","ALL_OF_KEY","ANY_OF_KEY","ADDITIONAL_PROPERTIES_KEY","DEPENDENCIES_KEY","ITEMS_KEY","NAME_KEY","ONE_OF_KEY","PROPERTIES_KEY","REF_KEY","RJSF_ADDITONAL_PROPERTIES_FLAG","getDiscriminatorFieldFromSchema","getClosestMatchingOption","retrieveSchema","toPathSchemaInternal","validator","schema","name","rootSchema","formData","_recurseList","_schema","sameSchemaIndex","findIndex","item","concat","pathSchema","replace","xxxOf","oneOf","anyOf","discriminator","index","Array","isArray","items","schemaItems","additionalItems","schemaAdditionalItems","forEach","element","i","console","warn","property","properties","field","toPathSchema"],"sources":["D:\\Reactjs\\my-app\\node_modules\\@rjsf\\utils\\src\\schema\\toPathSchema.ts"],"sourcesContent":["import get from 'lodash/get';\nimport isEqual from 'lodash/isEqual';\nimport set from 'lodash/set';\n\nimport {\n  ALL_OF_KEY,\n  ANY_OF_KEY,\n  ADDITIONAL_PROPERTIES_KEY,\n  DEPENDENCIES_KEY,\n  ITEMS_KEY,\n  NAME_KEY,\n  ONE_OF_KEY,\n  PROPERTIES_KEY,\n  REF_KEY,\n  RJSF_ADDITONAL_PROPERTIES_FLAG,\n} from '../constants';\nimport getDiscriminatorFieldFromSchema from '../getDiscriminatorFieldFromSchema';\nimport { FormContextType, PathSchema, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\nimport getClosestMatchingOption from './getClosestMatchingOption';\nimport retrieveSchema from './retrieveSchema';\n\n/** An internal helper that generates an `PathSchema` object for the `schema`, recursively with protection against\n * infinite recursion\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param schema - The schema for which the `PathSchema` is desired\n * @param [name=''] - The base name for the schema\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\n * @param [formData] - The current formData, if any, to assist retrieving a schema\n * @param [_recurseList=[]] - The list of retrieved schemas currently being recursed, used to prevent infinite recursion\n * @returns - The `PathSchema` object for the `schema`\n */\nfunction toPathSchemaInternal<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  name: string,\n  rootSchema?: S,\n  formData?: T,\n  _recurseList: S[] = []\n): PathSchema<T> {\n  if (REF_KEY in schema || DEPENDENCIES_KEY in schema || ALL_OF_KEY in schema) {\n    const _schema = retrieveSchema<T, S, F>(validator, schema, rootSchema, formData);\n    const sameSchemaIndex = _recurseList.findIndex((item) => isEqual(item, _schema));\n    if (sameSchemaIndex === -1) {\n      return toPathSchemaInternal<T, S, F>(\n        validator,\n        _schema,\n        name,\n        rootSchema,\n        formData,\n        _recurseList.concat(_schema)\n      );\n    }\n  }\n\n  let pathSchema: PathSchema = {\n    [NAME_KEY]: name.replace(/^\\./, ''),\n  } as PathSchema;\n\n  if (ONE_OF_KEY in schema || ANY_OF_KEY in schema) {\n    const xxxOf: S[] = ONE_OF_KEY in schema ? (schema.oneOf as S[]) : (schema.anyOf as S[]);\n    const discriminator = getDiscriminatorFieldFromSchema<S>(schema);\n    const index = getClosestMatchingOption<T, S, F>(validator, rootSchema!, formData, xxxOf, 0, discriminator);\n    const _schema: S = xxxOf![index] as S;\n    pathSchema = {\n      ...pathSchema,\n      ...toPathSchemaInternal<T, S, F>(validator, _schema, name, rootSchema, formData, _recurseList),\n    };\n  }\n\n  if (ADDITIONAL_PROPERTIES_KEY in schema && schema[ADDITIONAL_PROPERTIES_KEY] !== false) {\n    set(pathSchema, RJSF_ADDITONAL_PROPERTIES_FLAG, true);\n  }\n\n  if (ITEMS_KEY in schema && Array.isArray(formData)) {\n    const { items: schemaItems, additionalItems: schemaAdditionalItems } = schema;\n\n    if (Array.isArray(schemaItems)) {\n      formData.forEach((element, i: number) => {\n        if (schemaItems[i]) {\n          pathSchema[i] = toPathSchemaInternal<T, S, F>(\n            validator,\n            schemaItems[i] as S,\n            `${name}.${i}`,\n            rootSchema,\n            element,\n            _recurseList\n          );\n        } else if (schemaAdditionalItems) {\n          pathSchema[i] = toPathSchemaInternal<T, S, F>(\n            validator,\n            schemaAdditionalItems as S,\n            `${name}.${i}`,\n            rootSchema,\n            element,\n            _recurseList\n          );\n        } else {\n          console.warn(`Unable to generate path schema for \"${name}.${i}\". No schema defined for it`);\n        }\n      });\n    } else {\n      formData.forEach((element, i: number) => {\n        pathSchema[i] = toPathSchemaInternal<T, S, F>(\n          validator,\n          schemaItems as S,\n          `${name}.${i}`,\n          rootSchema,\n          element,\n          _recurseList\n        );\n      });\n    }\n  } else if (PROPERTIES_KEY in schema) {\n    for (const property in schema.properties) {\n      const field = get(schema, [PROPERTIES_KEY, property]);\n      pathSchema[property] = toPathSchemaInternal<T, S, F>(\n        validator,\n        field,\n        `${name}.${property}`,\n        rootSchema,\n        // It's possible that formData is not an object -- this can happen if an\n        // array item has just been added, but not populated with data yet\n        get(formData, [property]),\n        _recurseList\n      );\n    }\n  }\n  return pathSchema as PathSchema<T>;\n}\n\n/** Generates an `PathSchema` object for the `schema`, recursively\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param schema - The schema for which the `PathSchema` is desired\n * @param [name=''] - The base name for the schema\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\n * @param [formData] - The current formData, if any, to assist retrieving a schema\n * @returns - The `PathSchema` object for the `schema`\n */\nexport default function toPathSchema<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  name = '',\n  rootSchema?: S,\n  formData?: T\n): PathSchema<T> {\n  return toPathSchemaInternal(validator, schema, name, rootSchema, formData);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}