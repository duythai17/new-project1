{"ast":null,"code":"import { ID_KEY, ROOT_SCHEMA_PREFIX, toErrorList, withIdRefPrefix, hashForSchema } from '@rjsf/utils';\nimport createAjvInstance from './createAjvInstance';\nimport processRawValidationErrors from './processRawValidationErrors';\n/** `ValidatorType` implementation that uses the AJV 8 validation mechanism.\n */\nexport default class AJV8Validator {\n  /** Constructs an `AJV8Validator` instance using the `options`\n   *\n   * @param options - The `CustomValidatorOptionsType` options that are used to create the AJV instance\n   * @param [localizer] - If provided, is used to localize a list of Ajv `ErrorObject`s\n   */\n  constructor(options, localizer) {\n    const {\n      additionalMetaSchemas,\n      customFormats,\n      ajvOptionsOverrides,\n      ajvFormatOptions,\n      AjvClass\n    } = options;\n    this.ajv = createAjvInstance(additionalMetaSchemas, customFormats, ajvOptionsOverrides, ajvFormatOptions, AjvClass);\n    this.localizer = localizer;\n  }\n  /** Converts an `errorSchema` into a list of `RJSFValidationErrors`\n   *\n   * @param errorSchema - The `ErrorSchema` instance to convert\n   * @param [fieldPath=[]] - The current field path, defaults to [] if not specified\n   * @deprecated - Use the `toErrorList()` function provided by `@rjsf/utils` instead. This function will be removed in\n   *        the next major release.\n   */\n  toErrorList(errorSchema, fieldPath = []) {\n    return toErrorList(errorSchema, fieldPath);\n  }\n  /** Runs the pure validation of the `schema` and `formData` without any of the RJSF functionality. Provided for use\n   * by the playground. Returns the `errors` from the validation\n   *\n   * @param schema - The schema against which to validate the form data   * @param schema\n   * @param formData - The form data to validate\n   */\n  rawValidation(schema, formData) {\n    let compilationError = undefined;\n    let compiledValidator;\n    if (schema[ID_KEY]) {\n      compiledValidator = this.ajv.getSchema(schema[ID_KEY]);\n    }\n    try {\n      if (compiledValidator === undefined) {\n        compiledValidator = this.ajv.compile(schema);\n      }\n      compiledValidator(formData);\n    } catch (err) {\n      compilationError = err;\n    }\n    let errors;\n    if (compiledValidator) {\n      if (typeof this.localizer === 'function') {\n        this.localizer(compiledValidator.errors);\n      }\n      errors = compiledValidator.errors || undefined;\n      // Clear errors to prevent persistent errors, see #1104\n      compiledValidator.errors = null;\n    }\n    return {\n      errors: errors,\n      validationError: compilationError\n    };\n  }\n  /** This function processes the `formData` with an optional user contributed `customValidate` function, which receives\n   * the form data and a `errorHandler` function that will be used to add custom validation errors for each field. Also\n   * supports a `transformErrors` function that will take the raw AJV validation errors, prior to custom validation and\n   * transform them in what ever way it chooses.\n   *\n   * @param formData - The form data to validate\n   * @param schema - The schema against which to validate the form data\n   * @param [customValidate] - An optional function that is used to perform custom validation\n   * @param [transformErrors] - An optional function that is used to transform errors after AJV validation\n   * @param [uiSchema] - An optional uiSchema that is passed to `transformErrors` and `customValidate`\n   */\n  validateFormData(formData, schema, customValidate, transformErrors, uiSchema) {\n    const rawErrors = this.rawValidation(schema, formData);\n    return processRawValidationErrors(this, rawErrors, formData, schema, customValidate, transformErrors, uiSchema);\n  }\n  /** Validates data against a schema, returning true if the data is valid, or\n   * false otherwise. If the schema is invalid, then this function will return\n   * false.\n   *\n   * @param schema - The schema against which to validate the form data\n   * @param formData - The form data to validate\n   * @param rootSchema - The root schema used to provide $ref resolutions\n   */\n  isValid(schema, formData, rootSchema) {\n    var _a, _b;\n    const rootSchemaId = (_a = rootSchema[ID_KEY]) !== null && _a !== void 0 ? _a : ROOT_SCHEMA_PREFIX;\n    try {\n      // add the rootSchema ROOT_SCHEMA_PREFIX as id.\n      // then rewrite the schema ref's to point to the rootSchema\n      // this accounts for the case where schema have references to models\n      // that lives in the rootSchema but not in the schema in question.\n      // if (this.ajv.getSchema(rootSchemaId) === undefined) {\n      // TODO restore the commented out `if` above when the TODO in the `finally` is completed\n      this.ajv.addSchema(rootSchema, rootSchemaId);\n      // }\n      const schemaWithIdRefPrefix = withIdRefPrefix(schema);\n      const schemaId = (_b = schemaWithIdRefPrefix[ID_KEY]) !== null && _b !== void 0 ? _b : hashForSchema(schemaWithIdRefPrefix);\n      let compiledValidator;\n      compiledValidator = this.ajv.getSchema(schemaId);\n      if (compiledValidator === undefined) {\n        // Add schema by an explicit ID so it can be fetched later\n        // Fall back to using compile if necessary\n        // https://ajv.js.org/guide/managing-schemas.html#pre-adding-all-schemas-vs-adding-on-demand\n        compiledValidator = this.ajv.addSchema(schemaWithIdRefPrefix, schemaId).getSchema(schemaId) || this.ajv.compile(schemaWithIdRefPrefix);\n      }\n      const result = compiledValidator(formData);\n      return result;\n    } catch (e) {\n      console.warn('Error encountered compiling schema:', e);\n      return false;\n    } finally {\n      // TODO: A function should be called if the root schema changes so we don't have to remove and recompile the schema every run.\n      // make sure we remove the rootSchema from the global ajv instance\n      this.ajv.removeSchema(rootSchemaId);\n    }\n  }\n}","map":{"version":3,"names":["ID_KEY","ROOT_SCHEMA_PREFIX","toErrorList","withIdRefPrefix","hashForSchema","createAjvInstance","processRawValidationErrors","AJV8Validator","constructor","options","localizer","additionalMetaSchemas","customFormats","ajvOptionsOverrides","ajvFormatOptions","AjvClass","ajv","errorSchema","fieldPath","rawValidation","schema","formData","compilationError","undefined","compiledValidator","getSchema","compile","err","errors","validationError","validateFormData","customValidate","transformErrors","uiSchema","rawErrors","isValid","rootSchema","rootSchemaId","_a","addSchema","schemaWithIdRefPrefix","schemaId","_b","result","e","console","warn","removeSchema"],"sources":["D:\\Reactjs\\my-app\\node_modules\\@rjsf\\validator-ajv8\\src\\validator.ts"],"sourcesContent":["import Ajv, { ErrorObject, ValidateFunction } from 'ajv';\nimport {\n  CustomValidator,\n  ErrorSchema,\n  ErrorTransformer,\n  FormContextType,\n  ID_KEY,\n  RJSFSchema,\n  ROOT_SCHEMA_PREFIX,\n  StrictRJSFSchema,\n  toErrorList,\n  UiSchema,\n  ValidationData,\n  ValidatorType,\n  withIdRefPrefix,\n  hashForSchema,\n} from '@rjsf/utils';\n\nimport { CustomValidatorOptionsType, Localizer } from './types';\nimport createAjvInstance from './createAjvInstance';\nimport processRawValidationErrors, { RawValidationErrorsType } from './processRawValidationErrors';\n\n/** `ValidatorType` implementation that uses the AJV 8 validation mechanism.\n */\nexport default class AJV8Validator<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>\n  implements ValidatorType<T, S, F>\n{\n  /** The AJV instance to use for all validations\n   *\n   * @private\n   */\n  ajv: Ajv;\n\n  /** The Localizer function to use for localizing Ajv errors\n   *\n   * @private\n   */\n  readonly localizer?: Localizer;\n\n  /** Constructs an `AJV8Validator` instance using the `options`\n   *\n   * @param options - The `CustomValidatorOptionsType` options that are used to create the AJV instance\n   * @param [localizer] - If provided, is used to localize a list of Ajv `ErrorObject`s\n   */\n  constructor(options: CustomValidatorOptionsType, localizer?: Localizer) {\n    const { additionalMetaSchemas, customFormats, ajvOptionsOverrides, ajvFormatOptions, AjvClass } = options;\n    this.ajv = createAjvInstance(additionalMetaSchemas, customFormats, ajvOptionsOverrides, ajvFormatOptions, AjvClass);\n    this.localizer = localizer;\n  }\n\n  /** Converts an `errorSchema` into a list of `RJSFValidationErrors`\n   *\n   * @param errorSchema - The `ErrorSchema` instance to convert\n   * @param [fieldPath=[]] - The current field path, defaults to [] if not specified\n   * @deprecated - Use the `toErrorList()` function provided by `@rjsf/utils` instead. This function will be removed in\n   *        the next major release.\n   */\n  toErrorList(errorSchema?: ErrorSchema<T>, fieldPath: string[] = []) {\n    return toErrorList(errorSchema, fieldPath);\n  }\n\n  /** Runs the pure validation of the `schema` and `formData` without any of the RJSF functionality. Provided for use\n   * by the playground. Returns the `errors` from the validation\n   *\n   * @param schema - The schema against which to validate the form data   * @param schema\n   * @param formData - The form data to validate\n   */\n  rawValidation<Result = any>(schema: S, formData?: T): RawValidationErrorsType<Result> {\n    let compilationError: Error | undefined = undefined;\n    let compiledValidator: ValidateFunction | undefined;\n    if (schema[ID_KEY]) {\n      compiledValidator = this.ajv.getSchema(schema[ID_KEY]);\n    }\n    try {\n      if (compiledValidator === undefined) {\n        compiledValidator = this.ajv.compile(schema);\n      }\n      compiledValidator(formData);\n    } catch (err) {\n      compilationError = err as Error;\n    }\n\n    let errors;\n    if (compiledValidator) {\n      if (typeof this.localizer === 'function') {\n        this.localizer(compiledValidator.errors);\n      }\n      errors = compiledValidator.errors || undefined;\n\n      // Clear errors to prevent persistent errors, see #1104\n      compiledValidator.errors = null;\n    }\n\n    return {\n      errors: errors as unknown as Result[],\n      validationError: compilationError,\n    };\n  }\n\n  /** This function processes the `formData` with an optional user contributed `customValidate` function, which receives\n   * the form data and a `errorHandler` function that will be used to add custom validation errors for each field. Also\n   * supports a `transformErrors` function that will take the raw AJV validation errors, prior to custom validation and\n   * transform them in what ever way it chooses.\n   *\n   * @param formData - The form data to validate\n   * @param schema - The schema against which to validate the form data\n   * @param [customValidate] - An optional function that is used to perform custom validation\n   * @param [transformErrors] - An optional function that is used to transform errors after AJV validation\n   * @param [uiSchema] - An optional uiSchema that is passed to `transformErrors` and `customValidate`\n   */\n  validateFormData(\n    formData: T | undefined,\n    schema: S,\n    customValidate?: CustomValidator<T, S, F>,\n    transformErrors?: ErrorTransformer<T, S, F>,\n    uiSchema?: UiSchema<T, S, F>\n  ): ValidationData<T> {\n    const rawErrors = this.rawValidation<ErrorObject>(schema, formData);\n    return processRawValidationErrors(this, rawErrors, formData, schema, customValidate, transformErrors, uiSchema);\n  }\n\n  /** Validates data against a schema, returning true if the data is valid, or\n   * false otherwise. If the schema is invalid, then this function will return\n   * false.\n   *\n   * @param schema - The schema against which to validate the form data\n   * @param formData - The form data to validate\n   * @param rootSchema - The root schema used to provide $ref resolutions\n   */\n  isValid(schema: S, formData: T | undefined, rootSchema: S) {\n    const rootSchemaId = rootSchema[ID_KEY] ?? ROOT_SCHEMA_PREFIX;\n    try {\n      // add the rootSchema ROOT_SCHEMA_PREFIX as id.\n      // then rewrite the schema ref's to point to the rootSchema\n      // this accounts for the case where schema have references to models\n      // that lives in the rootSchema but not in the schema in question.\n      // if (this.ajv.getSchema(rootSchemaId) === undefined) {\n      // TODO restore the commented out `if` above when the TODO in the `finally` is completed\n      this.ajv.addSchema(rootSchema, rootSchemaId);\n      // }\n      const schemaWithIdRefPrefix = withIdRefPrefix<S>(schema) as S;\n      const schemaId = schemaWithIdRefPrefix[ID_KEY] ?? hashForSchema(schemaWithIdRefPrefix);\n      let compiledValidator: ValidateFunction | undefined;\n      compiledValidator = this.ajv.getSchema(schemaId);\n      if (compiledValidator === undefined) {\n        // Add schema by an explicit ID so it can be fetched later\n        // Fall back to using compile if necessary\n        // https://ajv.js.org/guide/managing-schemas.html#pre-adding-all-schemas-vs-adding-on-demand\n        compiledValidator =\n          this.ajv.addSchema(schemaWithIdRefPrefix, schemaId).getSchema(schemaId) ||\n          this.ajv.compile(schemaWithIdRefPrefix);\n      }\n      const result = compiledValidator(formData);\n      return result as boolean;\n    } catch (e) {\n      console.warn('Error encountered compiling schema:', e);\n      return false;\n    } finally {\n      // TODO: A function should be called if the root schema changes so we don't have to remove and recompile the schema every run.\n      // make sure we remove the rootSchema from the global ajv instance\n      this.ajv.removeSchema(rootSchemaId);\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}