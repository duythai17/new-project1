{"ast":null,"code":"import get from 'lodash/get';\nimport isEmpty from 'lodash/isEmpty';\nimport { ANY_OF_KEY, DEFAULT_KEY, DEPENDENCIES_KEY, PROPERTIES_KEY, ONE_OF_KEY, REF_KEY, ALL_OF_KEY } from '../constants';\nimport findSchemaDefinition from '../findSchemaDefinition';\nimport getClosestMatchingOption from './getClosestMatchingOption';\nimport getDiscriminatorFieldFromSchema from '../getDiscriminatorFieldFromSchema';\nimport getSchemaType from '../getSchemaType';\nimport isObject from '../isObject';\nimport isFixedItems from '../isFixedItems';\nimport mergeDefaultsWithFormData from '../mergeDefaultsWithFormData';\nimport mergeObjects from '../mergeObjects';\nimport mergeSchemas from '../mergeSchemas';\nimport isMultiSelect from './isMultiSelect';\nimport retrieveSchema, { resolveDependencies } from './retrieveSchema';\n/** Enum that indicates how `schema.additionalItems` should be handled by the `getInnerSchemaForArrayItem()` function.\n */\nexport var AdditionalItemsHandling;\n(function (AdditionalItemsHandling) {\n  AdditionalItemsHandling[AdditionalItemsHandling[\"Ignore\"] = 0] = \"Ignore\";\n  AdditionalItemsHandling[AdditionalItemsHandling[\"Invert\"] = 1] = \"Invert\";\n  AdditionalItemsHandling[AdditionalItemsHandling[\"Fallback\"] = 2] = \"Fallback\";\n})(AdditionalItemsHandling || (AdditionalItemsHandling = {}));\n/** Given a `schema` will return an inner schema that for an array item. This is computed differently based on the\n * `additionalItems` enum and the value of `idx`. There are four possible returns:\n * 1. If `idx` is >= 0, then if `schema.items` is an array the `idx`th element of the array is returned if it is a valid\n *    index and not a boolean, otherwise it falls through to 3.\n * 2. If `schema.items` is not an array AND truthy and not a boolean, then `schema.items` is returned since it actually\n *    is a schema, otherwise it falls through to 3.\n * 3. If `additionalItems` is not `AdditionalItemsHandling.Ignore` and `schema.additionalItems` is an object, then\n *    `schema.additionalItems` is returned since it actually is a schema, otherwise it falls through to 4.\n * 4. {} is returned representing an empty schema\n *\n * @param schema - The schema from which to get the particular item\n * @param [additionalItems=AdditionalItemsHandling.Ignore] - How do we want to handle additional items?\n * @param [idx=-1] - Index, if non-negative, will be used to return the idx-th element in a `schema.items` array\n * @returns - The best fit schema object from the `schema` given the `additionalItems` and `idx` modifiers\n */\nexport function getInnerSchemaForArrayItem(schema, additionalItems = AdditionalItemsHandling.Ignore, idx = -1) {\n  if (idx >= 0) {\n    if (Array.isArray(schema.items) && idx < schema.items.length) {\n      const item = schema.items[idx];\n      if (typeof item !== 'boolean') {\n        return item;\n      }\n    }\n  } else if (schema.items && !Array.isArray(schema.items) && typeof schema.items !== 'boolean') {\n    return schema.items;\n  }\n  if (additionalItems !== AdditionalItemsHandling.Ignore && isObject(schema.additionalItems)) {\n    return schema.additionalItems;\n  }\n  return {};\n}\n/** Either add `computedDefault` at `key` into `obj` or not add it based on its value, the value of\n * `includeUndefinedValues`, the value of `emptyObjectFields` and if its parent field is required. Generally undefined\n * `computedDefault` values are added only when `includeUndefinedValues` is either true/\"excludeObjectChildren\". If `\n * includeUndefinedValues` is false and `emptyObjectFields` is not \"skipDefaults\", then non-undefined and non-empty-object\n * values will be added based on certain conditions.\n *\n * @param obj - The object into which the computed default may be added\n * @param key - The key into the object at which the computed default may be added\n * @param computedDefault - The computed default value that maybe should be added to the obj\n * @param includeUndefinedValues - Optional flag, if true, cause undefined values to be added as defaults.\n *          If \"excludeObjectChildren\", cause undefined values for this object and pass `includeUndefinedValues` as\n *          false when computing defaults for any nested object properties. If \"allowEmptyObject\", prevents undefined\n *          values in this object while allow the object itself to be empty and passing `includeUndefinedValues` as\n *          false when computing defaults for any nested object properties.\n * @param isParentRequired - The optional boolean that indicates whether the parent field is required\n * @param requiredFields - The list of fields that are required\n * @param experimental_defaultFormStateBehavior - Optional configuration object, if provided, allows users to override\n *        default form state behavior\n */\nfunction maybeAddDefaultToObject(obj, key, computedDefault, includeUndefinedValues, isParentRequired, requiredFields = [], experimental_defaultFormStateBehavior = {}) {\n  const {\n    emptyObjectFields = 'populateAllDefaults'\n  } = experimental_defaultFormStateBehavior;\n  if (includeUndefinedValues) {\n    obj[key] = computedDefault;\n  } else if (emptyObjectFields !== 'skipDefaults') {\n    if (isObject(computedDefault)) {\n      // If isParentRequired is undefined, then we are at the root level of the schema so defer to the requiredness of\n      // the field key itself in the `requiredField` list\n      const isSelfOrParentRequired = isParentRequired === undefined ? requiredFields.includes(key) : isParentRequired;\n      // Store computedDefault if it's a non-empty object(e.g. not {}) and satisfies certain conditions\n      // Condition 1: If computedDefault is not empty or if the key is a required field\n      // Condition 2: If the parent object is required or emptyObjectFields is not 'populateRequiredDefaults'\n      if ((!isEmpty(computedDefault) || requiredFields.includes(key)) && (isSelfOrParentRequired || emptyObjectFields !== 'populateRequiredDefaults')) {\n        obj[key] = computedDefault;\n      }\n    } else if (\n    // Store computedDefault if it's a defined primitive (e.g., true) and satisfies certain conditions\n    // Condition 1: computedDefault is not undefined\n    // Condition 2: If emptyObjectFields is 'populateAllDefaults' or if the key is a required field\n    computedDefault !== undefined && (emptyObjectFields === 'populateAllDefaults' || requiredFields.includes(key))) {\n      obj[key] = computedDefault;\n    }\n  }\n}\n/** Computes the defaults for the current `schema` given the `rawFormData` and `parentDefaults` if any. This drills into\n * each level of the schema, recursively, to fill out every level of defaults provided by the schema.\n *\n * @param validator - an implementation of the `ValidatorType` interface that will be used when necessary\n * @param rawSchema - The schema for which the default state is desired\n * @param [props] - Optional props for this function\n * @param [props.parentDefaults] - Any defaults provided by the parent field in the schema\n * @param [props.rootSchema] - The options root schema, used to primarily to look up `$ref`s\n * @param [props.rawFormData] - The current formData, if any, onto which to provide any missing defaults\n * @param [props.includeUndefinedValues=false] - Optional flag, if true, cause undefined values to be added as defaults.\n *          If \"excludeObjectChildren\", cause undefined values for this object and pass `includeUndefinedValues` as\n *          false when computing defaults for any nested object properties.\n * @param [props._recurseList=[]] - The list of ref names currently being recursed, used to prevent infinite recursion\n * @param [props.experimental_defaultFormStateBehavior] Optional configuration object, if provided, allows users to override default form state behavior\n * @param [props.required] - Optional flag, if true, indicates this schema was required in the parent schema.\n * @returns - The resulting `formData` with all the defaults provided\n */\nexport function computeDefaults(validator, rawSchema, {\n  parentDefaults,\n  rawFormData,\n  rootSchema = {},\n  includeUndefinedValues = false,\n  _recurseList = [],\n  experimental_defaultFormStateBehavior = undefined,\n  required\n} = {}) {\n  var _a, _b;\n  const formData = isObject(rawFormData) ? rawFormData : {};\n  const schema = isObject(rawSchema) ? rawSchema : {};\n  // Compute the defaults recursively: give highest priority to deepest nodes.\n  let defaults = parentDefaults;\n  // If we get a new schema, then we need to recompute defaults again for the new schema found.\n  let schemaToCompute = null;\n  let updatedRecurseList = _recurseList;\n  if (isObject(defaults) && isObject(schema.default)) {\n    // For object defaults, only override parent defaults that are defined in\n    // schema.default.\n    defaults = mergeObjects(defaults, schema.default);\n  } else if (DEFAULT_KEY in schema) {\n    defaults = schema.default;\n  } else if (REF_KEY in schema) {\n    const refName = schema[REF_KEY];\n    // Use referenced schema defaults for this node.\n    if (!_recurseList.includes(refName)) {\n      updatedRecurseList = _recurseList.concat(refName);\n      schemaToCompute = findSchemaDefinition(refName, rootSchema);\n    }\n  } else if (DEPENDENCIES_KEY in schema) {\n    const resolvedSchema = resolveDependencies(validator, schema, rootSchema, false, [], formData);\n    schemaToCompute = resolvedSchema[0]; // pick the first element from resolve dependencies\n  } else if (isFixedItems(schema)) {\n    defaults = schema.items.map((itemSchema, idx) => computeDefaults(validator, itemSchema, {\n      rootSchema,\n      includeUndefinedValues,\n      _recurseList,\n      experimental_defaultFormStateBehavior,\n      parentDefaults: Array.isArray(parentDefaults) ? parentDefaults[idx] : undefined,\n      rawFormData: formData,\n      required\n    }));\n  } else if (ONE_OF_KEY in schema) {\n    const {\n      oneOf,\n      ...remaining\n    } = schema;\n    if (oneOf.length === 0) {\n      return undefined;\n    }\n    const discriminator = getDiscriminatorFieldFromSchema(schema);\n    schemaToCompute = oneOf[getClosestMatchingOption(validator, rootSchema, isEmpty(formData) ? undefined : formData, oneOf, 0, discriminator)];\n    schemaToCompute = mergeSchemas(remaining, schemaToCompute);\n  } else if (ANY_OF_KEY in schema) {\n    const {\n      anyOf,\n      ...remaining\n    } = schema;\n    if (anyOf.length === 0) {\n      return undefined;\n    }\n    const discriminator = getDiscriminatorFieldFromSchema(schema);\n    schemaToCompute = anyOf[getClosestMatchingOption(validator, rootSchema, isEmpty(formData) ? undefined : formData, anyOf, 0, discriminator)];\n    schemaToCompute = mergeSchemas(remaining, schemaToCompute);\n  }\n  if (schemaToCompute) {\n    return computeDefaults(validator, schemaToCompute, {\n      rootSchema,\n      includeUndefinedValues,\n      _recurseList: updatedRecurseList,\n      experimental_defaultFormStateBehavior,\n      parentDefaults: defaults,\n      rawFormData: formData,\n      required\n    });\n  }\n  // No defaults defined for this node, fallback to generic typed ones.\n  if (defaults === undefined) {\n    defaults = schema.default;\n  }\n  switch (getSchemaType(schema)) {\n    // We need to recurse for object schema inner default values.\n    case 'object':\n      {\n        // This is a custom addition that fixes this issue:\n        // https://github.com/rjsf-team/react-jsonschema-form/issues/3832\n        const retrievedSchema = (experimental_defaultFormStateBehavior === null || experimental_defaultFormStateBehavior === void 0 ? void 0 : experimental_defaultFormStateBehavior.allOf) === 'populateDefaults' && ALL_OF_KEY in schema ? retrieveSchema(validator, schema, rootSchema, formData) : schema;\n        const objectDefaults = Object.keys(retrievedSchema.properties || {}).reduce((acc, key) => {\n          var _a;\n          // Compute the defaults for this node, with the parent defaults we might\n          // have from a previous run: defaults[key].\n          const computedDefault = computeDefaults(validator, get(retrievedSchema, [PROPERTIES_KEY, key]), {\n            rootSchema,\n            _recurseList,\n            experimental_defaultFormStateBehavior,\n            includeUndefinedValues: includeUndefinedValues === true,\n            parentDefaults: get(defaults, [key]),\n            rawFormData: get(formData, [key]),\n            required: (_a = retrievedSchema.required) === null || _a === void 0 ? void 0 : _a.includes(key)\n          });\n          maybeAddDefaultToObject(acc, key, computedDefault, includeUndefinedValues, required, retrievedSchema.required, experimental_defaultFormStateBehavior);\n          return acc;\n        }, {});\n        if (retrievedSchema.additionalProperties) {\n          // as per spec additionalProperties may be either schema or boolean\n          const additionalPropertiesSchema = isObject(retrievedSchema.additionalProperties) ? retrievedSchema.additionalProperties : {};\n          const keys = new Set();\n          if (isObject(defaults)) {\n            Object.keys(defaults).filter(key => !retrievedSchema.properties || !retrievedSchema.properties[key]).forEach(key => keys.add(key));\n          }\n          const formDataRequired = [];\n          Object.keys(formData).filter(key => !retrievedSchema.properties || !retrievedSchema.properties[key]).forEach(key => {\n            keys.add(key);\n            formDataRequired.push(key);\n          });\n          keys.forEach(key => {\n            var _a;\n            const computedDefault = computeDefaults(validator, additionalPropertiesSchema, {\n              rootSchema,\n              _recurseList,\n              experimental_defaultFormStateBehavior,\n              includeUndefinedValues: includeUndefinedValues === true,\n              parentDefaults: get(defaults, [key]),\n              rawFormData: get(formData, [key]),\n              required: (_a = retrievedSchema.required) === null || _a === void 0 ? void 0 : _a.includes(key)\n            });\n            // Since these are additional properties we don't need to add the `experimental_defaultFormStateBehavior` prop\n            maybeAddDefaultToObject(objectDefaults, key, computedDefault, includeUndefinedValues, required, formDataRequired);\n          });\n        }\n        return objectDefaults;\n      }\n    case 'array':\n      {\n        const neverPopulate = ((_a = experimental_defaultFormStateBehavior === null || experimental_defaultFormStateBehavior === void 0 ? void 0 : experimental_defaultFormStateBehavior.arrayMinItems) === null || _a === void 0 ? void 0 : _a.populate) === 'never';\n        const ignoreMinItemsFlagSet = ((_b = experimental_defaultFormStateBehavior === null || experimental_defaultFormStateBehavior === void 0 ? void 0 : experimental_defaultFormStateBehavior.arrayMinItems) === null || _b === void 0 ? void 0 : _b.populate) === 'requiredOnly';\n        // Inject defaults into existing array defaults\n        if (Array.isArray(defaults)) {\n          defaults = defaults.map((item, idx) => {\n            const schemaItem = getInnerSchemaForArrayItem(schema, AdditionalItemsHandling.Fallback, idx);\n            return computeDefaults(validator, schemaItem, {\n              rootSchema,\n              _recurseList,\n              experimental_defaultFormStateBehavior,\n              parentDefaults: item,\n              required\n            });\n          });\n        }\n        // Deeply inject defaults into already existing form data\n        if (Array.isArray(rawFormData)) {\n          const schemaItem = getInnerSchemaForArrayItem(schema);\n          if (neverPopulate) {\n            defaults = rawFormData;\n          } else {\n            defaults = rawFormData.map((item, idx) => {\n              return computeDefaults(validator, schemaItem, {\n                rootSchema,\n                _recurseList,\n                experimental_defaultFormStateBehavior,\n                rawFormData: item,\n                parentDefaults: get(defaults, [idx]),\n                required\n              });\n            });\n          }\n        }\n        if (neverPopulate) {\n          return defaults !== null && defaults !== void 0 ? defaults : [];\n        }\n        if (ignoreMinItemsFlagSet && !required) {\n          // If no form data exists or defaults are set leave the field empty/non-existent, otherwise\n          // return form data/defaults\n          return defaults ? defaults : undefined;\n        }\n        const defaultsLength = Array.isArray(defaults) ? defaults.length : 0;\n        if (!schema.minItems || isMultiSelect(validator, schema, rootSchema) || schema.minItems <= defaultsLength) {\n          return defaults ? defaults : [];\n        }\n        const defaultEntries = defaults || [];\n        const fillerSchema = getInnerSchemaForArrayItem(schema, AdditionalItemsHandling.Invert);\n        const fillerDefault = fillerSchema.default;\n        // Calculate filler entries for remaining items (minItems - existing raw data/defaults)\n        const fillerEntries = new Array(schema.minItems - defaultsLength).fill(computeDefaults(validator, fillerSchema, {\n          parentDefaults: fillerDefault,\n          rootSchema,\n          _recurseList,\n          experimental_defaultFormStateBehavior,\n          required\n        }));\n        // then fill up the rest with either the item default or empty, up to minItems\n        return defaultEntries.concat(fillerEntries);\n      }\n  }\n  return defaults;\n}\n/** Returns the superset of `formData` that includes the given set updated to include any missing fields that have\n * computed to have defaults provided in the `schema`.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param theSchema - The schema for which the default state is desired\n * @param [formData] - The current formData, if any, onto which to provide any missing defaults\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\n * @param [includeUndefinedValues=false] - Optional flag, if true, cause undefined values to be added as defaults.\n *          If \"excludeObjectChildren\", cause undefined values for this object and pass `includeUndefinedValues` as\n *          false when computing defaults for any nested object properties.\n * @param [experimental_defaultFormStateBehavior] Optional configuration object, if provided, allows users to override default form state behavior\n * @returns - The resulting `formData` with all the defaults provided\n */\nexport default function getDefaultFormState(validator, theSchema, formData, rootSchema, includeUndefinedValues = false, experimental_defaultFormStateBehavior) {\n  if (!isObject(theSchema)) {\n    throw new Error('Invalid schema: ' + theSchema);\n  }\n  const schema = retrieveSchema(validator, theSchema, rootSchema, formData);\n  const defaults = computeDefaults(validator, schema, {\n    rootSchema,\n    includeUndefinedValues,\n    experimental_defaultFormStateBehavior,\n    rawFormData: formData\n  });\n  if (formData === undefined || formData === null || typeof formData === 'number' && isNaN(formData)) {\n    // No form data? Use schema defaults.\n    return defaults;\n  }\n  const {\n    mergeExtraDefaults\n  } = (experimental_defaultFormStateBehavior === null || experimental_defaultFormStateBehavior === void 0 ? void 0 : experimental_defaultFormStateBehavior.arrayMinItems) || {};\n  if (isObject(formData)) {\n    return mergeDefaultsWithFormData(defaults, formData, mergeExtraDefaults);\n  }\n  if (Array.isArray(formData)) {\n    return mergeDefaultsWithFormData(defaults, formData, mergeExtraDefaults);\n  }\n  return formData;\n}","map":{"version":3,"names":["get","isEmpty","ANY_OF_KEY","DEFAULT_KEY","DEPENDENCIES_KEY","PROPERTIES_KEY","ONE_OF_KEY","REF_KEY","ALL_OF_KEY","findSchemaDefinition","getClosestMatchingOption","getDiscriminatorFieldFromSchema","getSchemaType","isObject","isFixedItems","mergeDefaultsWithFormData","mergeObjects","mergeSchemas","isMultiSelect","retrieveSchema","resolveDependencies","AdditionalItemsHandling","getInnerSchemaForArrayItem","schema","additionalItems","Ignore","idx","Array","isArray","items","length","item","maybeAddDefaultToObject","obj","key","computedDefault","includeUndefinedValues","isParentRequired","requiredFields","experimental_defaultFormStateBehavior","emptyObjectFields","isSelfOrParentRequired","undefined","includes","computeDefaults","validator","rawSchema","parentDefaults","rawFormData","rootSchema","_recurseList","required","formData","defaults","schemaToCompute","updatedRecurseList","default","refName","concat","resolvedSchema","map","itemSchema","oneOf","remaining","discriminator","anyOf","retrievedSchema","allOf","objectDefaults","Object","keys","properties","reduce","acc","_a","additionalProperties","additionalPropertiesSchema","Set","filter","forEach","add","formDataRequired","push","neverPopulate","arrayMinItems","populate","ignoreMinItemsFlagSet","_b","schemaItem","Fallback","defaultsLength","minItems","defaultEntries","fillerSchema","Invert","fillerDefault","fillerEntries","fill","getDefaultFormState","theSchema","Error","isNaN","mergeExtraDefaults"],"sources":["D:\\Reactjs\\my-app\\node_modules\\@rjsf\\utils\\src\\schema\\getDefaultFormState.ts"],"sourcesContent":["import get from 'lodash/get';\nimport isEmpty from 'lodash/isEmpty';\n\nimport {\n  ANY_OF_KEY,\n  DEFAULT_KEY,\n  DEPENDENCIES_KEY,\n  PROPERTIES_KEY,\n  ONE_OF_KEY,\n  REF_KEY,\n  ALL_OF_KEY,\n} from '../constants';\nimport findSchemaDefinition from '../findSchemaDefinition';\nimport getClosestMatchingOption from './getClosestMatchingOption';\nimport getDiscriminatorFieldFromSchema from '../getDiscriminatorFieldFromSchema';\nimport getSchemaType from '../getSchemaType';\nimport isObject from '../isObject';\nimport isFixedItems from '../isFixedItems';\nimport mergeDefaultsWithFormData from '../mergeDefaultsWithFormData';\nimport mergeObjects from '../mergeObjects';\nimport mergeSchemas from '../mergeSchemas';\nimport {\n  Experimental_DefaultFormStateBehavior,\n  FormContextType,\n  GenericObjectType,\n  RJSFSchema,\n  StrictRJSFSchema,\n  ValidatorType,\n} from '../types';\nimport isMultiSelect from './isMultiSelect';\nimport retrieveSchema, { resolveDependencies } from './retrieveSchema';\n\n/** Enum that indicates how `schema.additionalItems` should be handled by the `getInnerSchemaForArrayItem()` function.\n */\nexport enum AdditionalItemsHandling {\n  Ignore,\n  Invert,\n  Fallback,\n}\n\n/** Given a `schema` will return an inner schema that for an array item. This is computed differently based on the\n * `additionalItems` enum and the value of `idx`. There are four possible returns:\n * 1. If `idx` is >= 0, then if `schema.items` is an array the `idx`th element of the array is returned if it is a valid\n *    index and not a boolean, otherwise it falls through to 3.\n * 2. If `schema.items` is not an array AND truthy and not a boolean, then `schema.items` is returned since it actually\n *    is a schema, otherwise it falls through to 3.\n * 3. If `additionalItems` is not `AdditionalItemsHandling.Ignore` and `schema.additionalItems` is an object, then\n *    `schema.additionalItems` is returned since it actually is a schema, otherwise it falls through to 4.\n * 4. {} is returned representing an empty schema\n *\n * @param schema - The schema from which to get the particular item\n * @param [additionalItems=AdditionalItemsHandling.Ignore] - How do we want to handle additional items?\n * @param [idx=-1] - Index, if non-negative, will be used to return the idx-th element in a `schema.items` array\n * @returns - The best fit schema object from the `schema` given the `additionalItems` and `idx` modifiers\n */\nexport function getInnerSchemaForArrayItem<S extends StrictRJSFSchema = RJSFSchema>(\n  schema: S,\n  additionalItems: AdditionalItemsHandling = AdditionalItemsHandling.Ignore,\n  idx = -1\n): S {\n  if (idx >= 0) {\n    if (Array.isArray(schema.items) && idx < schema.items.length) {\n      const item = schema.items[idx];\n      if (typeof item !== 'boolean') {\n        return item as S;\n      }\n    }\n  } else if (schema.items && !Array.isArray(schema.items) && typeof schema.items !== 'boolean') {\n    return schema.items as S;\n  }\n  if (additionalItems !== AdditionalItemsHandling.Ignore && isObject(schema.additionalItems)) {\n    return schema.additionalItems as S;\n  }\n  return {} as S;\n}\n\n/** Either add `computedDefault` at `key` into `obj` or not add it based on its value, the value of\n * `includeUndefinedValues`, the value of `emptyObjectFields` and if its parent field is required. Generally undefined\n * `computedDefault` values are added only when `includeUndefinedValues` is either true/\"excludeObjectChildren\". If `\n * includeUndefinedValues` is false and `emptyObjectFields` is not \"skipDefaults\", then non-undefined and non-empty-object\n * values will be added based on certain conditions.\n *\n * @param obj - The object into which the computed default may be added\n * @param key - The key into the object at which the computed default may be added\n * @param computedDefault - The computed default value that maybe should be added to the obj\n * @param includeUndefinedValues - Optional flag, if true, cause undefined values to be added as defaults.\n *          If \"excludeObjectChildren\", cause undefined values for this object and pass `includeUndefinedValues` as\n *          false when computing defaults for any nested object properties. If \"allowEmptyObject\", prevents undefined\n *          values in this object while allow the object itself to be empty and passing `includeUndefinedValues` as\n *          false when computing defaults for any nested object properties.\n * @param isParentRequired - The optional boolean that indicates whether the parent field is required\n * @param requiredFields - The list of fields that are required\n * @param experimental_defaultFormStateBehavior - Optional configuration object, if provided, allows users to override\n *        default form state behavior\n */\nfunction maybeAddDefaultToObject<T = any>(\n  obj: GenericObjectType,\n  key: string,\n  computedDefault: T | T[] | undefined,\n  includeUndefinedValues: boolean | 'excludeObjectChildren',\n  isParentRequired?: boolean,\n  requiredFields: string[] = [],\n  experimental_defaultFormStateBehavior: Experimental_DefaultFormStateBehavior = {}\n) {\n  const { emptyObjectFields = 'populateAllDefaults' } = experimental_defaultFormStateBehavior;\n  if (includeUndefinedValues) {\n    obj[key] = computedDefault;\n  } else if (emptyObjectFields !== 'skipDefaults') {\n    if (isObject(computedDefault)) {\n      // If isParentRequired is undefined, then we are at the root level of the schema so defer to the requiredness of\n      // the field key itself in the `requiredField` list\n      const isSelfOrParentRequired = isParentRequired === undefined ? requiredFields.includes(key) : isParentRequired;\n      // Store computedDefault if it's a non-empty object(e.g. not {}) and satisfies certain conditions\n      // Condition 1: If computedDefault is not empty or if the key is a required field\n      // Condition 2: If the parent object is required or emptyObjectFields is not 'populateRequiredDefaults'\n      if (\n        (!isEmpty(computedDefault) || requiredFields.includes(key)) &&\n        (isSelfOrParentRequired || emptyObjectFields !== 'populateRequiredDefaults')\n      ) {\n        obj[key] = computedDefault;\n      }\n    } else if (\n      // Store computedDefault if it's a defined primitive (e.g., true) and satisfies certain conditions\n      // Condition 1: computedDefault is not undefined\n      // Condition 2: If emptyObjectFields is 'populateAllDefaults' or if the key is a required field\n      computedDefault !== undefined &&\n      (emptyObjectFields === 'populateAllDefaults' || requiredFields.includes(key))\n    ) {\n      obj[key] = computedDefault;\n    }\n  }\n}\n\ninterface ComputeDefaultsProps<T = any, S extends StrictRJSFSchema = RJSFSchema> {\n  parentDefaults?: T;\n  rootSchema?: S;\n  rawFormData?: T;\n  includeUndefinedValues?: boolean | 'excludeObjectChildren';\n  _recurseList?: string[];\n  experimental_defaultFormStateBehavior?: Experimental_DefaultFormStateBehavior;\n  required?: boolean;\n}\n\n/** Computes the defaults for the current `schema` given the `rawFormData` and `parentDefaults` if any. This drills into\n * each level of the schema, recursively, to fill out every level of defaults provided by the schema.\n *\n * @param validator - an implementation of the `ValidatorType` interface that will be used when necessary\n * @param rawSchema - The schema for which the default state is desired\n * @param [props] - Optional props for this function\n * @param [props.parentDefaults] - Any defaults provided by the parent field in the schema\n * @param [props.rootSchema] - The options root schema, used to primarily to look up `$ref`s\n * @param [props.rawFormData] - The current formData, if any, onto which to provide any missing defaults\n * @param [props.includeUndefinedValues=false] - Optional flag, if true, cause undefined values to be added as defaults.\n *          If \"excludeObjectChildren\", cause undefined values for this object and pass `includeUndefinedValues` as\n *          false when computing defaults for any nested object properties.\n * @param [props._recurseList=[]] - The list of ref names currently being recursed, used to prevent infinite recursion\n * @param [props.experimental_defaultFormStateBehavior] Optional configuration object, if provided, allows users to override default form state behavior\n * @param [props.required] - Optional flag, if true, indicates this schema was required in the parent schema.\n * @returns - The resulting `formData` with all the defaults provided\n */\nexport function computeDefaults<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  rawSchema: S,\n  {\n    parentDefaults,\n    rawFormData,\n    rootSchema = {} as S,\n    includeUndefinedValues = false,\n    _recurseList = [],\n    experimental_defaultFormStateBehavior = undefined,\n    required,\n  }: ComputeDefaultsProps<T, S> = {}\n): T | T[] | undefined {\n  const formData: T = (isObject(rawFormData) ? rawFormData : {}) as T;\n  const schema: S = isObject(rawSchema) ? rawSchema : ({} as S);\n  // Compute the defaults recursively: give highest priority to deepest nodes.\n  let defaults: T | T[] | undefined = parentDefaults;\n  // If we get a new schema, then we need to recompute defaults again for the new schema found.\n  let schemaToCompute: S | null = null;\n  let updatedRecurseList = _recurseList;\n\n  if (isObject(defaults) && isObject(schema.default)) {\n    // For object defaults, only override parent defaults that are defined in\n    // schema.default.\n    defaults = mergeObjects(defaults!, schema.default as GenericObjectType) as T;\n  } else if (DEFAULT_KEY in schema) {\n    defaults = schema.default as unknown as T;\n  } else if (REF_KEY in schema) {\n    const refName = schema[REF_KEY];\n    // Use referenced schema defaults for this node.\n    if (!_recurseList.includes(refName!)) {\n      updatedRecurseList = _recurseList.concat(refName!);\n      schemaToCompute = findSchemaDefinition<S>(refName, rootSchema);\n    }\n  } else if (DEPENDENCIES_KEY in schema) {\n    const resolvedSchema = resolveDependencies<T, S, F>(validator, schema, rootSchema, false, [], formData);\n    schemaToCompute = resolvedSchema[0]; // pick the first element from resolve dependencies\n  } else if (isFixedItems(schema)) {\n    defaults = (schema.items! as S[]).map((itemSchema: S, idx: number) =>\n      computeDefaults<T, S>(validator, itemSchema, {\n        rootSchema,\n        includeUndefinedValues,\n        _recurseList,\n        experimental_defaultFormStateBehavior,\n        parentDefaults: Array.isArray(parentDefaults) ? parentDefaults[idx] : undefined,\n        rawFormData: formData as T,\n        required,\n      })\n    ) as T[];\n  } else if (ONE_OF_KEY in schema) {\n    const { oneOf, ...remaining } = schema;\n    if (oneOf!.length === 0) {\n      return undefined;\n    }\n    const discriminator = getDiscriminatorFieldFromSchema<S>(schema);\n    schemaToCompute = oneOf![\n      getClosestMatchingOption<T, S, F>(\n        validator,\n        rootSchema,\n        isEmpty(formData) ? undefined : formData,\n        oneOf as S[],\n        0,\n        discriminator\n      )\n    ] as S;\n    schemaToCompute = mergeSchemas(remaining, schemaToCompute) as S;\n  } else if (ANY_OF_KEY in schema) {\n    const { anyOf, ...remaining } = schema;\n    if (anyOf!.length === 0) {\n      return undefined;\n    }\n    const discriminator = getDiscriminatorFieldFromSchema<S>(schema);\n    schemaToCompute = anyOf![\n      getClosestMatchingOption<T, S, F>(\n        validator,\n        rootSchema,\n        isEmpty(formData) ? undefined : formData,\n        anyOf as S[],\n        0,\n        discriminator\n      )\n    ] as S;\n    schemaToCompute = mergeSchemas(remaining, schemaToCompute) as S;\n  }\n\n  if (schemaToCompute) {\n    return computeDefaults<T, S, F>(validator, schemaToCompute, {\n      rootSchema,\n      includeUndefinedValues,\n      _recurseList: updatedRecurseList,\n      experimental_defaultFormStateBehavior,\n      parentDefaults: defaults as T | undefined,\n      rawFormData: formData as T,\n      required,\n    });\n  }\n\n  // No defaults defined for this node, fallback to generic typed ones.\n  if (defaults === undefined) {\n    defaults = schema.default as unknown as T;\n  }\n\n  switch (getSchemaType<S>(schema)) {\n    // We need to recurse for object schema inner default values.\n    case 'object': {\n      // This is a custom addition that fixes this issue:\n      // https://github.com/rjsf-team/react-jsonschema-form/issues/3832\n      const retrievedSchema =\n        experimental_defaultFormStateBehavior?.allOf === 'populateDefaults' && ALL_OF_KEY in schema\n          ? retrieveSchema<T, S, F>(validator, schema, rootSchema, formData)\n          : schema;\n      const objectDefaults = Object.keys(retrievedSchema.properties || {}).reduce(\n        (acc: GenericObjectType, key: string) => {\n          // Compute the defaults for this node, with the parent defaults we might\n          // have from a previous run: defaults[key].\n          const computedDefault = computeDefaults<T, S, F>(validator, get(retrievedSchema, [PROPERTIES_KEY, key]), {\n            rootSchema,\n            _recurseList,\n            experimental_defaultFormStateBehavior,\n            includeUndefinedValues: includeUndefinedValues === true,\n            parentDefaults: get(defaults, [key]),\n            rawFormData: get(formData, [key]),\n            required: retrievedSchema.required?.includes(key),\n          });\n          maybeAddDefaultToObject<T>(\n            acc,\n            key,\n            computedDefault,\n            includeUndefinedValues,\n            required,\n            retrievedSchema.required,\n            experimental_defaultFormStateBehavior\n          );\n          return acc;\n        },\n        {}\n      ) as T;\n      if (retrievedSchema.additionalProperties) {\n        // as per spec additionalProperties may be either schema or boolean\n        const additionalPropertiesSchema = isObject(retrievedSchema.additionalProperties)\n          ? retrievedSchema.additionalProperties\n          : {};\n\n        const keys = new Set<string>();\n        if (isObject(defaults)) {\n          Object.keys(defaults as GenericObjectType)\n            .filter((key) => !retrievedSchema.properties || !retrievedSchema.properties[key])\n            .forEach((key) => keys.add(key));\n        }\n        const formDataRequired: string[] = [];\n        Object.keys(formData as GenericObjectType)\n          .filter((key) => !retrievedSchema.properties || !retrievedSchema.properties[key])\n          .forEach((key) => {\n            keys.add(key);\n            formDataRequired.push(key);\n          });\n        keys.forEach((key) => {\n          const computedDefault = computeDefaults(validator, additionalPropertiesSchema as S, {\n            rootSchema,\n            _recurseList,\n            experimental_defaultFormStateBehavior,\n            includeUndefinedValues: includeUndefinedValues === true,\n            parentDefaults: get(defaults, [key]),\n            rawFormData: get(formData, [key]),\n            required: retrievedSchema.required?.includes(key),\n          });\n          // Since these are additional properties we don't need to add the `experimental_defaultFormStateBehavior` prop\n          maybeAddDefaultToObject<T>(\n            objectDefaults as GenericObjectType,\n            key,\n            computedDefault,\n            includeUndefinedValues,\n            required,\n            formDataRequired\n          );\n        });\n      }\n      return objectDefaults;\n    }\n    case 'array': {\n      const neverPopulate = experimental_defaultFormStateBehavior?.arrayMinItems?.populate === 'never';\n      const ignoreMinItemsFlagSet = experimental_defaultFormStateBehavior?.arrayMinItems?.populate === 'requiredOnly';\n\n      // Inject defaults into existing array defaults\n      if (Array.isArray(defaults)) {\n        defaults = defaults.map((item, idx) => {\n          const schemaItem: S = getInnerSchemaForArrayItem<S>(schema, AdditionalItemsHandling.Fallback, idx);\n          return computeDefaults<T, S, F>(validator, schemaItem, {\n            rootSchema,\n            _recurseList,\n            experimental_defaultFormStateBehavior,\n            parentDefaults: item,\n            required,\n          });\n        }) as T[];\n      }\n\n      // Deeply inject defaults into already existing form data\n      if (Array.isArray(rawFormData)) {\n        const schemaItem: S = getInnerSchemaForArrayItem<S>(schema);\n        if (neverPopulate) {\n          defaults = rawFormData;\n        } else {\n          defaults = rawFormData.map((item: T, idx: number) => {\n            return computeDefaults<T, S, F>(validator, schemaItem, {\n              rootSchema,\n              _recurseList,\n              experimental_defaultFormStateBehavior,\n              rawFormData: item,\n              parentDefaults: get(defaults, [idx]),\n              required,\n            });\n          }) as T[];\n        }\n      }\n\n      if (neverPopulate) {\n        return defaults ?? [];\n      }\n      if (ignoreMinItemsFlagSet && !required) {\n        // If no form data exists or defaults are set leave the field empty/non-existent, otherwise\n        // return form data/defaults\n        return defaults ? defaults : undefined;\n      }\n\n      const defaultsLength = Array.isArray(defaults) ? defaults.length : 0;\n      if (\n        !schema.minItems ||\n        isMultiSelect<T, S, F>(validator, schema, rootSchema) ||\n        schema.minItems <= defaultsLength\n      ) {\n        return defaults ? defaults : [];\n      }\n\n      const defaultEntries: T[] = (defaults || []) as T[];\n      const fillerSchema: S = getInnerSchemaForArrayItem<S>(schema, AdditionalItemsHandling.Invert);\n      const fillerDefault = fillerSchema.default;\n\n      // Calculate filler entries for remaining items (minItems - existing raw data/defaults)\n      const fillerEntries: T[] = new Array(schema.minItems - defaultsLength).fill(\n        computeDefaults<any, S, F>(validator, fillerSchema, {\n          parentDefaults: fillerDefault,\n          rootSchema,\n          _recurseList,\n          experimental_defaultFormStateBehavior,\n          required,\n        })\n      ) as T[];\n      // then fill up the rest with either the item default or empty, up to minItems\n      return defaultEntries.concat(fillerEntries);\n    }\n  }\n\n  return defaults;\n}\n\n/** Returns the superset of `formData` that includes the given set updated to include any missing fields that have\n * computed to have defaults provided in the `schema`.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param theSchema - The schema for which the default state is desired\n * @param [formData] - The current formData, if any, onto which to provide any missing defaults\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\n * @param [includeUndefinedValues=false] - Optional flag, if true, cause undefined values to be added as defaults.\n *          If \"excludeObjectChildren\", cause undefined values for this object and pass `includeUndefinedValues` as\n *          false when computing defaults for any nested object properties.\n * @param [experimental_defaultFormStateBehavior] Optional configuration object, if provided, allows users to override default form state behavior\n * @returns - The resulting `formData` with all the defaults provided\n */\nexport default function getDefaultFormState<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(\n  validator: ValidatorType<T, S, F>,\n  theSchema: S,\n  formData?: T,\n  rootSchema?: S,\n  includeUndefinedValues: boolean | 'excludeObjectChildren' = false,\n  experimental_defaultFormStateBehavior?: Experimental_DefaultFormStateBehavior\n) {\n  if (!isObject(theSchema)) {\n    throw new Error('Invalid schema: ' + theSchema);\n  }\n  const schema = retrieveSchema<T, S, F>(validator, theSchema, rootSchema, formData);\n  const defaults = computeDefaults<T, S, F>(validator, schema, {\n    rootSchema,\n    includeUndefinedValues,\n    experimental_defaultFormStateBehavior,\n    rawFormData: formData,\n  });\n  if (formData === undefined || formData === null || (typeof formData === 'number' && isNaN(formData))) {\n    // No form data? Use schema defaults.\n    return defaults;\n  }\n  const { mergeExtraDefaults } = experimental_defaultFormStateBehavior?.arrayMinItems || {};\n  if (isObject(formData)) {\n    return mergeDefaultsWithFormData<T>(defaults as T, formData, mergeExtraDefaults);\n  }\n  if (Array.isArray(formData)) {\n    return mergeDefaultsWithFormData<T[]>(defaults as T[], formData, mergeExtraDefaults);\n  }\n  return formData;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}