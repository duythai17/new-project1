{"ast":null,"code":"import get from 'lodash/get';\nimport isEqual from 'lodash/isEqual';\nimport set from 'lodash/set';\nimport { ALL_OF_KEY, ANY_OF_KEY, ADDITIONAL_PROPERTIES_KEY, DEPENDENCIES_KEY, ITEMS_KEY, NAME_KEY, ONE_OF_KEY, PROPERTIES_KEY, REF_KEY, RJSF_ADDITONAL_PROPERTIES_FLAG } from '../constants';\nimport getDiscriminatorFieldFromSchema from '../getDiscriminatorFieldFromSchema';\nimport getClosestMatchingOption from './getClosestMatchingOption';\nimport retrieveSchema from './retrieveSchema';\n/** An internal helper that generates an `PathSchema` object for the `schema`, recursively with protection against\n * infinite recursion\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param schema - The schema for which the `PathSchema` is desired\n * @param [name=''] - The base name for the schema\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\n * @param [formData] - The current formData, if any, to assist retrieving a schema\n * @param [_recurseList=[]] - The list of retrieved schemas currently being recursed, used to prevent infinite recursion\n * @returns - The `PathSchema` object for the `schema`\n */\nfunction toPathSchemaInternal(validator, schema, name, rootSchema, formData) {\n  let _recurseList = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : [];\n  if (REF_KEY in schema || DEPENDENCIES_KEY in schema || ALL_OF_KEY in schema) {\n    const _schema = retrieveSchema(validator, schema, rootSchema, formData);\n    const sameSchemaIndex = _recurseList.findIndex(item => isEqual(item, _schema));\n    if (sameSchemaIndex === -1) {\n      return toPathSchemaInternal(validator, _schema, name, rootSchema, formData, _recurseList.concat(_schema));\n    }\n  }\n  let pathSchema = {\n    [NAME_KEY]: name.replace(/^\\./, '')\n  };\n  if (ONE_OF_KEY in schema || ANY_OF_KEY in schema) {\n    const xxxOf = ONE_OF_KEY in schema ? schema.oneOf : schema.anyOf;\n    const discriminator = getDiscriminatorFieldFromSchema(schema);\n    const index = getClosestMatchingOption(validator, rootSchema, formData, xxxOf, 0, discriminator);\n    const _schema = xxxOf[index];\n    pathSchema = {\n      ...pathSchema,\n      ...toPathSchemaInternal(validator, _schema, name, rootSchema, formData, _recurseList)\n    };\n  }\n  if (ADDITIONAL_PROPERTIES_KEY in schema && schema[ADDITIONAL_PROPERTIES_KEY] !== false) {\n    set(pathSchema, RJSF_ADDITONAL_PROPERTIES_FLAG, true);\n  }\n  if (ITEMS_KEY in schema && Array.isArray(formData)) {\n    const {\n      items: schemaItems,\n      additionalItems: schemaAdditionalItems\n    } = schema;\n    if (Array.isArray(schemaItems)) {\n      formData.forEach((element, i) => {\n        if (schemaItems[i]) {\n          pathSchema[i] = toPathSchemaInternal(validator, schemaItems[i], \"\".concat(name, \".\").concat(i), rootSchema, element, _recurseList);\n        } else if (schemaAdditionalItems) {\n          pathSchema[i] = toPathSchemaInternal(validator, schemaAdditionalItems, \"\".concat(name, \".\").concat(i), rootSchema, element, _recurseList);\n        } else {\n          console.warn(\"Unable to generate path schema for \\\"\".concat(name, \".\").concat(i, \"\\\". No schema defined for it\"));\n        }\n      });\n    } else {\n      formData.forEach((element, i) => {\n        pathSchema[i] = toPathSchemaInternal(validator, schemaItems, \"\".concat(name, \".\").concat(i), rootSchema, element, _recurseList);\n      });\n    }\n  } else if (PROPERTIES_KEY in schema) {\n    for (const property in schema.properties) {\n      const field = get(schema, [PROPERTIES_KEY, property]);\n      pathSchema[property] = toPathSchemaInternal(validator, field, \"\".concat(name, \".\").concat(property), rootSchema,\n      // It's possible that formData is not an object -- this can happen if an\n      // array item has just been added, but not populated with data yet\n      get(formData, [property]), _recurseList);\n    }\n  }\n  return pathSchema;\n}\n/** Generates an `PathSchema` object for the `schema`, recursively\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param schema - The schema for which the `PathSchema` is desired\n * @param [name=''] - The base name for the schema\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\n * @param [formData] - The current formData, if any, to assist retrieving a schema\n * @returns - The `PathSchema` object for the `schema`\n */\nexport default function toPathSchema(validator, schema) {\n  let name = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n  let rootSchema = arguments.length > 3 ? arguments[3] : undefined;\n  let formData = arguments.length > 4 ? arguments[4] : undefined;\n  return toPathSchemaInternal(validator, schema, name, rootSchema, formData);\n}","map":{"version":3,"names":["get","isEqual","set","ALL_OF_KEY","ANY_OF_KEY","ADDITIONAL_PROPERTIES_KEY","DEPENDENCIES_KEY","ITEMS_KEY","NAME_KEY","ONE_OF_KEY","PROPERTIES_KEY","REF_KEY","RJSF_ADDITONAL_PROPERTIES_FLAG","getDiscriminatorFieldFromSchema","getClosestMatchingOption","retrieveSchema","toPathSchemaInternal","validator","schema","name","rootSchema","formData","_recurseList","arguments","length","undefined","_schema","sameSchemaIndex","findIndex","item","concat","pathSchema","replace","xxxOf","oneOf","anyOf","discriminator","index","Array","isArray","items","schemaItems","additionalItems","schemaAdditionalItems","forEach","element","i","console","warn","property","properties","field","toPathSchema"],"sources":["D:\\Reactjs\\my-app\\node_modules\\@rjsf\\utils\\src\\schema\\toPathSchema.ts"],"sourcesContent":["import get from 'lodash/get';\nimport isEqual from 'lodash/isEqual';\nimport set from 'lodash/set';\n\nimport {\n  ALL_OF_KEY,\n  ANY_OF_KEY,\n  ADDITIONAL_PROPERTIES_KEY,\n  DEPENDENCIES_KEY,\n  ITEMS_KEY,\n  NAME_KEY,\n  ONE_OF_KEY,\n  PROPERTIES_KEY,\n  REF_KEY,\n  RJSF_ADDITONAL_PROPERTIES_FLAG,\n} from '../constants';\nimport getDiscriminatorFieldFromSchema from '../getDiscriminatorFieldFromSchema';\nimport { FormContextType, PathSchema, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\nimport getClosestMatchingOption from './getClosestMatchingOption';\nimport retrieveSchema from './retrieveSchema';\n\n/** An internal helper that generates an `PathSchema` object for the `schema`, recursively with protection against\n * infinite recursion\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param schema - The schema for which the `PathSchema` is desired\n * @param [name=''] - The base name for the schema\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\n * @param [formData] - The current formData, if any, to assist retrieving a schema\n * @param [_recurseList=[]] - The list of retrieved schemas currently being recursed, used to prevent infinite recursion\n * @returns - The `PathSchema` object for the `schema`\n */\nfunction toPathSchemaInternal<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  name: string,\n  rootSchema?: S,\n  formData?: T,\n  _recurseList: S[] = []\n): PathSchema<T> {\n  if (REF_KEY in schema || DEPENDENCIES_KEY in schema || ALL_OF_KEY in schema) {\n    const _schema = retrieveSchema<T, S, F>(validator, schema, rootSchema, formData);\n    const sameSchemaIndex = _recurseList.findIndex((item) => isEqual(item, _schema));\n    if (sameSchemaIndex === -1) {\n      return toPathSchemaInternal<T, S, F>(\n        validator,\n        _schema,\n        name,\n        rootSchema,\n        formData,\n        _recurseList.concat(_schema)\n      );\n    }\n  }\n\n  let pathSchema: PathSchema = {\n    [NAME_KEY]: name.replace(/^\\./, ''),\n  } as PathSchema;\n\n  if (ONE_OF_KEY in schema || ANY_OF_KEY in schema) {\n    const xxxOf: S[] = ONE_OF_KEY in schema ? (schema.oneOf as S[]) : (schema.anyOf as S[]);\n    const discriminator = getDiscriminatorFieldFromSchema<S>(schema);\n    const index = getClosestMatchingOption<T, S, F>(validator, rootSchema!, formData, xxxOf, 0, discriminator);\n    const _schema: S = xxxOf![index] as S;\n    pathSchema = {\n      ...pathSchema,\n      ...toPathSchemaInternal<T, S, F>(validator, _schema, name, rootSchema, formData, _recurseList),\n    };\n  }\n\n  if (ADDITIONAL_PROPERTIES_KEY in schema && schema[ADDITIONAL_PROPERTIES_KEY] !== false) {\n    set(pathSchema, RJSF_ADDITONAL_PROPERTIES_FLAG, true);\n  }\n\n  if (ITEMS_KEY in schema && Array.isArray(formData)) {\n    const { items: schemaItems, additionalItems: schemaAdditionalItems } = schema;\n\n    if (Array.isArray(schemaItems)) {\n      formData.forEach((element, i: number) => {\n        if (schemaItems[i]) {\n          pathSchema[i] = toPathSchemaInternal<T, S, F>(\n            validator,\n            schemaItems[i] as S,\n            `${name}.${i}`,\n            rootSchema,\n            element,\n            _recurseList\n          );\n        } else if (schemaAdditionalItems) {\n          pathSchema[i] = toPathSchemaInternal<T, S, F>(\n            validator,\n            schemaAdditionalItems as S,\n            `${name}.${i}`,\n            rootSchema,\n            element,\n            _recurseList\n          );\n        } else {\n          console.warn(`Unable to generate path schema for \"${name}.${i}\". No schema defined for it`);\n        }\n      });\n    } else {\n      formData.forEach((element, i: number) => {\n        pathSchema[i] = toPathSchemaInternal<T, S, F>(\n          validator,\n          schemaItems as S,\n          `${name}.${i}`,\n          rootSchema,\n          element,\n          _recurseList\n        );\n      });\n    }\n  } else if (PROPERTIES_KEY in schema) {\n    for (const property in schema.properties) {\n      const field = get(schema, [PROPERTIES_KEY, property]);\n      pathSchema[property] = toPathSchemaInternal<T, S, F>(\n        validator,\n        field,\n        `${name}.${property}`,\n        rootSchema,\n        // It's possible that formData is not an object -- this can happen if an\n        // array item has just been added, but not populated with data yet\n        get(formData, [property]),\n        _recurseList\n      );\n    }\n  }\n  return pathSchema as PathSchema<T>;\n}\n\n/** Generates an `PathSchema` object for the `schema`, recursively\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param schema - The schema for which the `PathSchema` is desired\n * @param [name=''] - The base name for the schema\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\n * @param [formData] - The current formData, if any, to assist retrieving a schema\n * @returns - The `PathSchema` object for the `schema`\n */\nexport default function toPathSchema<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  name = '',\n  rootSchema?: S,\n  formData?: T\n): PathSchema<T> {\n  return toPathSchemaInternal(validator, schema, name, rootSchema, formData);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}