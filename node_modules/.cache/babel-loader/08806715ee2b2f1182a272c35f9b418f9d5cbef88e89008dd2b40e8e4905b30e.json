{"ast":null,"code":"import get from 'lodash/get';\nimport isEqual from 'lodash/isEqual';\nimport { ALL_OF_KEY, DEPENDENCIES_KEY, ID_KEY, ITEMS_KEY, PROPERTIES_KEY, REF_KEY } from '../constants';\nimport isObject from '../isObject';\nimport retrieveSchema from './retrieveSchema';\nimport getSchemaType from '../getSchemaType';\n/** An internal helper that generates an `IdSchema` object for the `schema`, recursively with protection against\n * infinite recursion\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param schema - The schema for which the `IdSchema` is desired\n * @param idPrefix - The prefix to use for the id\n * @param idSeparator - The separator to use for the path segments in the id\n * @param [id] - The base id for the schema\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\n * @param [formData] - The current formData, if any, to assist retrieving a schema\n * @param [_recurseList=[]] - The list of retrieved schemas currently being recursed, used to prevent infinite recursion\n * @returns - The `IdSchema` object for the `schema`\n */\nfunction toIdSchemaInternal(validator, schema, idPrefix, idSeparator, id, rootSchema, formData, _recurseList = []) {\n  if (REF_KEY in schema || DEPENDENCIES_KEY in schema || ALL_OF_KEY in schema) {\n    const _schema = retrieveSchema(validator, schema, rootSchema, formData);\n    const sameSchemaIndex = _recurseList.findIndex(item => isEqual(item, _schema));\n    if (sameSchemaIndex === -1) {\n      return toIdSchemaInternal(validator, _schema, idPrefix, idSeparator, id, rootSchema, formData, _recurseList.concat(_schema));\n    }\n  }\n  if (ITEMS_KEY in schema && !get(schema, [ITEMS_KEY, REF_KEY])) {\n    return toIdSchemaInternal(validator, get(schema, ITEMS_KEY), idPrefix, idSeparator, id, rootSchema, formData, _recurseList);\n  }\n  const $id = id || idPrefix;\n  const idSchema = {\n    $id\n  };\n  if (getSchemaType(schema) === 'object' && PROPERTIES_KEY in schema) {\n    for (const name in schema.properties) {\n      const field = get(schema, [PROPERTIES_KEY, name]);\n      const fieldId = idSchema[ID_KEY] + idSeparator + name;\n      idSchema[name] = toIdSchemaInternal(validator, isObject(field) ? field : {}, idPrefix, idSeparator, fieldId, rootSchema,\n      // It's possible that formData is not an object -- this can happen if an\n      // array item has just been added, but not populated with data yet\n      get(formData, [name]), _recurseList);\n    }\n  }\n  return idSchema;\n}\n/** Generates an `IdSchema` object for the `schema`, recursively\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param schema - The schema for which the `IdSchema` is desired\n * @param [id] - The base id for the schema\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\n * @param [formData] - The current formData, if any, to assist retrieving a schema\n * @param [idPrefix='root'] - The prefix to use for the id\n * @param [idSeparator='_'] - The separator to use for the path segments in the id\n * @returns - The `IdSchema` object for the `schema`\n */\nexport default function toIdSchema(validator, schema, id, rootSchema, formData, idPrefix = 'root', idSeparator = '_') {\n  return toIdSchemaInternal(validator, schema, idPrefix, idSeparator, id, rootSchema, formData);\n}","map":{"version":3,"names":["get","isEqual","ALL_OF_KEY","DEPENDENCIES_KEY","ID_KEY","ITEMS_KEY","PROPERTIES_KEY","REF_KEY","isObject","retrieveSchema","getSchemaType","toIdSchemaInternal","validator","schema","idPrefix","idSeparator","id","rootSchema","formData","_recurseList","_schema","sameSchemaIndex","findIndex","item","concat","$id","idSchema","name","properties","field","fieldId","toIdSchema"],"sources":["D:\\Reactjs\\my-app\\node_modules\\@rjsf\\utils\\src\\schema\\toIdSchema.ts"],"sourcesContent":["import get from 'lodash/get';\nimport isEqual from 'lodash/isEqual';\n\nimport { ALL_OF_KEY, DEPENDENCIES_KEY, ID_KEY, ITEMS_KEY, PROPERTIES_KEY, REF_KEY } from '../constants';\nimport isObject from '../isObject';\nimport { FormContextType, IdSchema, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\nimport retrieveSchema from './retrieveSchema';\nimport getSchemaType from '../getSchemaType';\n\n/** An internal helper that generates an `IdSchema` object for the `schema`, recursively with protection against\n * infinite recursion\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param schema - The schema for which the `IdSchema` is desired\n * @param idPrefix - The prefix to use for the id\n * @param idSeparator - The separator to use for the path segments in the id\n * @param [id] - The base id for the schema\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\n * @param [formData] - The current formData, if any, to assist retrieving a schema\n * @param [_recurseList=[]] - The list of retrieved schemas currently being recursed, used to prevent infinite recursion\n * @returns - The `IdSchema` object for the `schema`\n */\nfunction toIdSchemaInternal<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  idPrefix: string,\n  idSeparator: string,\n  id?: string | null,\n  rootSchema?: S,\n  formData?: T,\n  _recurseList: S[] = []\n): IdSchema<T> {\n  if (REF_KEY in schema || DEPENDENCIES_KEY in schema || ALL_OF_KEY in schema) {\n    const _schema = retrieveSchema<T, S, F>(validator, schema, rootSchema, formData);\n    const sameSchemaIndex = _recurseList.findIndex((item) => isEqual(item, _schema));\n    if (sameSchemaIndex === -1) {\n      return toIdSchemaInternal<T, S, F>(\n        validator,\n        _schema,\n        idPrefix,\n        idSeparator,\n        id,\n        rootSchema,\n        formData,\n        _recurseList.concat(_schema)\n      );\n    }\n  }\n  if (ITEMS_KEY in schema && !get(schema, [ITEMS_KEY, REF_KEY])) {\n    return toIdSchemaInternal<T, S, F>(\n      validator,\n      get(schema, ITEMS_KEY) as S,\n      idPrefix,\n      idSeparator,\n      id,\n      rootSchema,\n      formData,\n      _recurseList\n    );\n  }\n  const $id = id || idPrefix;\n  const idSchema: IdSchema = { $id } as IdSchema<T>;\n  if (getSchemaType<S>(schema) === 'object' && PROPERTIES_KEY in schema) {\n    for (const name in schema.properties) {\n      const field = get(schema, [PROPERTIES_KEY, name]);\n      const fieldId = idSchema[ID_KEY] + idSeparator + name;\n      idSchema[name] = toIdSchemaInternal<T, S, F>(\n        validator,\n        isObject(field) ? field : {},\n        idPrefix,\n        idSeparator,\n        fieldId,\n        rootSchema,\n        // It's possible that formData is not an object -- this can happen if an\n        // array item has just been added, but not populated with data yet\n        get(formData, [name]),\n        _recurseList\n      );\n    }\n  }\n  return idSchema as IdSchema<T>;\n}\n\n/** Generates an `IdSchema` object for the `schema`, recursively\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param schema - The schema for which the `IdSchema` is desired\n * @param [id] - The base id for the schema\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\n * @param [formData] - The current formData, if any, to assist retrieving a schema\n * @param [idPrefix='root'] - The prefix to use for the id\n * @param [idSeparator='_'] - The separator to use for the path segments in the id\n * @returns - The `IdSchema` object for the `schema`\n */\nexport default function toIdSchema<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  id?: string | null,\n  rootSchema?: S,\n  formData?: T,\n  idPrefix = 'root',\n  idSeparator = '_'\n): IdSchema<T> {\n  return toIdSchemaInternal<T, S, F>(validator, schema, idPrefix, idSeparator, id, rootSchema, formData);\n}\n"],"mappings":"AAAA,OAAOA,GAAG,MAAM,YAAY;AAC5B,OAAOC,OAAO,MAAM,gBAAgB;AAEpC,SAASC,UAAU,EAAEC,gBAAgB,EAAEC,MAAM,EAAEC,SAAS,EAAEC,cAAc,EAAEC,OAAO,QAAQ,cAAc;AACvG,OAAOC,QAAQ,MAAM,aAAa;AAElC,OAAOC,cAAc,MAAM,kBAAkB;AAC7C,OAAOC,aAAa,MAAM,kBAAkB;AAE5C;;;;;;;;;;;;;AAaA,SAASC,kBAAkBA,CACzBC,SAAiC,EACjCC,MAAS,EACTC,QAAgB,EAChBC,WAAmB,EACnBC,EAAkB,EAClBC,UAAc,EACdC,QAAY,EACZC,YAAA,GAAoB,EAAE;EAEtB,IAAIZ,OAAO,IAAIM,MAAM,IAAIV,gBAAgB,IAAIU,MAAM,IAAIX,UAAU,IAAIW,MAAM,EAAE;IAC3E,MAAMO,OAAO,GAAGX,cAAc,CAAUG,SAAS,EAAEC,MAAM,EAAEI,UAAU,EAAEC,QAAQ,CAAC;IAChF,MAAMG,eAAe,GAAGF,YAAY,CAACG,SAAS,CAAEC,IAAI,IAAKtB,OAAO,CAACsB,IAAI,EAAEH,OAAO,CAAC,CAAC;IAChF,IAAIC,eAAe,KAAK,CAAC,CAAC,EAAE;MAC1B,OAAOV,kBAAkB,CACvBC,SAAS,EACTQ,OAAO,EACPN,QAAQ,EACRC,WAAW,EACXC,EAAE,EACFC,UAAU,EACVC,QAAQ,EACRC,YAAY,CAACK,MAAM,CAACJ,OAAO,CAAC,CAC7B;;;EAGL,IAAIf,SAAS,IAAIQ,MAAM,IAAI,CAACb,GAAG,CAACa,MAAM,EAAE,CAACR,SAAS,EAAEE,OAAO,CAAC,CAAC,EAAE;IAC7D,OAAOI,kBAAkB,CACvBC,SAAS,EACTZ,GAAG,CAACa,MAAM,EAAER,SAAS,CAAM,EAC3BS,QAAQ,EACRC,WAAW,EACXC,EAAE,EACFC,UAAU,EACVC,QAAQ,EACRC,YAAY,CACb;;EAEH,MAAMM,GAAG,GAAGT,EAAE,IAAIF,QAAQ;EAC1B,MAAMY,QAAQ,GAAa;IAAED;EAAG,CAAiB;EACjD,IAAIf,aAAa,CAAIG,MAAM,CAAC,KAAK,QAAQ,IAAIP,cAAc,IAAIO,MAAM,EAAE;IACrE,KAAK,MAAMc,IAAI,IAAId,MAAM,CAACe,UAAU,EAAE;MACpC,MAAMC,KAAK,GAAG7B,GAAG,CAACa,MAAM,EAAE,CAACP,cAAc,EAAEqB,IAAI,CAAC,CAAC;MACjD,MAAMG,OAAO,GAAGJ,QAAQ,CAACtB,MAAM,CAAC,GAAGW,WAAW,GAAGY,IAAI;MACrDD,QAAQ,CAACC,IAAI,CAAC,GAAGhB,kBAAkB,CACjCC,SAAS,EACTJ,QAAQ,CAACqB,KAAK,CAAC,GAAGA,KAAK,GAAG,EAAE,EAC5Bf,QAAQ,EACRC,WAAW,EACXe,OAAO,EACPb,UAAU;MACV;MACA;MACAjB,GAAG,CAACkB,QAAQ,EAAE,CAACS,IAAI,CAAC,CAAC,EACrBR,YAAY,CACb;;;EAGL,OAAOO,QAAuB;AAChC;AAEA;;;;;;;;;;;AAWA,eAAc,SAAUK,UAAUA,CAChCnB,SAAiC,EACjCC,MAAS,EACTG,EAAkB,EAClBC,UAAc,EACdC,QAAY,EACZJ,QAAQ,GAAG,MAAM,EACjBC,WAAW,GAAG,GAAG;EAEjB,OAAOJ,kBAAkB,CAAUC,SAAS,EAAEC,MAAM,EAAEC,QAAQ,EAAEC,WAAW,EAAEC,EAAE,EAAEC,UAAU,EAAEC,QAAQ,CAAC;AACxG"},"metadata":{},"sourceType":"module","externalDependencies":[]}