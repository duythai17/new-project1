{"ast":null,"code":"import get from 'lodash/get';\nimport { createErrorHandler, getDefaultFormState, getUiOptions, PROPERTIES_KEY, toErrorSchema, unwrapErrorHandler, validationDataMerge } from '@rjsf/utils';\n/** Transforming the error output from ajv to format used by @rjsf/utils.\n * At some point, components should be updated to support ajv.\n *\n * @param errors - The list of AJV errors to convert to `RJSFValidationErrors`\n * @param [uiSchema] - An optional uiSchema that is passed to `transformErrors` and `customValidate`\n */\nexport function transformRJSFValidationErrors(errors = [], uiSchema) {\n  return errors.map(e => {\n    const {\n      instancePath,\n      keyword,\n      params,\n      schemaPath,\n      parentSchema,\n      ...rest\n    } = e;\n    let {\n      message = ''\n    } = rest;\n    let property = instancePath.replace(/\\//g, '.');\n    let stack = `${property} ${message}`.trim();\n    if ('missingProperty' in params) {\n      property = property ? `${property}.${params.missingProperty}` : params.missingProperty;\n      const currentProperty = params.missingProperty;\n      const uiSchemaTitle = getUiOptions(get(uiSchema, `${property.replace(/^\\./, '')}`)).title;\n      if (uiSchemaTitle) {\n        message = message.replace(currentProperty, uiSchemaTitle);\n      } else {\n        const parentSchemaTitle = get(parentSchema, [PROPERTIES_KEY, currentProperty, 'title']);\n        if (parentSchemaTitle) {\n          message = message.replace(currentProperty, parentSchemaTitle);\n        }\n      }\n      stack = message;\n    } else {\n      const uiSchemaTitle = getUiOptions(get(uiSchema, `${property.replace(/^\\./, '')}`)).title;\n      if (uiSchemaTitle) {\n        stack = `'${uiSchemaTitle}' ${message}`.trim();\n      } else {\n        const parentSchemaTitle = parentSchema === null || parentSchema === void 0 ? void 0 : parentSchema.title;\n        if (parentSchemaTitle) {\n          stack = `'${parentSchemaTitle}' ${message}`.trim();\n        }\n      }\n    }\n    // put data in expected format\n    return {\n      name: keyword,\n      property,\n      message,\n      params,\n      stack,\n      schemaPath\n    };\n  });\n}\n/** This function processes the `formData` with an optional user contributed `customValidate` function, which receives\n * the form data and a `errorHandler` function that will be used to add custom validation errors for each field. Also\n * supports a `transformErrors` function that will take the raw AJV validation errors, prior to custom validation and\n * transform them in what ever way it chooses.\n *\n * @param validator - The `ValidatorType` implementation used for the `getDefaultFormState()` call\n * @param rawErrors - The list of raw `ErrorObject`s to process\n * @param formData - The form data to validate\n * @param schema - The schema against which to validate the form data\n * @param [customValidate] - An optional function that is used to perform custom validation\n * @param [transformErrors] - An optional function that is used to transform errors after AJV validation\n * @param [uiSchema] - An optional uiSchema that is passed to `transformErrors` and `customValidate`\n */\nexport default function processRawValidationErrors(validator, rawErrors, formData, schema, customValidate, transformErrors, uiSchema) {\n  const {\n    validationError: invalidSchemaError\n  } = rawErrors;\n  let errors = transformRJSFValidationErrors(rawErrors.errors, uiSchema);\n  if (invalidSchemaError) {\n    errors = [...errors, {\n      stack: invalidSchemaError.message\n    }];\n  }\n  if (typeof transformErrors === 'function') {\n    errors = transformErrors(errors, uiSchema);\n  }\n  let errorSchema = toErrorSchema(errors);\n  if (invalidSchemaError) {\n    errorSchema = {\n      ...errorSchema,\n      $schema: {\n        __errors: [invalidSchemaError.message]\n      }\n    };\n  }\n  if (typeof customValidate !== 'function') {\n    return {\n      errors,\n      errorSchema\n    };\n  }\n  // Include form data with undefined values, which is required for custom validation.\n  const newFormData = getDefaultFormState(validator, schema, formData, schema, true);\n  const errorHandler = customValidate(newFormData, createErrorHandler(newFormData), uiSchema);\n  const userErrorSchema = unwrapErrorHandler(errorHandler);\n  return validationDataMerge({\n    errors,\n    errorSchema\n  }, userErrorSchema);\n}","map":{"version":3,"names":["get","createErrorHandler","getDefaultFormState","getUiOptions","PROPERTIES_KEY","toErrorSchema","unwrapErrorHandler","validationDataMerge","transformRJSFValidationErrors","errors","uiSchema","map","e","instancePath","keyword","params","schemaPath","parentSchema","rest","message","property","replace","stack","trim","missingProperty","currentProperty","uiSchemaTitle","title","parentSchemaTitle","name","processRawValidationErrors","validator","rawErrors","formData","schema","customValidate","transformErrors","validationError","invalidSchemaError","errorSchema","$schema","__errors","newFormData","errorHandler","userErrorSchema"],"sources":["D:\\Reactjs\\my-app\\node_modules\\@rjsf\\validator-ajv8\\src\\processRawValidationErrors.ts"],"sourcesContent":["import { ErrorObject } from 'ajv';\nimport get from 'lodash/get';\nimport {\n  createErrorHandler,\n  CustomValidator,\n  ErrorTransformer,\n  FormContextType,\n  getDefaultFormState,\n  getUiOptions,\n  PROPERTIES_KEY,\n  RJSFSchema,\n  RJSFValidationError,\n  StrictRJSFSchema,\n  toErrorSchema,\n  UiSchema,\n  unwrapErrorHandler,\n  validationDataMerge,\n  ValidatorType,\n} from '@rjsf/utils';\n\nexport type RawValidationErrorsType<Result = any> = { errors?: Result[]; validationError?: Error };\n\n/** Transforming the error output from ajv to format used by @rjsf/utils.\n * At some point, components should be updated to support ajv.\n *\n * @param errors - The list of AJV errors to convert to `RJSFValidationErrors`\n * @param [uiSchema] - An optional uiSchema that is passed to `transformErrors` and `customValidate`\n */\nexport function transformRJSFValidationErrors<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(errors: ErrorObject[] = [], uiSchema?: UiSchema<T, S, F>): RJSFValidationError[] {\n  return errors.map((e: ErrorObject) => {\n    const { instancePath, keyword, params, schemaPath, parentSchema, ...rest } = e;\n    let { message = '' } = rest;\n    let property = instancePath.replace(/\\//g, '.');\n    let stack = `${property} ${message}`.trim();\n\n    if ('missingProperty' in params) {\n      property = property ? `${property}.${params.missingProperty}` : params.missingProperty;\n      const currentProperty: string = params.missingProperty;\n      const uiSchemaTitle = getUiOptions(get(uiSchema, `${property.replace(/^\\./, '')}`)).title;\n\n      if (uiSchemaTitle) {\n        message = message.replace(currentProperty, uiSchemaTitle);\n      } else {\n        const parentSchemaTitle = get(parentSchema, [PROPERTIES_KEY, currentProperty, 'title']);\n\n        if (parentSchemaTitle) {\n          message = message.replace(currentProperty, parentSchemaTitle);\n        }\n      }\n\n      stack = message;\n    } else {\n      const uiSchemaTitle = getUiOptions<T, S, F>(get(uiSchema, `${property.replace(/^\\./, '')}`)).title;\n\n      if (uiSchemaTitle) {\n        stack = `'${uiSchemaTitle}' ${message}`.trim();\n      } else {\n        const parentSchemaTitle = parentSchema?.title;\n\n        if (parentSchemaTitle) {\n          stack = `'${parentSchemaTitle}' ${message}`.trim();\n        }\n      }\n    }\n\n    // put data in expected format\n    return {\n      name: keyword,\n      property,\n      message,\n      params, // specific to ajv\n      stack,\n      schemaPath,\n    };\n  });\n}\n\n/** This function processes the `formData` with an optional user contributed `customValidate` function, which receives\n * the form data and a `errorHandler` function that will be used to add custom validation errors for each field. Also\n * supports a `transformErrors` function that will take the raw AJV validation errors, prior to custom validation and\n * transform them in what ever way it chooses.\n *\n * @param validator - The `ValidatorType` implementation used for the `getDefaultFormState()` call\n * @param rawErrors - The list of raw `ErrorObject`s to process\n * @param formData - The form data to validate\n * @param schema - The schema against which to validate the form data\n * @param [customValidate] - An optional function that is used to perform custom validation\n * @param [transformErrors] - An optional function that is used to transform errors after AJV validation\n * @param [uiSchema] - An optional uiSchema that is passed to `transformErrors` and `customValidate`\n */\nexport default function processRawValidationErrors<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(\n  validator: ValidatorType<T, S, F>,\n  rawErrors: RawValidationErrorsType<ErrorObject>,\n  formData: T | undefined,\n  schema: S,\n  customValidate?: CustomValidator<T, S, F>,\n  transformErrors?: ErrorTransformer<T, S, F>,\n  uiSchema?: UiSchema<T, S, F>\n) {\n  const { validationError: invalidSchemaError } = rawErrors;\n  let errors = transformRJSFValidationErrors<T, S, F>(rawErrors.errors, uiSchema);\n\n  if (invalidSchemaError) {\n    errors = [...errors, { stack: invalidSchemaError!.message }];\n  }\n  if (typeof transformErrors === 'function') {\n    errors = transformErrors(errors, uiSchema);\n  }\n\n  let errorSchema = toErrorSchema<T>(errors);\n\n  if (invalidSchemaError) {\n    errorSchema = {\n      ...errorSchema,\n      $schema: {\n        __errors: [invalidSchemaError!.message],\n      },\n    };\n  }\n\n  if (typeof customValidate !== 'function') {\n    return { errors, errorSchema };\n  }\n\n  // Include form data with undefined values, which is required for custom validation.\n  const newFormData = getDefaultFormState<T, S, F>(validator, schema, formData, schema, true) as T;\n\n  const errorHandler = customValidate(newFormData, createErrorHandler<T>(newFormData), uiSchema);\n  const userErrorSchema = unwrapErrorHandler<T>(errorHandler);\n  return validationDataMerge<T>({ errors, errorSchema }, userErrorSchema);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}