{"ast":null,"code":"const cloneDeep = require('lodash/cloneDeep');\nconst compare = require('json-schema-compare');\nconst computeLcm = require('compute-lcm');\nconst defaultsDeep = require('lodash/defaultsDeep');\nconst flatten = require('lodash/flatten');\nconst flattenDeep = require('lodash/flattenDeep');\nconst intersection = require('lodash/intersection');\nconst intersectionWith = require('lodash/intersectionWith');\nconst isEqual = require('lodash/isEqual');\nconst isPlainObject = require('lodash/isPlainObject');\nconst pullAll = require('lodash/pullAll');\nconst sortBy = require('lodash/sortBy');\nconst uniq = require('lodash/uniq');\nconst uniqWith = require('lodash/uniqWith');\nconst propertiesResolver = require('./complex-resolvers/properties');\nconst itemsResolver = require('./complex-resolvers/items');\nconst contains = (arr, val) => arr.indexOf(val) !== -1;\nconst isSchema = val => isPlainObject(val) || val === true || val === false;\nconst isFalse = val => val === false;\nconst isTrue = val => val === true;\nconst schemaResolver = (compacted, key, mergeSchemas) => mergeSchemas(compacted);\nconst stringArray = values => sortBy(uniq(flattenDeep(values)));\nconst notUndefined = val => val !== undefined;\nconst allUniqueKeys = arr => uniq(flattenDeep(arr.map(keys)));\n\n// resolvers\nconst first = compacted => compacted[0];\nconst required = compacted => stringArray(compacted);\nconst maximumValue = compacted => Math.max.apply(Math, compacted);\nconst minimumValue = compacted => Math.min.apply(Math, compacted);\nconst uniqueItems = compacted => compacted.some(isTrue);\nconst examples = compacted => uniqWith(flatten(compacted), isEqual);\nfunction compareProp(key) {\n  return function (a, b) {\n    return compare({\n      [key]: a\n    }, {\n      [key]: b\n    });\n  };\n}\nfunction getAllOf(schema) {\n  let {\n    allOf = [],\n    ...copy\n  } = schema;\n  copy = isPlainObject(schema) ? copy : schema; // if schema is boolean\n  return [copy, ...allOf.map(getAllOf)];\n}\nfunction getValues(schemas, key) {\n  return schemas.map(schema => schema && schema[key]);\n}\nfunction tryMergeSchemaGroups(schemaGroups, mergeSchemas) {\n  return schemaGroups.map(function (schemas, index) {\n    try {\n      return mergeSchemas(schemas, index);\n    } catch (e) {\n      return undefined;\n    }\n  }).filter(notUndefined);\n}\nfunction keys(obj) {\n  if (isPlainObject(obj) || Array.isArray(obj)) {\n    return Object.keys(obj);\n  } else {\n    return [];\n  }\n}\nfunction getAnyOfCombinations(arrOfArrays, combinations) {\n  combinations = combinations || [];\n  if (!arrOfArrays.length) {\n    return combinations;\n  }\n  const values = arrOfArrays.slice(0).shift();\n  const rest = arrOfArrays.slice(1);\n  if (combinations.length) {\n    return getAnyOfCombinations(rest, flatten(combinations.map(combination => values.map(item => [item].concat(combination)))));\n  }\n  return getAnyOfCombinations(rest, values.map(item => item));\n}\nfunction throwIncompatible(values, paths) {\n  let asJSON;\n  try {\n    asJSON = values.map(function (val) {\n      return JSON.stringify(val, null, 2);\n    }).join('\\n');\n  } catch (variable) {\n    asJSON = values.join(', ');\n  }\n  throw new Error('Could not resolve values for path:\"' + paths.join('.') + '\". They are probably incompatible. Values: \\n' + asJSON);\n}\nfunction callGroupResolver(complexKeywords, resolverName, schemas, mergeSchemas, options, parents) {\n  if (complexKeywords.length) {\n    const resolverConfig = options.complexResolvers[resolverName];\n    if (!resolverConfig || !resolverConfig.resolver) {\n      throw new Error('No resolver found for ' + resolverName);\n    }\n\n    // extract all keywords from all the schemas that have one or more\n    // then remove all undefined ones and not unique\n    const extractedKeywordsOnly = schemas.map(schema => complexKeywords.reduce((all, key) => {\n      if (schema[key] !== undefined) all[key] = schema[key];\n      return all;\n    }, {}));\n    const unique = uniqWith(extractedKeywordsOnly, compare);\n\n    // create mergers that automatically add the path of the keyword for use in the complex resolver\n    const mergers = resolverConfig.keywords.reduce((all, key) => ({\n      ...all,\n      [key]: function (schemas) {\n        let extraKey = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n        return mergeSchemas(schemas, null, parents.concat(key, extraKey));\n      }\n    }), {});\n    const result = resolverConfig.resolver(unique, parents.concat(resolverName), mergers, options);\n    if (!isPlainObject(result)) {\n      throwIncompatible(unique, parents.concat(resolverName));\n    }\n    return result;\n  }\n}\nfunction createRequiredMetaArray(arr) {\n  return {\n    required: arr\n  };\n}\nconst schemaGroupProps = ['properties', 'patternProperties', 'definitions', 'dependencies'];\nconst schemaArrays = ['anyOf', 'oneOf'];\nconst schemaProps = ['additionalProperties', 'additionalItems', 'contains', 'propertyNames', 'not', 'items'];\nconst defaultResolvers = {\n  type(compacted) {\n    if (compacted.some(Array.isArray)) {\n      const normalized = compacted.map(function (val) {\n        return Array.isArray(val) ? val : [val];\n      });\n      const common = intersection.apply(null, normalized);\n      if (common.length === 1) {\n        return common[0];\n      } else if (common.length > 1) {\n        return uniq(common);\n      }\n    }\n  },\n  dependencies(compacted, paths, mergeSchemas) {\n    const allChildren = allUniqueKeys(compacted);\n    return allChildren.reduce(function (all, childKey) {\n      const childSchemas = getValues(compacted, childKey);\n      let innerCompacted = uniqWith(childSchemas.filter(notUndefined), isEqual);\n\n      // to support dependencies\n      const innerArrays = innerCompacted.filter(Array.isArray);\n      if (innerArrays.length) {\n        if (innerArrays.length === innerCompacted.length) {\n          all[childKey] = stringArray(innerCompacted);\n        } else {\n          const innerSchemas = innerCompacted.filter(isSchema);\n          const arrayMetaScheams = innerArrays.map(createRequiredMetaArray);\n          all[childKey] = mergeSchemas(innerSchemas.concat(arrayMetaScheams), childKey);\n        }\n        return all;\n      }\n      innerCompacted = uniqWith(innerCompacted, compare);\n      all[childKey] = mergeSchemas(innerCompacted, childKey);\n      return all;\n    }, {});\n  },\n  oneOf(compacted, paths, mergeSchemas) {\n    const combinations = getAnyOfCombinations(cloneDeep(compacted));\n    const result = tryMergeSchemaGroups(combinations, mergeSchemas);\n    const unique = uniqWith(result, compare);\n    if (unique.length) {\n      return unique;\n    }\n  },\n  not(compacted) {\n    return {\n      anyOf: compacted\n    };\n  },\n  pattern(compacted) {\n    return compacted.map(r => '(?=' + r + ')').join('');\n  },\n  multipleOf(compacted) {\n    let integers = compacted.slice(0);\n    let factor = 1;\n    while (integers.some(n => !Number.isInteger(n))) {\n      integers = integers.map(n => n * 10);\n      factor = factor * 10;\n    }\n    return computeLcm(integers) / factor;\n  },\n  enum(compacted) {\n    const enums = intersectionWith.apply(null, compacted.concat(isEqual));\n    if (enums.length) {\n      return sortBy(enums);\n    }\n  }\n};\ndefaultResolvers.$id = first;\ndefaultResolvers.$ref = first;\ndefaultResolvers.$schema = first;\ndefaultResolvers.additionalItems = schemaResolver;\ndefaultResolvers.additionalProperties = schemaResolver;\ndefaultResolvers.anyOf = defaultResolvers.oneOf;\ndefaultResolvers.contains = schemaResolver;\ndefaultResolvers.default = first;\ndefaultResolvers.definitions = defaultResolvers.dependencies;\ndefaultResolvers.description = first;\ndefaultResolvers.examples = examples;\ndefaultResolvers.exclusiveMaximum = minimumValue;\ndefaultResolvers.exclusiveMinimum = maximumValue;\ndefaultResolvers.items = itemsResolver;\ndefaultResolvers.maximum = minimumValue;\ndefaultResolvers.maxItems = minimumValue;\ndefaultResolvers.maxLength = minimumValue;\ndefaultResolvers.maxProperties = minimumValue;\ndefaultResolvers.minimum = maximumValue;\ndefaultResolvers.minItems = maximumValue;\ndefaultResolvers.minLength = maximumValue;\ndefaultResolvers.minProperties = maximumValue;\ndefaultResolvers.properties = propertiesResolver;\ndefaultResolvers.propertyNames = schemaResolver;\ndefaultResolvers.required = required;\ndefaultResolvers.title = first;\ndefaultResolvers.uniqueItems = uniqueItems;\nconst defaultComplexResolvers = {\n  properties: propertiesResolver,\n  items: itemsResolver\n};\nfunction merger(rootSchema, options, totalSchemas) {\n  totalSchemas = totalSchemas || [];\n  options = defaultsDeep(options, {\n    ignoreAdditionalProperties: false,\n    resolvers: defaultResolvers,\n    complexResolvers: defaultComplexResolvers,\n    deep: true\n  });\n  const complexResolvers = Object.entries(options.complexResolvers);\n  function mergeSchemas(schemas, base, parents) {\n    schemas = cloneDeep(schemas.filter(notUndefined));\n    parents = parents || [];\n    const merged = isPlainObject(base) ? base : {};\n\n    // return undefined, an empty schema\n    if (!schemas.length) {\n      return;\n    }\n    if (schemas.some(isFalse)) {\n      return false;\n    }\n    if (schemas.every(isTrue)) {\n      return true;\n    }\n\n    // there are no false and we don't need the true ones as they accept everything\n    schemas = schemas.filter(isPlainObject);\n    const allKeys = allUniqueKeys(schemas);\n    if (options.deep && contains(allKeys, 'allOf')) {\n      return merger({\n        allOf: schemas\n      }, options, totalSchemas);\n    }\n    const complexKeysArr = complexResolvers.map(_ref => {\n      let [mainKeyWord, resolverConf] = _ref;\n      return allKeys.filter(k => resolverConf.keywords.includes(k));\n    });\n\n    // remove all complex keys before simple resolvers\n    complexKeysArr.forEach(keys => pullAll(allKeys, keys));\n\n    // call all simple resolvers for relevant keywords\n    allKeys.forEach(function (key) {\n      const values = getValues(schemas, key);\n      const compacted = uniqWith(values.filter(notUndefined), compareProp(key));\n\n      // arrayprops like anyOf and oneOf must be merged first, as they contains schemas\n      // allOf is treated differently alltogether\n      if (compacted.length === 1 && contains(schemaArrays, key)) {\n        merged[key] = compacted[0].map(schema => mergeSchemas([schema], schema));\n        // prop groups must always be resolved\n      } else if (compacted.length === 1 && !contains(schemaGroupProps, key) && !contains(schemaProps, key)) {\n        merged[key] = compacted[0];\n      } else {\n        const resolver = options.resolvers[key] || options.resolvers.defaultResolver;\n        if (!resolver) throw new Error('No resolver found for key ' + key + '. You can provide a resolver for this keyword in the options, or provide a default resolver.');\n        const merger = function (schemas) {\n          let extraKey = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n          return mergeSchemas(schemas, null, parents.concat(key, extraKey));\n        };\n        merged[key] = resolver(compacted, parents.concat(key), merger, options);\n        if (merged[key] === undefined) {\n          throwIncompatible(compacted, parents.concat(key));\n        } else if (merged[key] === undefined) {\n          delete merged[key];\n        }\n      }\n    });\n    return complexResolvers.reduce((all, _ref2, index) => {\n      let [resolverKeyword, config] = _ref2;\n      return {\n        ...all,\n        ...callGroupResolver(complexKeysArr[index], resolverKeyword, schemas, mergeSchemas, options, parents)\n      };\n    }, merged);\n  }\n  const allSchemas = flattenDeep(getAllOf(rootSchema));\n  const merged = mergeSchemas(allSchemas);\n  return merged;\n}\nmerger.options = {\n  resolvers: defaultResolvers\n};\nmodule.exports = merger;","map":{"version":3,"names":["cloneDeep","require","compare","computeLcm","defaultsDeep","flatten","flattenDeep","intersection","intersectionWith","isEqual","isPlainObject","pullAll","sortBy","uniq","uniqWith","propertiesResolver","itemsResolver","contains","arr","val","indexOf","isSchema","isFalse","isTrue","schemaResolver","compacted","key","mergeSchemas","stringArray","values","notUndefined","undefined","allUniqueKeys","map","keys","first","required","maximumValue","Math","max","apply","minimumValue","min","uniqueItems","some","examples","compareProp","a","b","getAllOf","schema","allOf","copy","getValues","schemas","tryMergeSchemaGroups","schemaGroups","index","e","filter","obj","Array","isArray","Object","getAnyOfCombinations","arrOfArrays","combinations","length","slice","shift","rest","combination","item","concat","throwIncompatible","paths","asJSON","JSON","stringify","join","variable","Error","callGroupResolver","complexKeywords","resolverName","options","parents","resolverConfig","complexResolvers","resolver","extractedKeywordsOnly","reduce","all","unique","mergers","keywords","extraKey","arguments","result","createRequiredMetaArray","schemaGroupProps","schemaArrays","schemaProps","defaultResolvers","type","normalized","common","dependencies","allChildren","childKey","childSchemas","innerCompacted","innerArrays","innerSchemas","arrayMetaScheams","oneOf","not","anyOf","pattern","r","multipleOf","integers","factor","n","Number","isInteger","enum","enums","$id","$ref","$schema","additionalItems","additionalProperties","default","definitions","description","exclusiveMaximum","exclusiveMinimum","items","maximum","maxItems","maxLength","maxProperties","minimum","minItems","minLength","minProperties","properties","propertyNames","title","defaultComplexResolvers","merger","rootSchema","totalSchemas","ignoreAdditionalProperties","resolvers","deep","entries","base","merged","every","allKeys","complexKeysArr","_ref","mainKeyWord","resolverConf","k","includes","forEach","defaultResolver","_ref2","resolverKeyword","config","allSchemas","module","exports"],"sources":["D:/Reactjs/my-app/node_modules/json-schema-merge-allof/src/index.js"],"sourcesContent":["const cloneDeep = require('lodash/cloneDeep')\nconst compare = require('json-schema-compare')\nconst computeLcm = require('compute-lcm')\nconst defaultsDeep = require('lodash/defaultsDeep')\nconst flatten = require('lodash/flatten')\nconst flattenDeep = require('lodash/flattenDeep')\nconst intersection = require('lodash/intersection')\nconst intersectionWith = require('lodash/intersectionWith')\nconst isEqual = require('lodash/isEqual')\nconst isPlainObject = require('lodash/isPlainObject')\nconst pullAll = require('lodash/pullAll')\nconst sortBy = require('lodash/sortBy')\nconst uniq = require('lodash/uniq')\nconst uniqWith = require('lodash/uniqWith')\n\nconst propertiesResolver = require('./complex-resolvers/properties')\nconst itemsResolver = require('./complex-resolvers/items')\n\nconst contains = (arr, val) => arr.indexOf(val) !== -1\nconst isSchema = (val) => isPlainObject(val) || val === true || val === false\nconst isFalse = (val) => val === false\nconst isTrue = (val) => val === true\nconst schemaResolver = (compacted, key, mergeSchemas) => mergeSchemas(compacted)\nconst stringArray = (values) => sortBy(uniq(flattenDeep(values)))\nconst notUndefined = (val) => val !== undefined\nconst allUniqueKeys = (arr) => uniq(flattenDeep(arr.map(keys)))\n\n// resolvers\nconst first = compacted => compacted[0]\nconst required = compacted => stringArray(compacted)\nconst maximumValue = compacted => Math.max.apply(Math, compacted)\nconst minimumValue = compacted => Math.min.apply(Math, compacted)\nconst uniqueItems = compacted => compacted.some(isTrue)\nconst examples = compacted => uniqWith(flatten(compacted), isEqual)\n\nfunction compareProp(key) {\n  return function(a, b) {\n    return compare({\n      [key]: a\n    }, { [key]: b })\n  }\n}\n\nfunction getAllOf(schema) {\n  let { allOf = [], ...copy } = schema\n  copy = isPlainObject(schema) ? copy : schema // if schema is boolean\n  return [copy, ...allOf.map(getAllOf)]\n}\n\nfunction getValues(schemas, key) {\n  return schemas.map(schema => schema && schema[key])\n}\n\nfunction tryMergeSchemaGroups(schemaGroups, mergeSchemas) {\n  return schemaGroups.map(function(schemas, index) {\n    try {\n      return mergeSchemas(schemas, index)\n    } catch (e) {\n      return undefined\n    }\n  }).filter(notUndefined)\n}\n\nfunction keys(obj) {\n  if (isPlainObject(obj) || Array.isArray(obj)) {\n    return Object.keys(obj)\n  } else {\n    return []\n  }\n}\n\nfunction getAnyOfCombinations(arrOfArrays, combinations) {\n  combinations = combinations || []\n  if (!arrOfArrays.length) {\n    return combinations\n  }\n\n  const values = arrOfArrays.slice(0).shift()\n  const rest = arrOfArrays.slice(1)\n  if (combinations.length) {\n    return getAnyOfCombinations(rest, flatten(combinations.map(combination => values.map(item => ([item].concat(combination))))))\n  }\n  return getAnyOfCombinations(rest, values.map(item => (item)))\n}\n\nfunction throwIncompatible(values, paths) {\n  let asJSON\n  try {\n    asJSON = values.map(function(val) {\n      return JSON.stringify(val, null, 2)\n    }).join('\\n')\n  } catch (variable) {\n    asJSON = values.join(', ')\n  }\n  throw new Error('Could not resolve values for path:\"' + paths.join('.') + '\". They are probably incompatible. Values: \\n' + asJSON)\n}\n\nfunction callGroupResolver(complexKeywords, resolverName, schemas, mergeSchemas, options, parents) {\n  if (complexKeywords.length) {\n    const resolverConfig = options.complexResolvers[resolverName]\n    if (!resolverConfig || !resolverConfig.resolver) {\n      throw new Error('No resolver found for ' + resolverName)\n    }\n\n    // extract all keywords from all the schemas that have one or more\n    // then remove all undefined ones and not unique\n    const extractedKeywordsOnly = schemas.map(schema => complexKeywords.reduce((all, key) => {\n      if (schema[key] !== undefined) all[key] = schema[key]\n      return all\n    }, {}))\n    const unique = uniqWith(extractedKeywordsOnly, compare)\n\n    // create mergers that automatically add the path of the keyword for use in the complex resolver\n    const mergers = resolverConfig.keywords.reduce((all, key) => ({\n      ...all,\n      [key]: (schemas, extraKey = []) => mergeSchemas(schemas, null, parents.concat(key, extraKey))\n    }), {})\n\n    const result = resolverConfig.resolver(unique, parents.concat(resolverName), mergers, options)\n\n    if (!isPlainObject(result)) {\n      throwIncompatible(unique, parents.concat(resolverName))\n    }\n\n    return result\n  }\n}\n\nfunction createRequiredMetaArray(arr) {\n  return { required: arr }\n}\n\nconst schemaGroupProps = ['properties', 'patternProperties', 'definitions', 'dependencies']\nconst schemaArrays = ['anyOf', 'oneOf']\nconst schemaProps = [\n  'additionalProperties',\n  'additionalItems',\n  'contains',\n  'propertyNames',\n  'not',\n  'items'\n]\n\nconst defaultResolvers = {\n  type(compacted) {\n    if (compacted.some(Array.isArray)) {\n      const normalized = compacted.map(function(val) {\n        return Array.isArray(val)\n          ? val\n          : [val]\n      })\n      const common = intersection.apply(null, normalized)\n\n      if (common.length === 1) {\n        return common[0]\n      } else if (common.length > 1) {\n        return uniq(common)\n      }\n    }\n  },\n  dependencies(compacted, paths, mergeSchemas) {\n    const allChildren = allUniqueKeys(compacted)\n\n    return allChildren.reduce(function(all, childKey) {\n      const childSchemas = getValues(compacted, childKey)\n      let innerCompacted = uniqWith(childSchemas.filter(notUndefined), isEqual)\n\n      // to support dependencies\n      const innerArrays = innerCompacted.filter(Array.isArray)\n\n      if (innerArrays.length) {\n        if (innerArrays.length === innerCompacted.length) {\n          all[childKey] = stringArray(innerCompacted)\n        } else {\n          const innerSchemas = innerCompacted.filter(isSchema)\n          const arrayMetaScheams = innerArrays.map(createRequiredMetaArray)\n          all[childKey] = mergeSchemas(innerSchemas.concat(arrayMetaScheams), childKey)\n        }\n        return all\n      }\n\n      innerCompacted = uniqWith(innerCompacted, compare)\n\n      all[childKey] = mergeSchemas(innerCompacted, childKey)\n      return all\n    }, {})\n  },\n  oneOf(compacted, paths, mergeSchemas) {\n    const combinations = getAnyOfCombinations(cloneDeep(compacted))\n    const result = tryMergeSchemaGroups(combinations, mergeSchemas)\n    const unique = uniqWith(result, compare)\n\n    if (unique.length) {\n      return unique\n    }\n  },\n  not(compacted) {\n    return { anyOf: compacted }\n  },\n  pattern(compacted) {\n    return compacted.map(r => '(?=' + r + ')').join('')\n  },\n  multipleOf(compacted) {\n    let integers = compacted.slice(0)\n    let factor = 1\n    while (integers.some(n => !Number.isInteger(n))) {\n      integers = integers.map(n => n * 10)\n      factor = factor * 10\n    }\n    return computeLcm(integers) / factor\n  },\n  enum(compacted) {\n    const enums = intersectionWith.apply(null, compacted.concat(isEqual))\n    if (enums.length) {\n      return sortBy(enums)\n    }\n  }\n}\n\ndefaultResolvers.$id = first\ndefaultResolvers.$ref = first\ndefaultResolvers.$schema = first\ndefaultResolvers.additionalItems = schemaResolver\ndefaultResolvers.additionalProperties = schemaResolver\ndefaultResolvers.anyOf = defaultResolvers.oneOf\ndefaultResolvers.contains = schemaResolver\ndefaultResolvers.default = first\ndefaultResolvers.definitions = defaultResolvers.dependencies\ndefaultResolvers.description = first\ndefaultResolvers.examples = examples\ndefaultResolvers.exclusiveMaximum = minimumValue\ndefaultResolvers.exclusiveMinimum = maximumValue\ndefaultResolvers.items = itemsResolver\ndefaultResolvers.maximum = minimumValue\ndefaultResolvers.maxItems = minimumValue\ndefaultResolvers.maxLength = minimumValue\ndefaultResolvers.maxProperties = minimumValue\ndefaultResolvers.minimum = maximumValue\ndefaultResolvers.minItems = maximumValue\ndefaultResolvers.minLength = maximumValue\ndefaultResolvers.minProperties = maximumValue\ndefaultResolvers.properties = propertiesResolver\ndefaultResolvers.propertyNames = schemaResolver\ndefaultResolvers.required = required\ndefaultResolvers.title = first\ndefaultResolvers.uniqueItems = uniqueItems\n\nconst defaultComplexResolvers = {\n  properties: propertiesResolver,\n  items: itemsResolver\n}\n\nfunction merger(rootSchema, options, totalSchemas) {\n  totalSchemas = totalSchemas || []\n  options = defaultsDeep(options, {\n    ignoreAdditionalProperties: false,\n    resolvers: defaultResolvers,\n    complexResolvers: defaultComplexResolvers,\n    deep: true\n  })\n\n  const complexResolvers = Object.entries(options.complexResolvers)\n\n  function mergeSchemas(schemas, base, parents) {\n    schemas = cloneDeep(schemas.filter(notUndefined))\n    parents = parents || []\n    const merged = isPlainObject(base)\n      ? base\n      : {}\n\n    // return undefined, an empty schema\n    if (!schemas.length) {\n      return\n    }\n\n    if (schemas.some(isFalse)) {\n      return false\n    }\n\n    if (schemas.every(isTrue)) {\n      return true\n    }\n\n    // there are no false and we don't need the true ones as they accept everything\n    schemas = schemas.filter(isPlainObject)\n\n    const allKeys = allUniqueKeys(schemas)\n    if (options.deep && contains(allKeys, 'allOf')) {\n      return merger({\n        allOf: schemas\n      }, options, totalSchemas)\n    }\n\n    const complexKeysArr = complexResolvers.map(([mainKeyWord, resolverConf]) =>\n      allKeys.filter(k => resolverConf.keywords.includes(k)))\n\n    // remove all complex keys before simple resolvers\n    complexKeysArr.forEach(keys => pullAll(allKeys, keys))\n\n    // call all simple resolvers for relevant keywords\n    allKeys.forEach(function(key) {\n      const values = getValues(schemas, key)\n      const compacted = uniqWith(values.filter(notUndefined), compareProp(key))\n\n      // arrayprops like anyOf and oneOf must be merged first, as they contains schemas\n      // allOf is treated differently alltogether\n      if (compacted.length === 1 && contains(schemaArrays, key)) {\n        merged[key] = compacted[0].map(schema => mergeSchemas([schema], schema))\n        // prop groups must always be resolved\n      } else if (compacted.length === 1 && !contains(schemaGroupProps, key) && !contains(schemaProps, key)) {\n        merged[key] = compacted[0]\n      } else {\n        const resolver = options.resolvers[key] || options.resolvers.defaultResolver\n        if (!resolver) throw new Error('No resolver found for key ' + key + '. You can provide a resolver for this keyword in the options, or provide a default resolver.')\n\n        const merger = (schemas, extraKey = []) => mergeSchemas(schemas, null, parents.concat(key, extraKey))\n        merged[key] = resolver(compacted, parents.concat(key), merger, options)\n\n        if (merged[key] === undefined) {\n          throwIncompatible(compacted, parents.concat(key))\n        } else if (merged[key] === undefined) {\n          delete merged[key]\n        }\n      }\n    })\n\n    return complexResolvers.reduce((all, [resolverKeyword, config], index) => ({\n      ...all,\n      ...callGroupResolver(complexKeysArr[index], resolverKeyword, schemas, mergeSchemas, options, parents)\n    }), merged)\n  }\n\n  const allSchemas = flattenDeep(getAllOf(rootSchema))\n  const merged = mergeSchemas(allSchemas)\n\n  return merged\n}\n\nmerger.options = {\n  resolvers: defaultResolvers\n}\n\nmodule.exports = merger\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}