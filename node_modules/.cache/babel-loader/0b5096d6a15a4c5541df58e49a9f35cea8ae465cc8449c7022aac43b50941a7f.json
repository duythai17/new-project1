{"ast":null,"code":"import toPath from 'lodash/toPath';\nimport ErrorSchemaBuilder from './ErrorSchemaBuilder';\n/** Transforms a rjsf validation errors list:\n * [\n *   {property: '.level1.level2[2].level3', message: 'err a'},\n *   {property: '.level1.level2[2].level3', message: 'err b'},\n *   {property: '.level1.level2[4].level3', message: 'err b'},\n * ]\n * Into an error tree:\n * {\n *   level1: {\n *     level2: {\n *       2: {level3: {errors: ['err a', 'err b']}},\n *       4: {level3: {errors: ['err b']}},\n *     }\n *   }\n * };\n *\n * @param errors - The list of RJSFValidationError objects\n * @returns - The `ErrorSchema` built from the list of `RJSFValidationErrors`\n */\nexport default function toErrorSchema(errors) {\n  const builder = new ErrorSchemaBuilder();\n  if (errors.length) {\n    errors.forEach(error => {\n      const {\n        property,\n        message\n      } = error;\n      // When the property is the root element, just use an empty array for the path\n      const path = property === '.' ? [] : toPath(property);\n      // If the property is at the root (.level1) then toPath creates\n      // an empty array element at the first index. Remove it.\n      if (path.length > 0 && path[0] === '') {\n        path.splice(0, 1);\n      }\n      if (message) {\n        builder.addErrors(message, path);\n      }\n    });\n  }\n  return builder.ErrorSchema;\n}","map":{"version":3,"names":["toPath","ErrorSchemaBuilder","toErrorSchema","errors","builder","length","forEach","error","property","message","path","splice","addErrors","ErrorSchema"],"sources":["D:\\Reactjs\\my-app\\node_modules\\@rjsf\\utils\\src\\toErrorSchema.ts"],"sourcesContent":["import toPath from 'lodash/toPath';\n\nimport { ErrorSchema, RJSFValidationError } from './types';\nimport ErrorSchemaBuilder from './ErrorSchemaBuilder';\n\n/** Transforms a rjsf validation errors list:\n * [\n *   {property: '.level1.level2[2].level3', message: 'err a'},\n *   {property: '.level1.level2[2].level3', message: 'err b'},\n *   {property: '.level1.level2[4].level3', message: 'err b'},\n * ]\n * Into an error tree:\n * {\n *   level1: {\n *     level2: {\n *       2: {level3: {errors: ['err a', 'err b']}},\n *       4: {level3: {errors: ['err b']}},\n *     }\n *   }\n * };\n *\n * @param errors - The list of RJSFValidationError objects\n * @returns - The `ErrorSchema` built from the list of `RJSFValidationErrors`\n */\nexport default function toErrorSchema<T = any>(errors: RJSFValidationError[]): ErrorSchema<T> {\n  const builder = new ErrorSchemaBuilder<T>();\n  if (errors.length) {\n    errors.forEach((error) => {\n      const { property, message } = error;\n      // When the property is the root element, just use an empty array for the path\n      const path = property === '.' ? [] : toPath(property);\n      // If the property is at the root (.level1) then toPath creates\n      // an empty array element at the first index. Remove it.\n      if (path.length > 0 && path[0] === '') {\n        path.splice(0, 1);\n      }\n      if (message) {\n        builder.addErrors(message, path);\n      }\n    });\n  }\n  return builder.ErrorSchema;\n}\n"],"mappings":"AAAA,OAAOA,MAAM,MAAM,eAAe;AAGlC,OAAOC,kBAAkB,MAAM,sBAAsB;AAErD;;;;;;;;;;;;;;;;;;;AAmBA,eAAc,SAAUC,aAAaA,CAAUC,MAA6B;EAC1E,MAAMC,OAAO,GAAG,IAAIH,kBAAkB,EAAK;EAC3C,IAAIE,MAAM,CAACE,MAAM,EAAE;IACjBF,MAAM,CAACG,OAAO,CAAEC,KAAK,IAAI;MACvB,MAAM;QAAEC,QAAQ;QAAEC;MAAO,CAAE,GAAGF,KAAK;MACnC;MACA,MAAMG,IAAI,GAAGF,QAAQ,KAAK,GAAG,GAAG,EAAE,GAAGR,MAAM,CAACQ,QAAQ,CAAC;MACrD;MACA;MACA,IAAIE,IAAI,CAACL,MAAM,GAAG,CAAC,IAAIK,IAAI,CAAC,CAAC,CAAC,KAAK,EAAE,EAAE;QACrCA,IAAI,CAACC,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC;;MAEnB,IAAIF,OAAO,EAAE;QACXL,OAAO,CAACQ,SAAS,CAACH,OAAO,EAAEC,IAAI,CAAC;;IAEpC,CAAC,CAAC;;EAEJ,OAAON,OAAO,CAACS,WAAW;AAC5B"},"metadata":{},"sourceType":"module","externalDependencies":[]}