{"ast":null,"code":"/** Given the `FileReader.readAsDataURL()` based `dataURI` extracts that data into an actual Blob along with the name\n * of that Blob if provided in the URL. If no name is provided, then the name falls back to `unknown`.\n *\n * @param dataURI - The `DataUrl` potentially containing name and raw data to be converted to a Blob\n * @returns - an object containing a Blob and its name, extracted from the URI\n */\nexport default function dataURItoBlob(dataURI) {\n  // Split metadata from data\n  const splitted = dataURI.split(',');\n  // Split params\n  const params = splitted[0].split(';');\n  // Get mime-type from params\n  const type = params[0].replace('data:', '');\n  // Filter the name property from params\n  const properties = params.filter(param => {\n    return param.split('=')[0] === 'name';\n  });\n  // Look for the name and use unknown if no name property.\n  let name;\n  if (properties.length !== 1) {\n    name = 'unknown';\n  } else {\n    // Because we filtered out the other property,\n    // we only have the name case here, which we decode to make it human-readable\n    name = decodeURI(properties[0].split('=')[1]);\n  }\n  // Built the Uint8Array Blob parameter from the base64 string.\n  try {\n    const binary = atob(splitted[1]);\n    const array = [];\n    for (let i = 0; i < binary.length; i++) {\n      array.push(binary.charCodeAt(i));\n    }\n    // Create the blob object\n    const blob = new window.Blob([new Uint8Array(array)], {\n      type\n    });\n    return {\n      blob,\n      name\n    };\n  } catch (error) {\n    return {\n      blob: {\n        size: 0,\n        type: error.message\n      },\n      name: dataURI\n    };\n  }\n}","map":{"version":3,"names":["dataURItoBlob","dataURI","splitted","split","params","type","replace","properties","filter","param","name","length","decodeURI","binary","atob","array","i","push","charCodeAt","blob","window","Blob","Uint8Array","error","size","message"],"sources":["D:\\Reactjs\\my-app\\node_modules\\@rjsf\\utils\\src\\dataURItoBlob.ts"],"sourcesContent":["/** Given the `FileReader.readAsDataURL()` based `dataURI` extracts that data into an actual Blob along with the name\n * of that Blob if provided in the URL. If no name is provided, then the name falls back to `unknown`.\n *\n * @param dataURI - The `DataUrl` potentially containing name and raw data to be converted to a Blob\n * @returns - an object containing a Blob and its name, extracted from the URI\n */\nexport default function dataURItoBlob(dataURI: string) {\n  // Split metadata from data\n  const splitted: string[] = dataURI.split(',');\n  // Split params\n  const params: string[] = splitted[0].split(';');\n  // Get mime-type from params\n  const type: string = params[0].replace('data:', '');\n  // Filter the name property from params\n  const properties = params.filter((param) => {\n    return param.split('=')[0] === 'name';\n  });\n  // Look for the name and use unknown if no name property.\n  let name: string;\n  if (properties.length !== 1) {\n    name = 'unknown';\n  } else {\n    // Because we filtered out the other property,\n    // we only have the name case here, which we decode to make it human-readable\n    name = decodeURI(properties[0].split('=')[1]);\n  }\n\n  // Built the Uint8Array Blob parameter from the base64 string.\n  try {\n    const binary = atob(splitted[1]);\n    const array = [];\n    for (let i = 0; i < binary.length; i++) {\n      array.push(binary.charCodeAt(i));\n    }\n    // Create the blob object\n    const blob = new window.Blob([new Uint8Array(array)], { type });\n\n    return { blob, name };\n  } catch (error) {\n    return { blob: { size: 0, type: (error as Error).message }, name: dataURI };\n  }\n}\n"],"mappings":"AAAA;;;;;;AAMA,eAAc,SAAUA,aAAaA,CAACC,OAAe;EACnD;EACA,MAAMC,QAAQ,GAAaD,OAAO,CAACE,KAAK,CAAC,GAAG,CAAC;EAC7C;EACA,MAAMC,MAAM,GAAaF,QAAQ,CAAC,CAAC,CAAC,CAACC,KAAK,CAAC,GAAG,CAAC;EAC/C;EACA,MAAME,IAAI,GAAWD,MAAM,CAAC,CAAC,CAAC,CAACE,OAAO,CAAC,OAAO,EAAE,EAAE,CAAC;EACnD;EACA,MAAMC,UAAU,GAAGH,MAAM,CAACI,MAAM,CAAEC,KAAK,IAAI;IACzC,OAAOA,KAAK,CAACN,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,KAAK,MAAM;EACvC,CAAC,CAAC;EACF;EACA,IAAIO,IAAY;EAChB,IAAIH,UAAU,CAACI,MAAM,KAAK,CAAC,EAAE;IAC3BD,IAAI,GAAG,SAAS;GACjB,MAAM;IACL;IACA;IACAA,IAAI,GAAGE,SAAS,CAACL,UAAU,CAAC,CAAC,CAAC,CAACJ,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;;EAG/C;EACA,IAAI;IACF,MAAMU,MAAM,GAAGC,IAAI,CAACZ,QAAQ,CAAC,CAAC,CAAC,CAAC;IAChC,MAAMa,KAAK,GAAG,EAAE;IAChB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGH,MAAM,CAACF,MAAM,EAAEK,CAAC,EAAE,EAAE;MACtCD,KAAK,CAACE,IAAI,CAACJ,MAAM,CAACK,UAAU,CAACF,CAAC,CAAC,CAAC;;IAElC;IACA,MAAMG,IAAI,GAAG,IAAIC,MAAM,CAACC,IAAI,CAAC,CAAC,IAAIC,UAAU,CAACP,KAAK,CAAC,CAAC,EAAE;MAAEV;IAAI,CAAE,CAAC;IAE/D,OAAO;MAAEc,IAAI;MAAET;IAAI,CAAE;GACtB,CAAC,OAAOa,KAAK,EAAE;IACd,OAAO;MAAEJ,IAAI,EAAE;QAAEK,IAAI,EAAE,CAAC;QAAEnB,IAAI,EAAGkB,KAAe,CAACE;MAAO,CAAE;MAAEf,IAAI,EAAET;IAAO,CAAE;;AAE/E"},"metadata":{},"sourceType":"module","externalDependencies":[]}